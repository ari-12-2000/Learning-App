
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Learner
 * 
 */
export type Learner = $Result.DefaultSelection<Prisma.$LearnerPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model Module
 * 
 */
export type Module = $Result.DefaultSelection<Prisma.$ModulePayload>
/**
 * Model Enrollment
 * 
 */
export type Enrollment = $Result.DefaultSelection<Prisma.$EnrollmentPayload>
/**
 * Model ProgramModule
 * 
 */
export type ProgramModule = $Result.DefaultSelection<Prisma.$ProgramModulePayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model ModuleTopic
 * 
 */
export type ModuleTopic = $Result.DefaultSelection<Prisma.$ModuleTopicPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model TopicResource
 * 
 */
export type TopicResource = $Result.DefaultSelection<Prisma.$TopicResourcePayload>
/**
 * Model QuestionPool
 * 
 */
export type QuestionPool = $Result.DefaultSelection<Prisma.$QuestionPoolPayload>
/**
 * Model QuizPaper
 * 
 */
export type QuizPaper = $Result.DefaultSelection<Prisma.$QuizPaperPayload>
/**
 * Model QuizPaperQuestion
 * 
 */
export type QuizPaperQuestion = $Result.DefaultSelection<Prisma.$QuizPaperQuestionPayload>
/**
 * Model QuizAssignment
 * 
 */
export type QuizAssignment = $Result.DefaultSelection<Prisma.$QuizAssignmentPayload>
/**
 * Model QuizAttempt
 * 
 */
export type QuizAttempt = $Result.DefaultSelection<Prisma.$QuizAttemptPayload>
/**
 * Model QuestionAttempt
 * 
 */
export type QuestionAttempt = $Result.DefaultSelection<Prisma.$QuestionAttemptPayload>
/**
 * Model ResourceView
 * 
 */
export type ResourceView = $Result.DefaultSelection<Prisma.$ResourceViewPayload>
/**
 * Model MeasureProgress
 * 
 */
export type MeasureProgress = $Result.DefaultSelection<Prisma.$MeasureProgressPayload>
/**
 * Model Leaderboard
 * 
 */
export type Leaderboard = $Result.DefaultSelection<Prisma.$LeaderboardPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AdminType: {
  SystemAdmin: 'SystemAdmin',
  PartnerAdmin: 'PartnerAdmin'
};

export type AdminType = (typeof AdminType)[keyof typeof AdminType]


export const ProgramType: {
  self_paced: 'self_paced',
  tutor_paced: 'tutor_paced',
  workshop: 'workshop',
  webinar: 'webinar'
};

export type ProgramType = (typeof ProgramType)[keyof typeof ProgramType]


export const ResourceType: {
  video: 'video',
  document: 'document',
  image: 'image',
  other: 'other'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const QuestionType: {
  mcq_single: 'mcq_single',
  true_false: 'true_false',
  fill_blank: 'fill_blank',
  slider: 'slider',
  text: 'text'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const TimeMode: {
  none: 'none',
  qns: 'qns',
  exam: 'exam'
};

export type TimeMode = (typeof TimeMode)[keyof typeof TimeMode]


export const WrongAnswerMode: {
  none: 'none',
  retry: 'retry',
  correct_ans: 'correct_ans'
};

export type WrongAnswerMode = (typeof WrongAnswerMode)[keyof typeof WrongAnswerMode]


export const ResultMode: {
  none: 'none',
  exam_ends: 'exam_ends',
  later: 'later'
};

export type ResultMode = (typeof ResultMode)[keyof typeof ResultMode]

}

export type AdminType = $Enums.AdminType

export const AdminType: typeof $Enums.AdminType

export type ProgramType = $Enums.ProgramType

export const ProgramType: typeof $Enums.ProgramType

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type TimeMode = $Enums.TimeMode

export const TimeMode: typeof $Enums.TimeMode

export type WrongAnswerMode = $Enums.WrongAnswerMode

export const WrongAnswerMode: typeof $Enums.WrongAnswerMode

export type ResultMode = $Enums.ResultMode

export const ResultMode: typeof $Enums.ResultMode

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Admins
 * const admins = await prisma.admin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Admins
   * const admins = await prisma.admin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.learner`: Exposes CRUD operations for the **Learner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Learners
    * const learners = await prisma.learner.findMany()
    * ```
    */
  get learner(): Prisma.LearnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.module`: Exposes CRUD operations for the **Module** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Modules
    * const modules = await prisma.module.findMany()
    * ```
    */
  get module(): Prisma.ModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollment`: Exposes CRUD operations for the **Enrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollment.findMany()
    * ```
    */
  get enrollment(): Prisma.EnrollmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.programModule`: Exposes CRUD operations for the **ProgramModule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramModules
    * const programModules = await prisma.programModule.findMany()
    * ```
    */
  get programModule(): Prisma.ProgramModuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.moduleTopic`: Exposes CRUD operations for the **ModuleTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModuleTopics
    * const moduleTopics = await prisma.moduleTopic.findMany()
    * ```
    */
  get moduleTopic(): Prisma.ModuleTopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topicResource`: Exposes CRUD operations for the **TopicResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopicResources
    * const topicResources = await prisma.topicResource.findMany()
    * ```
    */
  get topicResource(): Prisma.TopicResourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionPool`: Exposes CRUD operations for the **QuestionPool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionPools
    * const questionPools = await prisma.questionPool.findMany()
    * ```
    */
  get questionPool(): Prisma.QuestionPoolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizPaper`: Exposes CRUD operations for the **QuizPaper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizPapers
    * const quizPapers = await prisma.quizPaper.findMany()
    * ```
    */
  get quizPaper(): Prisma.QuizPaperDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizPaperQuestion`: Exposes CRUD operations for the **QuizPaperQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizPaperQuestions
    * const quizPaperQuestions = await prisma.quizPaperQuestion.findMany()
    * ```
    */
  get quizPaperQuestion(): Prisma.QuizPaperQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAssignment`: Exposes CRUD operations for the **QuizAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAssignments
    * const quizAssignments = await prisma.quizAssignment.findMany()
    * ```
    */
  get quizAssignment(): Prisma.QuizAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAttempt`: Exposes CRUD operations for the **QuizAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAttempts
    * const quizAttempts = await prisma.quizAttempt.findMany()
    * ```
    */
  get quizAttempt(): Prisma.QuizAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionAttempt`: Exposes CRUD operations for the **QuestionAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionAttempts
    * const questionAttempts = await prisma.questionAttempt.findMany()
    * ```
    */
  get questionAttempt(): Prisma.QuestionAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resourceView`: Exposes CRUD operations for the **ResourceView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ResourceViews
    * const resourceViews = await prisma.resourceView.findMany()
    * ```
    */
  get resourceView(): Prisma.ResourceViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.measureProgress`: Exposes CRUD operations for the **MeasureProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeasureProgresses
    * const measureProgresses = await prisma.measureProgress.findMany()
    * ```
    */
  get measureProgress(): Prisma.MeasureProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaderboard`: Exposes CRUD operations for the **Leaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaderboards
    * const leaderboards = await prisma.leaderboard.findMany()
    * ```
    */
  get leaderboard(): Prisma.LeaderboardDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.0
   * Query Engine version: aee10d5a411e4360c6d3445ce4810ca65adbf3e8
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Admin: 'Admin',
    Learner: 'Learner',
    Program: 'Program',
    Module: 'Module',
    Enrollment: 'Enrollment',
    ProgramModule: 'ProgramModule',
    Topic: 'Topic',
    ModuleTopic: 'ModuleTopic',
    Resource: 'Resource',
    TopicResource: 'TopicResource',
    QuestionPool: 'QuestionPool',
    QuizPaper: 'QuizPaper',
    QuizPaperQuestion: 'QuizPaperQuestion',
    QuizAssignment: 'QuizAssignment',
    QuizAttempt: 'QuizAttempt',
    QuestionAttempt: 'QuestionAttempt',
    ResourceView: 'ResourceView',
    MeasureProgress: 'MeasureProgress',
    Leaderboard: 'Leaderboard'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "admin" | "learner" | "program" | "module" | "enrollment" | "programModule" | "topic" | "moduleTopic" | "resource" | "topicResource" | "questionPool" | "quizPaper" | "quizPaperQuestion" | "quizAssignment" | "quizAttempt" | "questionAttempt" | "resourceView" | "measureProgress" | "leaderboard"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Learner: {
        payload: Prisma.$LearnerPayload<ExtArgs>
        fields: Prisma.LearnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload>
          }
          findFirst: {
            args: Prisma.LearnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload>
          }
          findMany: {
            args: Prisma.LearnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload>[]
          }
          create: {
            args: Prisma.LearnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload>
          }
          createMany: {
            args: Prisma.LearnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload>[]
          }
          delete: {
            args: Prisma.LearnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload>
          }
          update: {
            args: Prisma.LearnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload>
          }
          deleteMany: {
            args: Prisma.LearnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LearnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload>[]
          }
          upsert: {
            args: Prisma.LearnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnerPayload>
          }
          aggregate: {
            args: Prisma.LearnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearner>
          }
          groupBy: {
            args: Prisma.LearnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearnerCountArgs<ExtArgs>
            result: $Utils.Optional<LearnerCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      Module: {
        payload: Prisma.$ModulePayload<ExtArgs>
        fields: Prisma.ModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findFirst: {
            args: Prisma.ModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          findMany: {
            args: Prisma.ModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          create: {
            args: Prisma.ModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          createMany: {
            args: Prisma.ModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          delete: {
            args: Prisma.ModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          update: {
            args: Prisma.ModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          deleteMany: {
            args: Prisma.ModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>[]
          }
          upsert: {
            args: Prisma.ModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModulePayload>
          }
          aggregate: {
            args: Prisma.ModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModule>
          }
          groupBy: {
            args: Prisma.ModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleCountAggregateOutputType> | number
          }
        }
      }
      Enrollment: {
        payload: Prisma.$EnrollmentPayload<ExtArgs>
        fields: Prisma.EnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findFirst: {
            args: Prisma.EnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          findMany: {
            args: Prisma.EnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          create: {
            args: Prisma.EnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          createMany: {
            args: Prisma.EnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          delete: {
            args: Prisma.EnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          update: {
            args: Prisma.EnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.EnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EnrollmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>[]
          }
          upsert: {
            args: Prisma.EnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EnrollmentPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollment>
          }
          groupBy: {
            args: Prisma.EnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentCountAggregateOutputType> | number
          }
        }
      }
      ProgramModule: {
        payload: Prisma.$ProgramModulePayload<ExtArgs>
        fields: Prisma.ProgramModuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramModuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramModuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload>
          }
          findFirst: {
            args: Prisma.ProgramModuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramModuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload>
          }
          findMany: {
            args: Prisma.ProgramModuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload>[]
          }
          create: {
            args: Prisma.ProgramModuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload>
          }
          createMany: {
            args: Prisma.ProgramModuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramModuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload>[]
          }
          delete: {
            args: Prisma.ProgramModuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload>
          }
          update: {
            args: Prisma.ProgramModuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload>
          }
          deleteMany: {
            args: Prisma.ProgramModuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramModuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProgramModuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload>[]
          }
          upsert: {
            args: Prisma.ProgramModuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramModulePayload>
          }
          aggregate: {
            args: Prisma.ProgramModuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramModule>
          }
          groupBy: {
            args: Prisma.ProgramModuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramModuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramModuleCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramModuleCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      ModuleTopic: {
        payload: Prisma.$ModuleTopicPayload<ExtArgs>
        fields: Prisma.ModuleTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModuleTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModuleTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload>
          }
          findFirst: {
            args: Prisma.ModuleTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModuleTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload>
          }
          findMany: {
            args: Prisma.ModuleTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload>[]
          }
          create: {
            args: Prisma.ModuleTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload>
          }
          createMany: {
            args: Prisma.ModuleTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModuleTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload>[]
          }
          delete: {
            args: Prisma.ModuleTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload>
          }
          update: {
            args: Prisma.ModuleTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload>
          }
          deleteMany: {
            args: Prisma.ModuleTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModuleTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModuleTopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload>[]
          }
          upsert: {
            args: Prisma.ModuleTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModuleTopicPayload>
          }
          aggregate: {
            args: Prisma.ModuleTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModuleTopic>
          }
          groupBy: {
            args: Prisma.ModuleTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModuleTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModuleTopicCountArgs<ExtArgs>
            result: $Utils.Optional<ModuleTopicCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      TopicResource: {
        payload: Prisma.$TopicResourcePayload<ExtArgs>
        fields: Prisma.TopicResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload>
          }
          findFirst: {
            args: Prisma.TopicResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload>
          }
          findMany: {
            args: Prisma.TopicResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload>[]
          }
          create: {
            args: Prisma.TopicResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload>
          }
          createMany: {
            args: Prisma.TopicResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload>[]
          }
          delete: {
            args: Prisma.TopicResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload>
          }
          update: {
            args: Prisma.TopicResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload>
          }
          deleteMany: {
            args: Prisma.TopicResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicResourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload>[]
          }
          upsert: {
            args: Prisma.TopicResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicResourcePayload>
          }
          aggregate: {
            args: Prisma.TopicResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopicResource>
          }
          groupBy: {
            args: Prisma.TopicResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicResourceCountArgs<ExtArgs>
            result: $Utils.Optional<TopicResourceCountAggregateOutputType> | number
          }
        }
      }
      QuestionPool: {
        payload: Prisma.$QuestionPoolPayload<ExtArgs>
        fields: Prisma.QuestionPoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionPoolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionPoolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload>
          }
          findFirst: {
            args: Prisma.QuestionPoolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionPoolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload>
          }
          findMany: {
            args: Prisma.QuestionPoolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload>[]
          }
          create: {
            args: Prisma.QuestionPoolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload>
          }
          createMany: {
            args: Prisma.QuestionPoolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionPoolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload>[]
          }
          delete: {
            args: Prisma.QuestionPoolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload>
          }
          update: {
            args: Prisma.QuestionPoolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload>
          }
          deleteMany: {
            args: Prisma.QuestionPoolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionPoolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionPoolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload>[]
          }
          upsert: {
            args: Prisma.QuestionPoolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPoolPayload>
          }
          aggregate: {
            args: Prisma.QuestionPoolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionPool>
          }
          groupBy: {
            args: Prisma.QuestionPoolGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionPoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionPoolCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionPoolCountAggregateOutputType> | number
          }
        }
      }
      QuizPaper: {
        payload: Prisma.$QuizPaperPayload<ExtArgs>
        fields: Prisma.QuizPaperFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizPaperFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizPaperFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload>
          }
          findFirst: {
            args: Prisma.QuizPaperFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizPaperFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload>
          }
          findMany: {
            args: Prisma.QuizPaperFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload>[]
          }
          create: {
            args: Prisma.QuizPaperCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload>
          }
          createMany: {
            args: Prisma.QuizPaperCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizPaperCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload>[]
          }
          delete: {
            args: Prisma.QuizPaperDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload>
          }
          update: {
            args: Prisma.QuizPaperUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload>
          }
          deleteMany: {
            args: Prisma.QuizPaperDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizPaperUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizPaperUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload>[]
          }
          upsert: {
            args: Prisma.QuizPaperUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperPayload>
          }
          aggregate: {
            args: Prisma.QuizPaperAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizPaper>
          }
          groupBy: {
            args: Prisma.QuizPaperGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizPaperGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizPaperCountArgs<ExtArgs>
            result: $Utils.Optional<QuizPaperCountAggregateOutputType> | number
          }
        }
      }
      QuizPaperQuestion: {
        payload: Prisma.$QuizPaperQuestionPayload<ExtArgs>
        fields: Prisma.QuizPaperQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizPaperQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizPaperQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizPaperQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizPaperQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizPaperQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizPaperQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizPaperQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizPaperQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizPaperQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload>
          }
          update: {
            args: Prisma.QuizPaperQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizPaperQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizPaperQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizPaperQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizPaperQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPaperQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizPaperQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizPaperQuestion>
          }
          groupBy: {
            args: Prisma.QuizPaperQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizPaperQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizPaperQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizPaperQuestionCountAggregateOutputType> | number
          }
        }
      }
      QuizAssignment: {
        payload: Prisma.$QuizAssignmentPayload<ExtArgs>
        fields: Prisma.QuizAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload>
          }
          findFirst: {
            args: Prisma.QuizAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload>
          }
          findMany: {
            args: Prisma.QuizAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload>[]
          }
          create: {
            args: Prisma.QuizAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload>
          }
          createMany: {
            args: Prisma.QuizAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload>[]
          }
          delete: {
            args: Prisma.QuizAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload>
          }
          update: {
            args: Prisma.QuizAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.QuizAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.QuizAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAssignmentPayload>
          }
          aggregate: {
            args: Prisma.QuizAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAssignment>
          }
          groupBy: {
            args: Prisma.QuizAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAssignmentCountAggregateOutputType> | number
          }
        }
      }
      QuizAttempt: {
        payload: Prisma.$QuizAttemptPayload<ExtArgs>
        fields: Prisma.QuizAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findFirst: {
            args: Prisma.QuizAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findMany: {
            args: Prisma.QuizAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          create: {
            args: Prisma.QuizAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          createMany: {
            args: Prisma.QuizAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          delete: {
            args: Prisma.QuizAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          update: {
            args: Prisma.QuizAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          deleteMany: {
            args: Prisma.QuizAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          upsert: {
            args: Prisma.QuizAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          aggregate: {
            args: Prisma.QuizAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAttempt>
          }
          groupBy: {
            args: Prisma.QuizAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptCountAggregateOutputType> | number
          }
        }
      }
      QuestionAttempt: {
        payload: Prisma.$QuestionAttemptPayload<ExtArgs>
        fields: Prisma.QuestionAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          findFirst: {
            args: Prisma.QuestionAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          findMany: {
            args: Prisma.QuestionAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>[]
          }
          create: {
            args: Prisma.QuestionAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          createMany: {
            args: Prisma.QuestionAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>[]
          }
          delete: {
            args: Prisma.QuestionAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          update: {
            args: Prisma.QuestionAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          deleteMany: {
            args: Prisma.QuestionAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>[]
          }
          upsert: {
            args: Prisma.QuestionAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAttemptPayload>
          }
          aggregate: {
            args: Prisma.QuestionAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionAttempt>
          }
          groupBy: {
            args: Prisma.QuestionAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionAttemptCountAggregateOutputType> | number
          }
        }
      }
      ResourceView: {
        payload: Prisma.$ResourceViewPayload<ExtArgs>
        fields: Prisma.ResourceViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload>
          }
          findFirst: {
            args: Prisma.ResourceViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload>
          }
          findMany: {
            args: Prisma.ResourceViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload>[]
          }
          create: {
            args: Prisma.ResourceViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload>
          }
          createMany: {
            args: Prisma.ResourceViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResourceViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload>[]
          }
          delete: {
            args: Prisma.ResourceViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload>
          }
          update: {
            args: Prisma.ResourceViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload>
          }
          deleteMany: {
            args: Prisma.ResourceViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResourceViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload>[]
          }
          upsert: {
            args: Prisma.ResourceViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourceViewPayload>
          }
          aggregate: {
            args: Prisma.ResourceViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResourceView>
          }
          groupBy: {
            args: Prisma.ResourceViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceViewCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceViewCountAggregateOutputType> | number
          }
        }
      }
      MeasureProgress: {
        payload: Prisma.$MeasureProgressPayload<ExtArgs>
        fields: Prisma.MeasureProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeasureProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeasureProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload>
          }
          findFirst: {
            args: Prisma.MeasureProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeasureProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload>
          }
          findMany: {
            args: Prisma.MeasureProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload>[]
          }
          create: {
            args: Prisma.MeasureProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload>
          }
          createMany: {
            args: Prisma.MeasureProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeasureProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload>[]
          }
          delete: {
            args: Prisma.MeasureProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload>
          }
          update: {
            args: Prisma.MeasureProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload>
          }
          deleteMany: {
            args: Prisma.MeasureProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeasureProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeasureProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload>[]
          }
          upsert: {
            args: Prisma.MeasureProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeasureProgressPayload>
          }
          aggregate: {
            args: Prisma.MeasureProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeasureProgress>
          }
          groupBy: {
            args: Prisma.MeasureProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeasureProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeasureProgressCountArgs<ExtArgs>
            result: $Utils.Optional<MeasureProgressCountAggregateOutputType> | number
          }
        }
      }
      Leaderboard: {
        payload: Prisma.$LeaderboardPayload<ExtArgs>
        fields: Prisma.LeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findMany: {
            args: Prisma.LeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          create: {
            args: Prisma.LeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          createMany: {
            args: Prisma.LeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaderboardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          delete: {
            args: Prisma.LeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          update: {
            args: Prisma.LeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaderboardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          upsert: {
            args: Prisma.LeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboard>
          }
          groupBy: {
            args: Prisma.LeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    admin?: AdminOmit
    learner?: LearnerOmit
    program?: ProgramOmit
    module?: ModuleOmit
    enrollment?: EnrollmentOmit
    programModule?: ProgramModuleOmit
    topic?: TopicOmit
    moduleTopic?: ModuleTopicOmit
    resource?: ResourceOmit
    topicResource?: TopicResourceOmit
    questionPool?: QuestionPoolOmit
    quizPaper?: QuizPaperOmit
    quizPaperQuestion?: QuizPaperQuestionOmit
    quizAssignment?: QuizAssignmentOmit
    quizAttempt?: QuizAttemptOmit
    questionAttempt?: QuestionAttemptOmit
    resourceView?: ResourceViewOmit
    measureProgress?: MeasureProgressOmit
    leaderboard?: LeaderboardOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    createdAdmins: number
    questions: number
    quizPapers: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdAdmins?: boolean | AdminCountOutputTypeCountCreatedAdminsArgs
    questions?: boolean | AdminCountOutputTypeCountQuestionsArgs
    quizPapers?: boolean | AdminCountOutputTypeCountQuizPapersArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountCreatedAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionPoolWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountQuizPapersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizPaperWhereInput
  }


  /**
   * Count Type LearnerCountOutputType
   */

  export type LearnerCountOutputType = {
    createdLearners: number
    enrollments: number
    quizAttempts: number
    resourceViews: number
    measureProgress: number
    leaderboards: number
  }

  export type LearnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdLearners?: boolean | LearnerCountOutputTypeCountCreatedLearnersArgs
    enrollments?: boolean | LearnerCountOutputTypeCountEnrollmentsArgs
    quizAttempts?: boolean | LearnerCountOutputTypeCountQuizAttemptsArgs
    resourceViews?: boolean | LearnerCountOutputTypeCountResourceViewsArgs
    measureProgress?: boolean | LearnerCountOutputTypeCountMeasureProgressArgs
    leaderboards?: boolean | LearnerCountOutputTypeCountLeaderboardsArgs
  }

  // Custom InputTypes
  /**
   * LearnerCountOutputType without action
   */
  export type LearnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnerCountOutputType
     */
    select?: LearnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearnerCountOutputType without action
   */
  export type LearnerCountOutputTypeCountCreatedLearnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearnerWhereInput
  }

  /**
   * LearnerCountOutputType without action
   */
  export type LearnerCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * LearnerCountOutputType without action
   */
  export type LearnerCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * LearnerCountOutputType without action
   */
  export type LearnerCountOutputTypeCountResourceViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceViewWhereInput
  }

  /**
   * LearnerCountOutputType without action
   */
  export type LearnerCountOutputTypeCountMeasureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasureProgressWhereInput
  }

  /**
   * LearnerCountOutputType without action
   */
  export type LearnerCountOutputTypeCountLeaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
  }


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    enrollments: number
    quizAssignments: number
    measureProgress: number
    leaderboards: number
    programModules: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | ProgramCountOutputTypeCountEnrollmentsArgs
    quizAssignments?: boolean | ProgramCountOutputTypeCountQuizAssignmentsArgs
    measureProgress?: boolean | ProgramCountOutputTypeCountMeasureProgressArgs
    leaderboards?: boolean | ProgramCountOutputTypeCountLeaderboardsArgs
    programModules?: boolean | ProgramCountOutputTypeCountProgramModulesArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountQuizAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAssignmentWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountMeasureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasureProgressWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountLeaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountProgramModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramModuleWhereInput
  }


  /**
   * Count Type ModuleCountOutputType
   */

  export type ModuleCountOutputType = {
    dependentModules: number
    measureProgress: number
    programModules: number
    moduleTopics: number
  }

  export type ModuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependentModules?: boolean | ModuleCountOutputTypeCountDependentModulesArgs
    measureProgress?: boolean | ModuleCountOutputTypeCountMeasureProgressArgs
    programModules?: boolean | ModuleCountOutputTypeCountProgramModulesArgs
    moduleTopics?: boolean | ModuleCountOutputTypeCountModuleTopicsArgs
  }

  // Custom InputTypes
  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleCountOutputType
     */
    select?: ModuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountDependentModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountMeasureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasureProgressWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountProgramModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramModuleWhereInput
  }

  /**
   * ModuleCountOutputType without action
   */
  export type ModuleCountOutputTypeCountModuleTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleTopicWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    dependentTopics: number
    measureProgress: number
    moduleTopics: number
    topicResources: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dependentTopics?: boolean | TopicCountOutputTypeCountDependentTopicsArgs
    measureProgress?: boolean | TopicCountOutputTypeCountMeasureProgressArgs
    moduleTopics?: boolean | TopicCountOutputTypeCountModuleTopicsArgs
    topicResources?: boolean | TopicCountOutputTypeCountTopicResourcesArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountDependentTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountMeasureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasureProgressWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountModuleTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleTopicWhereInput
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountTopicResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicResourceWhereInput
  }


  /**
   * Count Type ResourceCountOutputType
   */

  export type ResourceCountOutputType = {
    resourceViews: number
    measureProgress: number
    topicResources: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resourceViews?: boolean | ResourceCountOutputTypeCountResourceViewsArgs
    measureProgress?: boolean | ResourceCountOutputTypeCountMeasureProgressArgs
    topicResources?: boolean | ResourceCountOutputTypeCountTopicResourcesArgs
  }

  // Custom InputTypes
  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountResourceViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceViewWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountMeasureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasureProgressWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountTopicResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicResourceWhereInput
  }


  /**
   * Count Type QuestionPoolCountOutputType
   */

  export type QuestionPoolCountOutputType = {
    quizPaperQuestions: number
    questionAttempts: number
  }

  export type QuestionPoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizPaperQuestions?: boolean | QuestionPoolCountOutputTypeCountQuizPaperQuestionsArgs
    questionAttempts?: boolean | QuestionPoolCountOutputTypeCountQuestionAttemptsArgs
  }

  // Custom InputTypes
  /**
   * QuestionPoolCountOutputType without action
   */
  export type QuestionPoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPoolCountOutputType
     */
    select?: QuestionPoolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionPoolCountOutputType without action
   */
  export type QuestionPoolCountOutputTypeCountQuizPaperQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizPaperQuestionWhereInput
  }

  /**
   * QuestionPoolCountOutputType without action
   */
  export type QuestionPoolCountOutputTypeCountQuestionAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAttemptWhereInput
  }


  /**
   * Count Type QuizPaperCountOutputType
   */

  export type QuizPaperCountOutputType = {
    questions: number
    assignments: number
  }

  export type QuizPaperCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizPaperCountOutputTypeCountQuestionsArgs
    assignments?: boolean | QuizPaperCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * QuizPaperCountOutputType without action
   */
  export type QuizPaperCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperCountOutputType
     */
    select?: QuizPaperCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizPaperCountOutputType without action
   */
  export type QuizPaperCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizPaperQuestionWhereInput
  }

  /**
   * QuizPaperCountOutputType without action
   */
  export type QuizPaperCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAssignmentWhereInput
  }


  /**
   * Count Type QuizAssignmentCountOutputType
   */

  export type QuizAssignmentCountOutputType = {
    quizAttempts: number
  }

  export type QuizAssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizAttempts?: boolean | QuizAssignmentCountOutputTypeCountQuizAttemptsArgs
  }

  // Custom InputTypes
  /**
   * QuizAssignmentCountOutputType without action
   */
  export type QuizAssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignmentCountOutputType
     */
    select?: QuizAssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizAssignmentCountOutputType without action
   */
  export type QuizAssignmentCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }


  /**
   * Count Type QuizAttemptCountOutputType
   */

  export type QuizAttemptCountOutputType = {
    questionAttempts: number
  }

  export type QuizAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionAttempts?: boolean | QuizAttemptCountOutputTypeCountQuestionAttemptsArgs
  }

  // Custom InputTypes
  /**
   * QuizAttemptCountOutputType without action
   */
  export type QuizAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttemptCountOutputType
     */
    select?: QuizAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizAttemptCountOutputType without action
   */
  export type QuizAttemptCountOutputTypeCountQuestionAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAttemptWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type AdminSumAggregateOutputType = {
    id: number | null
    createdBy: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    adminType: $Enums.AdminType | null
    organization: string | null
    bio: string | null
    profile_image: string | null
    contactPhone: string | null
    website: string | null
    isVerified: boolean | null
    isActive: boolean | null
    lastLogin: Date | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
    adminType: $Enums.AdminType | null
    organization: string | null
    bio: string | null
    profile_image: string | null
    contactPhone: string | null
    website: string | null
    isVerified: boolean | null
    isActive: boolean | null
    lastLogin: Date | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    adminType: number
    organization: number
    bio: number
    profile_image: number
    contactPhone: number
    website: number
    isVerified: number
    isActive: number
    lastLogin: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type AdminSumAggregateInputType = {
    id?: true
    createdBy?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    adminType?: true
    organization?: true
    bio?: true
    profile_image?: true
    contactPhone?: true
    website?: true
    isVerified?: true
    isActive?: true
    lastLogin?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    adminType?: true
    organization?: true
    bio?: true
    profile_image?: true
    contactPhone?: true
    website?: true
    isVerified?: true
    isActive?: true
    lastLogin?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    adminType?: true
    organization?: true
    bio?: true
    profile_image?: true
    contactPhone?: true
    website?: true
    isVerified?: true
    isActive?: true
    lastLogin?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization: string | null
    bio: string | null
    profile_image: string | null
    contactPhone: string | null
    website: string | null
    isVerified: boolean
    isActive: boolean
    lastLogin: Date | null
    createdBy: number | null
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    adminType?: boolean
    organization?: boolean
    bio?: boolean
    profile_image?: boolean
    contactPhone?: boolean
    website?: boolean
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | Admin$creatorArgs<ExtArgs>
    createdAdmins?: boolean | Admin$createdAdminsArgs<ExtArgs>
    questions?: boolean | Admin$questionsArgs<ExtArgs>
    quizPapers?: boolean | Admin$quizPapersArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    adminType?: boolean
    organization?: boolean
    bio?: boolean
    profile_image?: boolean
    contactPhone?: boolean
    website?: boolean
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | Admin$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    adminType?: boolean
    organization?: boolean
    bio?: boolean
    profile_image?: boolean
    contactPhone?: boolean
    website?: boolean
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | Admin$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    adminType?: boolean
    organization?: boolean
    bio?: boolean
    profile_image?: boolean
    contactPhone?: boolean
    website?: boolean
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "email" | "password" | "adminType" | "organization" | "bio" | "profile_image" | "contactPhone" | "website" | "isVerified" | "isActive" | "lastLogin" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Admin$creatorArgs<ExtArgs>
    createdAdmins?: boolean | Admin$createdAdminsArgs<ExtArgs>
    questions?: boolean | Admin$questionsArgs<ExtArgs>
    quizPapers?: boolean | Admin$quizPapersArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Admin$creatorArgs<ExtArgs>
  }
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Admin$creatorArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      creator: Prisma.$AdminPayload<ExtArgs> | null
      createdAdmins: Prisma.$AdminPayload<ExtArgs>[]
      questions: Prisma.$QuestionPoolPayload<ExtArgs>[]
      quizPapers: Prisma.$QuizPaperPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password: string
      adminType: $Enums.AdminType
      organization: string | null
      bio: string | null
      profile_image: string | null
      contactPhone: string | null
      website: string | null
      isVerified: boolean
      isActive: boolean
      lastLogin: Date | null
      createdBy: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Admin$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Admin$creatorArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdAdmins<T extends Admin$createdAdminsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$createdAdminsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends Admin$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizPapers<T extends Admin$quizPapersArgs<ExtArgs> = {}>(args?: Subset<T, Admin$quizPapersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'Int'>
    readonly first_name: FieldRef<"Admin", 'String'>
    readonly last_name: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
    readonly adminType: FieldRef<"Admin", 'AdminType'>
    readonly organization: FieldRef<"Admin", 'String'>
    readonly bio: FieldRef<"Admin", 'String'>
    readonly profile_image: FieldRef<"Admin", 'String'>
    readonly contactPhone: FieldRef<"Admin", 'String'>
    readonly website: FieldRef<"Admin", 'String'>
    readonly isVerified: FieldRef<"Admin", 'Boolean'>
    readonly isActive: FieldRef<"Admin", 'Boolean'>
    readonly lastLogin: FieldRef<"Admin", 'DateTime'>
    readonly createdBy: FieldRef<"Admin", 'Int'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.creator
   */
  export type Admin$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Admin.createdAdmins
   */
  export type Admin$createdAdminsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    cursor?: AdminWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin.questions
   */
  export type Admin$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    where?: QuestionPoolWhereInput
    orderBy?: QuestionPoolOrderByWithRelationInput | QuestionPoolOrderByWithRelationInput[]
    cursor?: QuestionPoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionPoolScalarFieldEnum | QuestionPoolScalarFieldEnum[]
  }

  /**
   * Admin.quizPapers
   */
  export type Admin$quizPapersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    where?: QuizPaperWhereInput
    orderBy?: QuizPaperOrderByWithRelationInput | QuizPaperOrderByWithRelationInput[]
    cursor?: QuizPaperWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizPaperScalarFieldEnum | QuizPaperScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Learner
   */

  export type AggregateLearner = {
    _count: LearnerCountAggregateOutputType | null
    _avg: LearnerAvgAggregateOutputType | null
    _sum: LearnerSumAggregateOutputType | null
    _min: LearnerMinAggregateOutputType | null
    _max: LearnerMaxAggregateOutputType | null
  }

  export type LearnerAvgAggregateOutputType = {
    id: number | null
    totalPoints: number | null
    createdBy: number | null
    status: number | null
  }

  export type LearnerSumAggregateOutputType = {
    id: number | null
    totalPoints: number | null
    createdBy: number | null
    status: number | null
  }

  export type LearnerMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    gender: string | null
    dob: Date | null
    email: string | null
    phone: Uint8Array | null
    communicationEmail: Uint8Array | null
    password: string | null
    profile_image: string | null
    organisation: string | null
    designation: string | null
    department: string | null
    location: string | null
    hierarchy_level: string | null
    totalPoints: number | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    isVerified: boolean | null
    lastLogin: Date | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    uniqueHash: string | null
    status: number | null
    extraConfig: string | null
    metaData: string | null
    role: string | null
  }

  export type LearnerMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    gender: string | null
    dob: Date | null
    email: string | null
    phone: Uint8Array | null
    communicationEmail: Uint8Array | null
    password: string | null
    profile_image: string | null
    organisation: string | null
    designation: string | null
    department: string | null
    location: string | null
    hierarchy_level: string | null
    totalPoints: number | null
    isActive: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    isVerified: boolean | null
    lastLogin: Date | null
    createdBy: number | null
    createdAt: Date | null
    updatedAt: Date | null
    uniqueHash: string | null
    status: number | null
    extraConfig: string | null
    metaData: string | null
    role: string | null
  }

  export type LearnerCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    gender: number
    dob: number
    email: number
    phone: number
    communicationEmail: number
    password: number
    profile_image: number
    organisation: number
    designation: number
    department: number
    location: number
    hierarchy_level: number
    totalPoints: number
    isActive: number
    isDeleted: number
    deletedAt: number
    isVerified: number
    lastLogin: number
    createdBy: number
    createdAt: number
    updatedAt: number
    uniqueHash: number
    status: number
    extraConfig: number
    metaData: number
    role: number
    _all: number
  }


  export type LearnerAvgAggregateInputType = {
    id?: true
    totalPoints?: true
    createdBy?: true
    status?: true
  }

  export type LearnerSumAggregateInputType = {
    id?: true
    totalPoints?: true
    createdBy?: true
    status?: true
  }

  export type LearnerMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    gender?: true
    dob?: true
    email?: true
    phone?: true
    communicationEmail?: true
    password?: true
    profile_image?: true
    organisation?: true
    designation?: true
    department?: true
    location?: true
    hierarchy_level?: true
    totalPoints?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    isVerified?: true
    lastLogin?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    uniqueHash?: true
    status?: true
    extraConfig?: true
    metaData?: true
    role?: true
  }

  export type LearnerMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    gender?: true
    dob?: true
    email?: true
    phone?: true
    communicationEmail?: true
    password?: true
    profile_image?: true
    organisation?: true
    designation?: true
    department?: true
    location?: true
    hierarchy_level?: true
    totalPoints?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    isVerified?: true
    lastLogin?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    uniqueHash?: true
    status?: true
    extraConfig?: true
    metaData?: true
    role?: true
  }

  export type LearnerCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    gender?: true
    dob?: true
    email?: true
    phone?: true
    communicationEmail?: true
    password?: true
    profile_image?: true
    organisation?: true
    designation?: true
    department?: true
    location?: true
    hierarchy_level?: true
    totalPoints?: true
    isActive?: true
    isDeleted?: true
    deletedAt?: true
    isVerified?: true
    lastLogin?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    uniqueHash?: true
    status?: true
    extraConfig?: true
    metaData?: true
    role?: true
    _all?: true
  }

  export type LearnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Learner to aggregate.
     */
    where?: LearnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Learners to fetch.
     */
    orderBy?: LearnerOrderByWithRelationInput | LearnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Learners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Learners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Learners
    **/
    _count?: true | LearnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearnerMaxAggregateInputType
  }

  export type GetLearnerAggregateType<T extends LearnerAggregateArgs> = {
        [P in keyof T & keyof AggregateLearner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearner[P]>
      : GetScalarType<T[P], AggregateLearner[P]>
  }




  export type LearnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearnerWhereInput
    orderBy?: LearnerOrderByWithAggregationInput | LearnerOrderByWithAggregationInput[]
    by: LearnerScalarFieldEnum[] | LearnerScalarFieldEnum
    having?: LearnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearnerCountAggregateInputType | true
    _avg?: LearnerAvgAggregateInputType
    _sum?: LearnerSumAggregateInputType
    _min?: LearnerMinAggregateInputType
    _max?: LearnerMaxAggregateInputType
  }

  export type LearnerGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    gender: string | null
    dob: Date | null
    email: string
    phone: Uint8Array | null
    communicationEmail: Uint8Array | null
    password: string | null
    profile_image: string | null
    organisation: string | null
    designation: string | null
    department: string | null
    location: string | null
    hierarchy_level: string | null
    totalPoints: number
    isActive: boolean
    isDeleted: boolean
    deletedAt: Date | null
    isVerified: boolean
    lastLogin: Date | null
    createdBy: number | null
    createdAt: Date
    updatedAt: Date
    uniqueHash: string | null
    status: number | null
    extraConfig: string | null
    metaData: string | null
    role: string
    _count: LearnerCountAggregateOutputType | null
    _avg: LearnerAvgAggregateOutputType | null
    _sum: LearnerSumAggregateOutputType | null
    _min: LearnerMinAggregateOutputType | null
    _max: LearnerMaxAggregateOutputType | null
  }

  type GetLearnerGroupByPayload<T extends LearnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearnerGroupByOutputType[P]>
            : GetScalarType<T[P], LearnerGroupByOutputType[P]>
        }
      >
    >


  export type LearnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    gender?: boolean
    dob?: boolean
    email?: boolean
    phone?: boolean
    communicationEmail?: boolean
    password?: boolean
    profile_image?: boolean
    organisation?: boolean
    designation?: boolean
    department?: boolean
    location?: boolean
    hierarchy_level?: boolean
    totalPoints?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    isVerified?: boolean
    lastLogin?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueHash?: boolean
    status?: boolean
    extraConfig?: boolean
    metaData?: boolean
    role?: boolean
    creator?: boolean | Learner$creatorArgs<ExtArgs>
    createdLearners?: boolean | Learner$createdLearnersArgs<ExtArgs>
    enrollments?: boolean | Learner$enrollmentsArgs<ExtArgs>
    quizAttempts?: boolean | Learner$quizAttemptsArgs<ExtArgs>
    resourceViews?: boolean | Learner$resourceViewsArgs<ExtArgs>
    measureProgress?: boolean | Learner$measureProgressArgs<ExtArgs>
    leaderboards?: boolean | Learner$leaderboardsArgs<ExtArgs>
    _count?: boolean | LearnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learner"]>

  export type LearnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    gender?: boolean
    dob?: boolean
    email?: boolean
    phone?: boolean
    communicationEmail?: boolean
    password?: boolean
    profile_image?: boolean
    organisation?: boolean
    designation?: boolean
    department?: boolean
    location?: boolean
    hierarchy_level?: boolean
    totalPoints?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    isVerified?: boolean
    lastLogin?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueHash?: boolean
    status?: boolean
    extraConfig?: boolean
    metaData?: boolean
    role?: boolean
    creator?: boolean | Learner$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["learner"]>

  export type LearnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    gender?: boolean
    dob?: boolean
    email?: boolean
    phone?: boolean
    communicationEmail?: boolean
    password?: boolean
    profile_image?: boolean
    organisation?: boolean
    designation?: boolean
    department?: boolean
    location?: boolean
    hierarchy_level?: boolean
    totalPoints?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    isVerified?: boolean
    lastLogin?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueHash?: boolean
    status?: boolean
    extraConfig?: boolean
    metaData?: boolean
    role?: boolean
    creator?: boolean | Learner$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["learner"]>

  export type LearnerSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    gender?: boolean
    dob?: boolean
    email?: boolean
    phone?: boolean
    communicationEmail?: boolean
    password?: boolean
    profile_image?: boolean
    organisation?: boolean
    designation?: boolean
    department?: boolean
    location?: boolean
    hierarchy_level?: boolean
    totalPoints?: boolean
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    isVerified?: boolean
    lastLogin?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    uniqueHash?: boolean
    status?: boolean
    extraConfig?: boolean
    metaData?: boolean
    role?: boolean
  }

  export type LearnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "first_name" | "last_name" | "gender" | "dob" | "email" | "phone" | "communicationEmail" | "password" | "profile_image" | "organisation" | "designation" | "department" | "location" | "hierarchy_level" | "totalPoints" | "isActive" | "isDeleted" | "deletedAt" | "isVerified" | "lastLogin" | "createdBy" | "createdAt" | "updatedAt" | "uniqueHash" | "status" | "extraConfig" | "metaData" | "role", ExtArgs["result"]["learner"]>
  export type LearnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Learner$creatorArgs<ExtArgs>
    createdLearners?: boolean | Learner$createdLearnersArgs<ExtArgs>
    enrollments?: boolean | Learner$enrollmentsArgs<ExtArgs>
    quizAttempts?: boolean | Learner$quizAttemptsArgs<ExtArgs>
    resourceViews?: boolean | Learner$resourceViewsArgs<ExtArgs>
    measureProgress?: boolean | Learner$measureProgressArgs<ExtArgs>
    leaderboards?: boolean | Learner$leaderboardsArgs<ExtArgs>
    _count?: boolean | LearnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Learner$creatorArgs<ExtArgs>
  }
  export type LearnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Learner$creatorArgs<ExtArgs>
  }

  export type $LearnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Learner"
    objects: {
      creator: Prisma.$LearnerPayload<ExtArgs> | null
      createdLearners: Prisma.$LearnerPayload<ExtArgs>[]
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      quizAttempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      resourceViews: Prisma.$ResourceViewPayload<ExtArgs>[]
      measureProgress: Prisma.$MeasureProgressPayload<ExtArgs>[]
      leaderboards: Prisma.$LeaderboardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      gender: string | null
      dob: Date | null
      email: string
      phone: Uint8Array | null
      communicationEmail: Uint8Array | null
      password: string | null
      profile_image: string | null
      organisation: string | null
      designation: string | null
      department: string | null
      location: string | null
      hierarchy_level: string | null
      totalPoints: number
      isActive: boolean
      isDeleted: boolean
      deletedAt: Date | null
      isVerified: boolean
      lastLogin: Date | null
      createdBy: number | null
      createdAt: Date
      updatedAt: Date
      uniqueHash: string | null
      status: number | null
      extraConfig: string | null
      metaData: string | null
      role: string
    }, ExtArgs["result"]["learner"]>
    composites: {}
  }

  type LearnerGetPayload<S extends boolean | null | undefined | LearnerDefaultArgs> = $Result.GetResult<Prisma.$LearnerPayload, S>

  type LearnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LearnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LearnerCountAggregateInputType | true
    }

  export interface LearnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Learner'], meta: { name: 'Learner' } }
    /**
     * Find zero or one Learner that matches the filter.
     * @param {LearnerFindUniqueArgs} args - Arguments to find a Learner
     * @example
     * // Get one Learner
     * const learner = await prisma.learner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearnerFindUniqueArgs>(args: SelectSubset<T, LearnerFindUniqueArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Learner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LearnerFindUniqueOrThrowArgs} args - Arguments to find a Learner
     * @example
     * // Get one Learner
     * const learner = await prisma.learner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearnerFindUniqueOrThrowArgs>(args: SelectSubset<T, LearnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Learner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerFindFirstArgs} args - Arguments to find a Learner
     * @example
     * // Get one Learner
     * const learner = await prisma.learner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearnerFindFirstArgs>(args?: SelectSubset<T, LearnerFindFirstArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Learner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerFindFirstOrThrowArgs} args - Arguments to find a Learner
     * @example
     * // Get one Learner
     * const learner = await prisma.learner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearnerFindFirstOrThrowArgs>(args?: SelectSubset<T, LearnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Learners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Learners
     * const learners = await prisma.learner.findMany()
     * 
     * // Get first 10 Learners
     * const learners = await prisma.learner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learnerWithIdOnly = await prisma.learner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearnerFindManyArgs>(args?: SelectSubset<T, LearnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Learner.
     * @param {LearnerCreateArgs} args - Arguments to create a Learner.
     * @example
     * // Create one Learner
     * const Learner = await prisma.learner.create({
     *   data: {
     *     // ... data to create a Learner
     *   }
     * })
     * 
     */
    create<T extends LearnerCreateArgs>(args: SelectSubset<T, LearnerCreateArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Learners.
     * @param {LearnerCreateManyArgs} args - Arguments to create many Learners.
     * @example
     * // Create many Learners
     * const learner = await prisma.learner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearnerCreateManyArgs>(args?: SelectSubset<T, LearnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Learners and returns the data saved in the database.
     * @param {LearnerCreateManyAndReturnArgs} args - Arguments to create many Learners.
     * @example
     * // Create many Learners
     * const learner = await prisma.learner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Learners and only return the `id`
     * const learnerWithIdOnly = await prisma.learner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearnerCreateManyAndReturnArgs>(args?: SelectSubset<T, LearnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Learner.
     * @param {LearnerDeleteArgs} args - Arguments to delete one Learner.
     * @example
     * // Delete one Learner
     * const Learner = await prisma.learner.delete({
     *   where: {
     *     // ... filter to delete one Learner
     *   }
     * })
     * 
     */
    delete<T extends LearnerDeleteArgs>(args: SelectSubset<T, LearnerDeleteArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Learner.
     * @param {LearnerUpdateArgs} args - Arguments to update one Learner.
     * @example
     * // Update one Learner
     * const learner = await prisma.learner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearnerUpdateArgs>(args: SelectSubset<T, LearnerUpdateArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Learners.
     * @param {LearnerDeleteManyArgs} args - Arguments to filter Learners to delete.
     * @example
     * // Delete a few Learners
     * const { count } = await prisma.learner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearnerDeleteManyArgs>(args?: SelectSubset<T, LearnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Learners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Learners
     * const learner = await prisma.learner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearnerUpdateManyArgs>(args: SelectSubset<T, LearnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Learners and returns the data updated in the database.
     * @param {LearnerUpdateManyAndReturnArgs} args - Arguments to update many Learners.
     * @example
     * // Update many Learners
     * const learner = await prisma.learner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Learners and only return the `id`
     * const learnerWithIdOnly = await prisma.learner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LearnerUpdateManyAndReturnArgs>(args: SelectSubset<T, LearnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Learner.
     * @param {LearnerUpsertArgs} args - Arguments to update or create a Learner.
     * @example
     * // Update or create a Learner
     * const learner = await prisma.learner.upsert({
     *   create: {
     *     // ... data to create a Learner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Learner we want to update
     *   }
     * })
     */
    upsert<T extends LearnerUpsertArgs>(args: SelectSubset<T, LearnerUpsertArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Learners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerCountArgs} args - Arguments to filter Learners to count.
     * @example
     * // Count the number of Learners
     * const count = await prisma.learner.count({
     *   where: {
     *     // ... the filter for the Learners we want to count
     *   }
     * })
    **/
    count<T extends LearnerCountArgs>(
      args?: Subset<T, LearnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Learner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearnerAggregateArgs>(args: Subset<T, LearnerAggregateArgs>): Prisma.PrismaPromise<GetLearnerAggregateType<T>>

    /**
     * Group by Learner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearnerGroupByArgs['orderBy'] }
        : { orderBy?: LearnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Learner model
   */
  readonly fields: LearnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Learner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Learner$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Learner$creatorArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdLearners<T extends Learner$createdLearnersArgs<ExtArgs> = {}>(args?: Subset<T, Learner$createdLearnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends Learner$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Learner$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizAttempts<T extends Learner$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Learner$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resourceViews<T extends Learner$resourceViewsArgs<ExtArgs> = {}>(args?: Subset<T, Learner$resourceViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    measureProgress<T extends Learner$measureProgressArgs<ExtArgs> = {}>(args?: Subset<T, Learner$measureProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboards<T extends Learner$leaderboardsArgs<ExtArgs> = {}>(args?: Subset<T, Learner$leaderboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Learner model
   */
  interface LearnerFieldRefs {
    readonly id: FieldRef<"Learner", 'Int'>
    readonly first_name: FieldRef<"Learner", 'String'>
    readonly last_name: FieldRef<"Learner", 'String'>
    readonly gender: FieldRef<"Learner", 'String'>
    readonly dob: FieldRef<"Learner", 'DateTime'>
    readonly email: FieldRef<"Learner", 'String'>
    readonly phone: FieldRef<"Learner", 'Bytes'>
    readonly communicationEmail: FieldRef<"Learner", 'Bytes'>
    readonly password: FieldRef<"Learner", 'String'>
    readonly profile_image: FieldRef<"Learner", 'String'>
    readonly organisation: FieldRef<"Learner", 'String'>
    readonly designation: FieldRef<"Learner", 'String'>
    readonly department: FieldRef<"Learner", 'String'>
    readonly location: FieldRef<"Learner", 'String'>
    readonly hierarchy_level: FieldRef<"Learner", 'String'>
    readonly totalPoints: FieldRef<"Learner", 'Int'>
    readonly isActive: FieldRef<"Learner", 'Boolean'>
    readonly isDeleted: FieldRef<"Learner", 'Boolean'>
    readonly deletedAt: FieldRef<"Learner", 'DateTime'>
    readonly isVerified: FieldRef<"Learner", 'Boolean'>
    readonly lastLogin: FieldRef<"Learner", 'DateTime'>
    readonly createdBy: FieldRef<"Learner", 'Int'>
    readonly createdAt: FieldRef<"Learner", 'DateTime'>
    readonly updatedAt: FieldRef<"Learner", 'DateTime'>
    readonly uniqueHash: FieldRef<"Learner", 'String'>
    readonly status: FieldRef<"Learner", 'Int'>
    readonly extraConfig: FieldRef<"Learner", 'String'>
    readonly metaData: FieldRef<"Learner", 'String'>
    readonly role: FieldRef<"Learner", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Learner findUnique
   */
  export type LearnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    /**
     * Filter, which Learner to fetch.
     */
    where: LearnerWhereUniqueInput
  }

  /**
   * Learner findUniqueOrThrow
   */
  export type LearnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    /**
     * Filter, which Learner to fetch.
     */
    where: LearnerWhereUniqueInput
  }

  /**
   * Learner findFirst
   */
  export type LearnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    /**
     * Filter, which Learner to fetch.
     */
    where?: LearnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Learners to fetch.
     */
    orderBy?: LearnerOrderByWithRelationInput | LearnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Learners.
     */
    cursor?: LearnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Learners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Learners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Learners.
     */
    distinct?: LearnerScalarFieldEnum | LearnerScalarFieldEnum[]
  }

  /**
   * Learner findFirstOrThrow
   */
  export type LearnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    /**
     * Filter, which Learner to fetch.
     */
    where?: LearnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Learners to fetch.
     */
    orderBy?: LearnerOrderByWithRelationInput | LearnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Learners.
     */
    cursor?: LearnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Learners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Learners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Learners.
     */
    distinct?: LearnerScalarFieldEnum | LearnerScalarFieldEnum[]
  }

  /**
   * Learner findMany
   */
  export type LearnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    /**
     * Filter, which Learners to fetch.
     */
    where?: LearnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Learners to fetch.
     */
    orderBy?: LearnerOrderByWithRelationInput | LearnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Learners.
     */
    cursor?: LearnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Learners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Learners.
     */
    skip?: number
    distinct?: LearnerScalarFieldEnum | LearnerScalarFieldEnum[]
  }

  /**
   * Learner create
   */
  export type LearnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Learner.
     */
    data: XOR<LearnerCreateInput, LearnerUncheckedCreateInput>
  }

  /**
   * Learner createMany
   */
  export type LearnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Learners.
     */
    data: LearnerCreateManyInput | LearnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Learner createManyAndReturn
   */
  export type LearnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * The data used to create many Learners.
     */
    data: LearnerCreateManyInput | LearnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Learner update
   */
  export type LearnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Learner.
     */
    data: XOR<LearnerUpdateInput, LearnerUncheckedUpdateInput>
    /**
     * Choose, which Learner to update.
     */
    where: LearnerWhereUniqueInput
  }

  /**
   * Learner updateMany
   */
  export type LearnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Learners.
     */
    data: XOR<LearnerUpdateManyMutationInput, LearnerUncheckedUpdateManyInput>
    /**
     * Filter which Learners to update
     */
    where?: LearnerWhereInput
    /**
     * Limit how many Learners to update.
     */
    limit?: number
  }

  /**
   * Learner updateManyAndReturn
   */
  export type LearnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * The data used to update Learners.
     */
    data: XOR<LearnerUpdateManyMutationInput, LearnerUncheckedUpdateManyInput>
    /**
     * Filter which Learners to update
     */
    where?: LearnerWhereInput
    /**
     * Limit how many Learners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Learner upsert
   */
  export type LearnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Learner to update in case it exists.
     */
    where: LearnerWhereUniqueInput
    /**
     * In case the Learner found by the `where` argument doesn't exist, create a new Learner with this data.
     */
    create: XOR<LearnerCreateInput, LearnerUncheckedCreateInput>
    /**
     * In case the Learner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearnerUpdateInput, LearnerUncheckedUpdateInput>
  }

  /**
   * Learner delete
   */
  export type LearnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    /**
     * Filter which Learner to delete.
     */
    where: LearnerWhereUniqueInput
  }

  /**
   * Learner deleteMany
   */
  export type LearnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Learners to delete
     */
    where?: LearnerWhereInput
    /**
     * Limit how many Learners to delete.
     */
    limit?: number
  }

  /**
   * Learner.creator
   */
  export type Learner$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    where?: LearnerWhereInput
  }

  /**
   * Learner.createdLearners
   */
  export type Learner$createdLearnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
    where?: LearnerWhereInput
    orderBy?: LearnerOrderByWithRelationInput | LearnerOrderByWithRelationInput[]
    cursor?: LearnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearnerScalarFieldEnum | LearnerScalarFieldEnum[]
  }

  /**
   * Learner.enrollments
   */
  export type Learner$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Learner.quizAttempts
   */
  export type Learner$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * Learner.resourceViews
   */
  export type Learner$resourceViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    where?: ResourceViewWhereInput
    orderBy?: ResourceViewOrderByWithRelationInput | ResourceViewOrderByWithRelationInput[]
    cursor?: ResourceViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceViewScalarFieldEnum | ResourceViewScalarFieldEnum[]
  }

  /**
   * Learner.measureProgress
   */
  export type Learner$measureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    where?: MeasureProgressWhereInput
    orderBy?: MeasureProgressOrderByWithRelationInput | MeasureProgressOrderByWithRelationInput[]
    cursor?: MeasureProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeasureProgressScalarFieldEnum | MeasureProgressScalarFieldEnum[]
  }

  /**
   * Learner.leaderboards
   */
  export type Learner$leaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    cursor?: LeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Learner without action
   */
  export type LearnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Learner
     */
    select?: LearnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Learner
     */
    omit?: LearnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnerInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    rating: number | null
    price: Decimal | null
    totalTimeLimit: number | null
    status: number | null
    passingScore: number | null
    clientId: number | null
    packageId: number | null
  }

  export type ProgramSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    rating: number | null
    price: Decimal | null
    totalTimeLimit: number | null
    status: number | null
    passingScore: number | null
    clientId: number | null
    packageId: bigint | null
  }

  export type ProgramMinAggregateOutputType = {
    id: number | null
    authorId: number | null
    title: string | null
    description: string | null
    category: string | null
    instructor: string | null
    instructorAvatar: string | null
    image: string | null
    rating: number | null
    level: string | null
    price: Decimal | null
    type: $Enums.ProgramType | null
    totalTimeLimit: number | null
    status: number | null
    uniqueHash: string | null
    startDate: Date | null
    endDate: Date | null
    surveyStartDate: Date | null
    surveyEndDate: Date | null
    maxParticipants: string | null
    passingScore: number | null
    clientId: number | null
    packageId: bigint | null
    isActive: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: number | null
    authorId: number | null
    title: string | null
    description: string | null
    category: string | null
    instructor: string | null
    instructorAvatar: string | null
    image: string | null
    rating: number | null
    level: string | null
    price: Decimal | null
    type: $Enums.ProgramType | null
    totalTimeLimit: number | null
    status: number | null
    uniqueHash: string | null
    startDate: Date | null
    endDate: Date | null
    surveyStartDate: Date | null
    surveyEndDate: Date | null
    maxParticipants: string | null
    passingScore: number | null
    clientId: number | null
    packageId: bigint | null
    isActive: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    authorId: number
    title: number
    description: number
    category: number
    instructor: number
    instructorAvatar: number
    image: number
    rating: number
    level: number
    price: number
    type: number
    totalTimeLimit: number
    status: number
    uniqueHash: number
    startDate: number
    endDate: number
    surveyStartDate: number
    surveyEndDate: number
    maxParticipants: number
    passingScore: number
    studySettings: number
    clientId: number
    packageId: number
    isActive: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    id?: true
    authorId?: true
    rating?: true
    price?: true
    totalTimeLimit?: true
    status?: true
    passingScore?: true
    clientId?: true
    packageId?: true
  }

  export type ProgramSumAggregateInputType = {
    id?: true
    authorId?: true
    rating?: true
    price?: true
    totalTimeLimit?: true
    status?: true
    passingScore?: true
    clientId?: true
    packageId?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    description?: true
    category?: true
    instructor?: true
    instructorAvatar?: true
    image?: true
    rating?: true
    level?: true
    price?: true
    type?: true
    totalTimeLimit?: true
    status?: true
    uniqueHash?: true
    startDate?: true
    endDate?: true
    surveyStartDate?: true
    surveyEndDate?: true
    maxParticipants?: true
    passingScore?: true
    clientId?: true
    packageId?: true
    isActive?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    description?: true
    category?: true
    instructor?: true
    instructorAvatar?: true
    image?: true
    rating?: true
    level?: true
    price?: true
    type?: true
    totalTimeLimit?: true
    status?: true
    uniqueHash?: true
    startDate?: true
    endDate?: true
    surveyStartDate?: true
    surveyEndDate?: true
    maxParticipants?: true
    passingScore?: true
    clientId?: true
    packageId?: true
    isActive?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    description?: true
    category?: true
    instructor?: true
    instructorAvatar?: true
    image?: true
    rating?: true
    level?: true
    price?: true
    type?: true
    totalTimeLimit?: true
    status?: true
    uniqueHash?: true
    startDate?: true
    endDate?: true
    surveyStartDate?: true
    surveyEndDate?: true
    maxParticipants?: true
    passingScore?: true
    studySettings?: true
    clientId?: true
    packageId?: true
    isActive?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: number
    authorId: number
    title: string
    description: string
    category: string | null
    instructor: string | null
    instructorAvatar: string | null
    image: string | null
    rating: number | null
    level: string | null
    price: Decimal | null
    type: $Enums.ProgramType | null
    totalTimeLimit: number | null
    status: number | null
    uniqueHash: string | null
    startDate: Date | null
    endDate: Date | null
    surveyStartDate: Date | null
    surveyEndDate: Date | null
    maxParticipants: string | null
    passingScore: number | null
    studySettings: JsonValue | null
    clientId: number | null
    packageId: bigint | null
    isActive: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    instructor?: boolean
    instructorAvatar?: boolean
    image?: boolean
    rating?: boolean
    level?: boolean
    price?: boolean
    type?: boolean
    totalTimeLimit?: boolean
    status?: boolean
    uniqueHash?: boolean
    startDate?: boolean
    endDate?: boolean
    surveyStartDate?: boolean
    surveyEndDate?: boolean
    maxParticipants?: boolean
    passingScore?: boolean
    studySettings?: boolean
    clientId?: boolean
    packageId?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    enrollments?: boolean | Program$enrollmentsArgs<ExtArgs>
    quizAssignments?: boolean | Program$quizAssignmentsArgs<ExtArgs>
    measureProgress?: boolean | Program$measureProgressArgs<ExtArgs>
    leaderboards?: boolean | Program$leaderboardsArgs<ExtArgs>
    programModules?: boolean | Program$programModulesArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    instructor?: boolean
    instructorAvatar?: boolean
    image?: boolean
    rating?: boolean
    level?: boolean
    price?: boolean
    type?: boolean
    totalTimeLimit?: boolean
    status?: boolean
    uniqueHash?: boolean
    startDate?: boolean
    endDate?: boolean
    surveyStartDate?: boolean
    surveyEndDate?: boolean
    maxParticipants?: boolean
    passingScore?: boolean
    studySettings?: boolean
    clientId?: boolean
    packageId?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    instructor?: boolean
    instructorAvatar?: boolean
    image?: boolean
    rating?: boolean
    level?: boolean
    price?: boolean
    type?: boolean
    totalTimeLimit?: boolean
    status?: boolean
    uniqueHash?: boolean
    startDate?: boolean
    endDate?: boolean
    surveyStartDate?: boolean
    surveyEndDate?: boolean
    maxParticipants?: boolean
    passingScore?: boolean
    studySettings?: boolean
    clientId?: boolean
    packageId?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    authorId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    instructor?: boolean
    instructorAvatar?: boolean
    image?: boolean
    rating?: boolean
    level?: boolean
    price?: boolean
    type?: boolean
    totalTimeLimit?: boolean
    status?: boolean
    uniqueHash?: boolean
    startDate?: boolean
    endDate?: boolean
    surveyStartDate?: boolean
    surveyEndDate?: boolean
    maxParticipants?: boolean
    passingScore?: boolean
    studySettings?: boolean
    clientId?: boolean
    packageId?: boolean
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProgramOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authorId" | "title" | "description" | "category" | "instructor" | "instructorAvatar" | "image" | "rating" | "level" | "price" | "type" | "totalTimeLimit" | "status" | "uniqueHash" | "startDate" | "endDate" | "surveyStartDate" | "surveyEndDate" | "maxParticipants" | "passingScore" | "studySettings" | "clientId" | "packageId" | "isActive" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["program"]>
  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | Program$enrollmentsArgs<ExtArgs>
    quizAssignments?: boolean | Program$quizAssignmentsArgs<ExtArgs>
    measureProgress?: boolean | Program$measureProgressArgs<ExtArgs>
    leaderboards?: boolean | Program$leaderboardsArgs<ExtArgs>
    programModules?: boolean | Program$programModulesArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProgramIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      enrollments: Prisma.$EnrollmentPayload<ExtArgs>[]
      quizAssignments: Prisma.$QuizAssignmentPayload<ExtArgs>[]
      measureProgress: Prisma.$MeasureProgressPayload<ExtArgs>[]
      leaderboards: Prisma.$LeaderboardPayload<ExtArgs>[]
      programModules: Prisma.$ProgramModulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      authorId: number
      title: string
      description: string
      category: string | null
      instructor: string | null
      instructorAvatar: string | null
      image: string | null
      rating: number | null
      level: string | null
      price: Prisma.Decimal | null
      type: $Enums.ProgramType | null
      totalTimeLimit: number | null
      status: number | null
      uniqueHash: string | null
      startDate: Date | null
      endDate: Date | null
      surveyStartDate: Date | null
      surveyEndDate: Date | null
      maxParticipants: string | null
      passingScore: number | null
      studySettings: Prisma.JsonValue | null
      clientId: number | null
      packageId: bigint | null
      isActive: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs and returns the data updated in the database.
     * @param {ProgramUpdateManyAndReturnArgs} args - Arguments to update many Programs.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollments<T extends Program$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Program$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizAssignments<T extends Program$quizAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Program$quizAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    measureProgress<T extends Program$measureProgressArgs<ExtArgs> = {}>(args?: Subset<T, Program$measureProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaderboards<T extends Program$leaderboardsArgs<ExtArgs> = {}>(args?: Subset<T, Program$leaderboardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    programModules<T extends Program$programModulesArgs<ExtArgs> = {}>(args?: Subset<T, Program$programModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'Int'>
    readonly authorId: FieldRef<"Program", 'Int'>
    readonly title: FieldRef<"Program", 'String'>
    readonly description: FieldRef<"Program", 'String'>
    readonly category: FieldRef<"Program", 'String'>
    readonly instructor: FieldRef<"Program", 'String'>
    readonly instructorAvatar: FieldRef<"Program", 'String'>
    readonly image: FieldRef<"Program", 'String'>
    readonly rating: FieldRef<"Program", 'Float'>
    readonly level: FieldRef<"Program", 'String'>
    readonly price: FieldRef<"Program", 'Decimal'>
    readonly type: FieldRef<"Program", 'ProgramType'>
    readonly totalTimeLimit: FieldRef<"Program", 'Int'>
    readonly status: FieldRef<"Program", 'Int'>
    readonly uniqueHash: FieldRef<"Program", 'String'>
    readonly startDate: FieldRef<"Program", 'DateTime'>
    readonly endDate: FieldRef<"Program", 'DateTime'>
    readonly surveyStartDate: FieldRef<"Program", 'DateTime'>
    readonly surveyEndDate: FieldRef<"Program", 'DateTime'>
    readonly maxParticipants: FieldRef<"Program", 'String'>
    readonly passingScore: FieldRef<"Program", 'Int'>
    readonly studySettings: FieldRef<"Program", 'Json'>
    readonly clientId: FieldRef<"Program", 'Int'>
    readonly packageId: FieldRef<"Program", 'BigInt'>
    readonly isActive: FieldRef<"Program", 'Boolean'>
    readonly isDeleted: FieldRef<"Program", 'Boolean'>
    readonly createdAt: FieldRef<"Program", 'DateTime'>
    readonly updatedAt: FieldRef<"Program", 'DateTime'>
    readonly deletedAt: FieldRef<"Program", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program updateManyAndReturn
   */
  export type ProgramUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to update.
     */
    limit?: number
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
    /**
     * Limit how many Programs to delete.
     */
    limit?: number
  }

  /**
   * Program.enrollments
   */
  export type Program$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    cursor?: EnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Program.quizAssignments
   */
  export type Program$quizAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    where?: QuizAssignmentWhereInput
    orderBy?: QuizAssignmentOrderByWithRelationInput | QuizAssignmentOrderByWithRelationInput[]
    cursor?: QuizAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAssignmentScalarFieldEnum | QuizAssignmentScalarFieldEnum[]
  }

  /**
   * Program.measureProgress
   */
  export type Program$measureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    where?: MeasureProgressWhereInput
    orderBy?: MeasureProgressOrderByWithRelationInput | MeasureProgressOrderByWithRelationInput[]
    cursor?: MeasureProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeasureProgressScalarFieldEnum | MeasureProgressScalarFieldEnum[]
  }

  /**
   * Program.leaderboards
   */
  export type Program$leaderboardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    cursor?: LeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Program.programModules
   */
  export type Program$programModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    where?: ProgramModuleWhereInput
    orderBy?: ProgramModuleOrderByWithRelationInput | ProgramModuleOrderByWithRelationInput[]
    cursor?: ProgramModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramModuleScalarFieldEnum | ProgramModuleScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model Module
   */

  export type AggregateModule = {
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  export type ModuleAvgAggregateOutputType = {
    id: number | null
    prerequisiteModuleId: number | null
    status: number | null
  }

  export type ModuleSumAggregateOutputType = {
    id: number | null
    prerequisiteModuleId: number | null
    status: number | null
  }

  export type ModuleMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    prerequisiteModuleId: number | null
    status: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    prerequisiteModuleId: number | null
    status: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModuleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    prerequisiteModuleId: number
    status: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModuleAvgAggregateInputType = {
    id?: true
    prerequisiteModuleId?: true
    status?: true
  }

  export type ModuleSumAggregateInputType = {
    id?: true
    prerequisiteModuleId?: true
    status?: true
  }

  export type ModuleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    prerequisiteModuleId?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    prerequisiteModuleId?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModuleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    prerequisiteModuleId?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Module to aggregate.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Modules
    **/
    _count?: true | ModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleMaxAggregateInputType
  }

  export type GetModuleAggregateType<T extends ModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModule[P]>
      : GetScalarType<T[P], AggregateModule[P]>
  }




  export type ModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithAggregationInput | ModuleOrderByWithAggregationInput[]
    by: ModuleScalarFieldEnum[] | ModuleScalarFieldEnum
    having?: ModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleCountAggregateInputType | true
    _avg?: ModuleAvgAggregateInputType
    _sum?: ModuleSumAggregateInputType
    _min?: ModuleMinAggregateInputType
    _max?: ModuleMaxAggregateInputType
  }

  export type ModuleGroupByOutputType = {
    id: number
    title: string
    description: string | null
    prerequisiteModuleId: number | null
    status: number | null
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ModuleCountAggregateOutputType | null
    _avg: ModuleAvgAggregateOutputType | null
    _sum: ModuleSumAggregateOutputType | null
    _min: ModuleMinAggregateOutputType | null
    _max: ModuleMaxAggregateOutputType | null
  }

  type GetModuleGroupByPayload<T extends ModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleGroupByOutputType[P]>
        }
      >
    >


  export type ModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    prerequisiteModuleId?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prerequisiteModule?: boolean | Module$prerequisiteModuleArgs<ExtArgs>
    dependentModules?: boolean | Module$dependentModulesArgs<ExtArgs>
    measureProgress?: boolean | Module$measureProgressArgs<ExtArgs>
    programModules?: boolean | Module$programModulesArgs<ExtArgs>
    moduleTopics?: boolean | Module$moduleTopicsArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    prerequisiteModuleId?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prerequisiteModule?: boolean | Module$prerequisiteModuleArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    prerequisiteModuleId?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prerequisiteModule?: boolean | Module$prerequisiteModuleArgs<ExtArgs>
  }, ExtArgs["result"]["module"]>

  export type ModuleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    prerequisiteModuleId?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "prerequisiteModuleId" | "status" | "isDeleted" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["module"]>
  export type ModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prerequisiteModule?: boolean | Module$prerequisiteModuleArgs<ExtArgs>
    dependentModules?: boolean | Module$dependentModulesArgs<ExtArgs>
    measureProgress?: boolean | Module$measureProgressArgs<ExtArgs>
    programModules?: boolean | Module$programModulesArgs<ExtArgs>
    moduleTopics?: boolean | Module$moduleTopicsArgs<ExtArgs>
    _count?: boolean | ModuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prerequisiteModule?: boolean | Module$prerequisiteModuleArgs<ExtArgs>
  }
  export type ModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prerequisiteModule?: boolean | Module$prerequisiteModuleArgs<ExtArgs>
  }

  export type $ModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Module"
    objects: {
      prerequisiteModule: Prisma.$ModulePayload<ExtArgs> | null
      dependentModules: Prisma.$ModulePayload<ExtArgs>[]
      measureProgress: Prisma.$MeasureProgressPayload<ExtArgs>[]
      programModules: Prisma.$ProgramModulePayload<ExtArgs>[]
      moduleTopics: Prisma.$ModuleTopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      prerequisiteModuleId: number | null
      status: number | null
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["module"]>
    composites: {}
  }

  type ModuleGetPayload<S extends boolean | null | undefined | ModuleDefaultArgs> = $Result.GetResult<Prisma.$ModulePayload, S>

  type ModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleCountAggregateInputType | true
    }

  export interface ModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Module'], meta: { name: 'Module' } }
    /**
     * Find zero or one Module that matches the filter.
     * @param {ModuleFindUniqueArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleFindUniqueArgs>(args: SelectSubset<T, ModuleFindUniqueArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Module that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleFindUniqueOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleFindFirstArgs>(args?: SelectSubset<T, ModuleFindFirstArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Module that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindFirstOrThrowArgs} args - Arguments to find a Module
     * @example
     * // Get one Module
     * const module = await prisma.module.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Modules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Modules
     * const modules = await prisma.module.findMany()
     * 
     * // Get first 10 Modules
     * const modules = await prisma.module.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const moduleWithIdOnly = await prisma.module.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModuleFindManyArgs>(args?: SelectSubset<T, ModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Module.
     * @param {ModuleCreateArgs} args - Arguments to create a Module.
     * @example
     * // Create one Module
     * const Module = await prisma.module.create({
     *   data: {
     *     // ... data to create a Module
     *   }
     * })
     * 
     */
    create<T extends ModuleCreateArgs>(args: SelectSubset<T, ModuleCreateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Modules.
     * @param {ModuleCreateManyArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleCreateManyArgs>(args?: SelectSubset<T, ModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Modules and returns the data saved in the database.
     * @param {ModuleCreateManyAndReturnArgs} args - Arguments to create many Modules.
     * @example
     * // Create many Modules
     * const module = await prisma.module.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Module.
     * @param {ModuleDeleteArgs} args - Arguments to delete one Module.
     * @example
     * // Delete one Module
     * const Module = await prisma.module.delete({
     *   where: {
     *     // ... filter to delete one Module
     *   }
     * })
     * 
     */
    delete<T extends ModuleDeleteArgs>(args: SelectSubset<T, ModuleDeleteArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Module.
     * @param {ModuleUpdateArgs} args - Arguments to update one Module.
     * @example
     * // Update one Module
     * const module = await prisma.module.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleUpdateArgs>(args: SelectSubset<T, ModuleUpdateArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Modules.
     * @param {ModuleDeleteManyArgs} args - Arguments to filter Modules to delete.
     * @example
     * // Delete a few Modules
     * const { count } = await prisma.module.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleDeleteManyArgs>(args?: SelectSubset<T, ModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleUpdateManyArgs>(args: SelectSubset<T, ModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Modules and returns the data updated in the database.
     * @param {ModuleUpdateManyAndReturnArgs} args - Arguments to update many Modules.
     * @example
     * // Update many Modules
     * const module = await prisma.module.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Modules and only return the `id`
     * const moduleWithIdOnly = await prisma.module.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Module.
     * @param {ModuleUpsertArgs} args - Arguments to update or create a Module.
     * @example
     * // Update or create a Module
     * const module = await prisma.module.upsert({
     *   create: {
     *     // ... data to create a Module
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Module we want to update
     *   }
     * })
     */
    upsert<T extends ModuleUpsertArgs>(args: SelectSubset<T, ModuleUpsertArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Modules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleCountArgs} args - Arguments to filter Modules to count.
     * @example
     * // Count the number of Modules
     * const count = await prisma.module.count({
     *   where: {
     *     // ... the filter for the Modules we want to count
     *   }
     * })
    **/
    count<T extends ModuleCountArgs>(
      args?: Subset<T, ModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleAggregateArgs>(args: Subset<T, ModuleAggregateArgs>): Prisma.PrismaPromise<GetModuleAggregateType<T>>

    /**
     * Group by Module.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleGroupByArgs['orderBy'] }
        : { orderBy?: ModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Module model
   */
  readonly fields: ModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Module.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prerequisiteModule<T extends Module$prerequisiteModuleArgs<ExtArgs> = {}>(args?: Subset<T, Module$prerequisiteModuleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dependentModules<T extends Module$dependentModulesArgs<ExtArgs> = {}>(args?: Subset<T, Module$dependentModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    measureProgress<T extends Module$measureProgressArgs<ExtArgs> = {}>(args?: Subset<T, Module$measureProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    programModules<T extends Module$programModulesArgs<ExtArgs> = {}>(args?: Subset<T, Module$programModulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moduleTopics<T extends Module$moduleTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Module$moduleTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Module model
   */
  interface ModuleFieldRefs {
    readonly id: FieldRef<"Module", 'Int'>
    readonly title: FieldRef<"Module", 'String'>
    readonly description: FieldRef<"Module", 'String'>
    readonly prerequisiteModuleId: FieldRef<"Module", 'Int'>
    readonly status: FieldRef<"Module", 'Int'>
    readonly isDeleted: FieldRef<"Module", 'Boolean'>
    readonly deletedAt: FieldRef<"Module", 'DateTime'>
    readonly createdAt: FieldRef<"Module", 'DateTime'>
    readonly updatedAt: FieldRef<"Module", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Module findUnique
   */
  export type ModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findUniqueOrThrow
   */
  export type ModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module findFirst
   */
  export type ModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findFirstOrThrow
   */
  export type ModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Module to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Modules.
     */
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module findMany
   */
  export type ModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter, which Modules to fetch.
     */
    where?: ModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Modules to fetch.
     */
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Modules.
     */
    cursor?: ModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Modules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Modules.
     */
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module create
   */
  export type ModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a Module.
     */
    data: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
  }

  /**
   * Module createMany
   */
  export type ModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Module createManyAndReturn
   */
  export type ModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to create many Modules.
     */
    data: ModuleCreateManyInput | ModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module update
   */
  export type ModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a Module.
     */
    data: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
    /**
     * Choose, which Module to update.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module updateMany
   */
  export type ModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
  }

  /**
   * Module updateManyAndReturn
   */
  export type ModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * The data used to update Modules.
     */
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyInput>
    /**
     * Filter which Modules to update
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Module upsert
   */
  export type ModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the Module to update in case it exists.
     */
    where: ModuleWhereUniqueInput
    /**
     * In case the Module found by the `where` argument doesn't exist, create a new Module with this data.
     */
    create: XOR<ModuleCreateInput, ModuleUncheckedCreateInput>
    /**
     * In case the Module was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleUpdateInput, ModuleUncheckedUpdateInput>
  }

  /**
   * Module delete
   */
  export type ModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    /**
     * Filter which Module to delete.
     */
    where: ModuleWhereUniqueInput
  }

  /**
   * Module deleteMany
   */
  export type ModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Modules to delete
     */
    where?: ModuleWhereInput
    /**
     * Limit how many Modules to delete.
     */
    limit?: number
  }

  /**
   * Module.prerequisiteModule
   */
  export type Module$prerequisiteModuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * Module.dependentModules
   */
  export type Module$dependentModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
    orderBy?: ModuleOrderByWithRelationInput | ModuleOrderByWithRelationInput[]
    cursor?: ModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleScalarFieldEnum | ModuleScalarFieldEnum[]
  }

  /**
   * Module.measureProgress
   */
  export type Module$measureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    where?: MeasureProgressWhereInput
    orderBy?: MeasureProgressOrderByWithRelationInput | MeasureProgressOrderByWithRelationInput[]
    cursor?: MeasureProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeasureProgressScalarFieldEnum | MeasureProgressScalarFieldEnum[]
  }

  /**
   * Module.programModules
   */
  export type Module$programModulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    where?: ProgramModuleWhereInput
    orderBy?: ProgramModuleOrderByWithRelationInput | ProgramModuleOrderByWithRelationInput[]
    cursor?: ProgramModuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramModuleScalarFieldEnum | ProgramModuleScalarFieldEnum[]
  }

  /**
   * Module.moduleTopics
   */
  export type Module$moduleTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    where?: ModuleTopicWhereInput
    orderBy?: ModuleTopicOrderByWithRelationInput | ModuleTopicOrderByWithRelationInput[]
    cursor?: ModuleTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleTopicScalarFieldEnum | ModuleTopicScalarFieldEnum[]
  }

  /**
   * Module without action
   */
  export type ModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
  }


  /**
   * Model Enrollment
   */

  export type AggregateEnrollment = {
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  export type EnrollmentAvgAggregateOutputType = {
    id: number | null
    learnerId: number | null
    programId: number | null
  }

  export type EnrollmentSumAggregateOutputType = {
    id: number | null
    learnerId: number | null
    programId: number | null
  }

  export type EnrollmentMinAggregateOutputType = {
    id: number | null
    learnerId: number | null
    programId: number | null
    enrolledAt: Date | null
  }

  export type EnrollmentMaxAggregateOutputType = {
    id: number | null
    learnerId: number | null
    programId: number | null
    enrolledAt: Date | null
  }

  export type EnrollmentCountAggregateOutputType = {
    id: number
    learnerId: number
    programId: number
    enrolledAt: number
    _all: number
  }


  export type EnrollmentAvgAggregateInputType = {
    id?: true
    learnerId?: true
    programId?: true
  }

  export type EnrollmentSumAggregateInputType = {
    id?: true
    learnerId?: true
    programId?: true
  }

  export type EnrollmentMinAggregateInputType = {
    id?: true
    learnerId?: true
    programId?: true
    enrolledAt?: true
  }

  export type EnrollmentMaxAggregateInputType = {
    id?: true
    learnerId?: true
    programId?: true
    enrolledAt?: true
  }

  export type EnrollmentCountAggregateInputType = {
    id?: true
    learnerId?: true
    programId?: true
    enrolledAt?: true
    _all?: true
  }

  export type EnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollment to aggregate.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enrollments
    **/
    _count?: true | EnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentMaxAggregateInputType
  }

  export type GetEnrollmentAggregateType<T extends EnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollment[P]>
      : GetScalarType<T[P], AggregateEnrollment[P]>
  }




  export type EnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnrollmentWhereInput
    orderBy?: EnrollmentOrderByWithAggregationInput | EnrollmentOrderByWithAggregationInput[]
    by: EnrollmentScalarFieldEnum[] | EnrollmentScalarFieldEnum
    having?: EnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentCountAggregateInputType | true
    _avg?: EnrollmentAvgAggregateInputType
    _sum?: EnrollmentSumAggregateInputType
    _min?: EnrollmentMinAggregateInputType
    _max?: EnrollmentMaxAggregateInputType
  }

  export type EnrollmentGroupByOutputType = {
    id: number
    learnerId: number
    programId: number
    enrolledAt: Date
    _count: EnrollmentCountAggregateOutputType | null
    _avg: EnrollmentAvgAggregateOutputType | null
    _sum: EnrollmentSumAggregateOutputType | null
    _min: EnrollmentMinAggregateOutputType | null
    _max: EnrollmentMaxAggregateOutputType | null
  }

  type GetEnrollmentGroupByPayload<T extends EnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type EnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    learnerId?: boolean
    programId?: boolean
    enrolledAt?: boolean
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    learnerId?: boolean
    programId?: boolean
    enrolledAt?: boolean
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    learnerId?: boolean
    programId?: boolean
    enrolledAt?: boolean
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["enrollment"]>

  export type EnrollmentSelectScalar = {
    id?: boolean
    learnerId?: boolean
    programId?: boolean
    enrolledAt?: boolean
  }

  export type EnrollmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "learnerId" | "programId" | "enrolledAt", ExtArgs["result"]["enrollment"]>
  export type EnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }
  export type EnrollmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
  }

  export type $EnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enrollment"
    objects: {
      learner: Prisma.$LearnerPayload<ExtArgs>
      program: Prisma.$ProgramPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      learnerId: number
      programId: number
      enrolledAt: Date
    }, ExtArgs["result"]["enrollment"]>
    composites: {}
  }

  type EnrollmentGetPayload<S extends boolean | null | undefined | EnrollmentDefaultArgs> = $Result.GetResult<Prisma.$EnrollmentPayload, S>

  type EnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EnrollmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentCountAggregateInputType | true
    }

  export interface EnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enrollment'], meta: { name: 'Enrollment' } }
    /**
     * Find zero or one Enrollment that matches the filter.
     * @param {EnrollmentFindUniqueArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EnrollmentFindUniqueArgs>(args: SelectSubset<T, EnrollmentFindUniqueArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EnrollmentFindUniqueOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EnrollmentFindFirstArgs>(args?: SelectSubset<T, EnrollmentFindFirstArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindFirstOrThrowArgs} args - Arguments to find a Enrollment
     * @example
     * // Get one Enrollment
     * const enrollment = await prisma.enrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollment.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EnrollmentFindManyArgs>(args?: SelectSubset<T, EnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollment.
     * @param {EnrollmentCreateArgs} args - Arguments to create a Enrollment.
     * @example
     * // Create one Enrollment
     * const Enrollment = await prisma.enrollment.create({
     *   data: {
     *     // ... data to create a Enrollment
     *   }
     * })
     * 
     */
    create<T extends EnrollmentCreateArgs>(args: SelectSubset<T, EnrollmentCreateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {EnrollmentCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EnrollmentCreateManyArgs>(args?: SelectSubset<T, EnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {EnrollmentCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollment = await prisma.enrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollment.
     * @param {EnrollmentDeleteArgs} args - Arguments to delete one Enrollment.
     * @example
     * // Delete one Enrollment
     * const Enrollment = await prisma.enrollment.delete({
     *   where: {
     *     // ... filter to delete one Enrollment
     *   }
     * })
     * 
     */
    delete<T extends EnrollmentDeleteArgs>(args: SelectSubset<T, EnrollmentDeleteArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollment.
     * @param {EnrollmentUpdateArgs} args - Arguments to update one Enrollment.
     * @example
     * // Update one Enrollment
     * const enrollment = await prisma.enrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EnrollmentUpdateArgs>(args: SelectSubset<T, EnrollmentUpdateArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {EnrollmentDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EnrollmentDeleteManyArgs>(args?: SelectSubset<T, EnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EnrollmentUpdateManyArgs>(args: SelectSubset<T, EnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {EnrollmentUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollment = await prisma.enrollment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentWithIdOnly = await prisma.enrollment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EnrollmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EnrollmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollment.
     * @param {EnrollmentUpsertArgs} args - Arguments to update or create a Enrollment.
     * @example
     * // Update or create a Enrollment
     * const enrollment = await prisma.enrollment.upsert({
     *   create: {
     *     // ... data to create a Enrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollment we want to update
     *   }
     * })
     */
    upsert<T extends EnrollmentUpsertArgs>(args: SelectSubset<T, EnrollmentUpsertArgs<ExtArgs>>): Prisma__EnrollmentClient<$Result.GetResult<Prisma.$EnrollmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollment.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends EnrollmentCountArgs>(
      args?: Subset<T, EnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentAggregateArgs>(args: Subset<T, EnrollmentAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentAggregateType<T>>

    /**
     * Group by Enrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: EnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enrollment model
   */
  readonly fields: EnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learner<T extends LearnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearnerDefaultArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Enrollment model
   */
  interface EnrollmentFieldRefs {
    readonly id: FieldRef<"Enrollment", 'Int'>
    readonly learnerId: FieldRef<"Enrollment", 'Int'>
    readonly programId: FieldRef<"Enrollment", 'Int'>
    readonly enrolledAt: FieldRef<"Enrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Enrollment findUnique
   */
  export type EnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findUniqueOrThrow
   */
  export type EnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment findFirst
   */
  export type EnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findFirstOrThrow
   */
  export type EnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollment to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enrollments.
     */
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment findMany
   */
  export type EnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which Enrollments to fetch.
     */
    where?: EnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enrollments to fetch.
     */
    orderBy?: EnrollmentOrderByWithRelationInput | EnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enrollments.
     */
    cursor?: EnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enrollments.
     */
    skip?: number
    distinct?: EnrollmentScalarFieldEnum | EnrollmentScalarFieldEnum[]
  }

  /**
   * Enrollment create
   */
  export type EnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Enrollment.
     */
    data: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
  }

  /**
   * Enrollment createMany
   */
  export type EnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Enrollment createManyAndReturn
   */
  export type EnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to create many Enrollments.
     */
    data: EnrollmentCreateManyInput | EnrollmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment update
   */
  export type EnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Enrollment.
     */
    data: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
    /**
     * Choose, which Enrollment to update.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment updateMany
   */
  export type EnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
  }

  /**
   * Enrollment updateManyAndReturn
   */
  export type EnrollmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * The data used to update Enrollments.
     */
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which Enrollments to update
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Enrollment upsert
   */
  export type EnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Enrollment to update in case it exists.
     */
    where: EnrollmentWhereUniqueInput
    /**
     * In case the Enrollment found by the `where` argument doesn't exist, create a new Enrollment with this data.
     */
    create: XOR<EnrollmentCreateInput, EnrollmentUncheckedCreateInput>
    /**
     * In case the Enrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnrollmentUpdateInput, EnrollmentUncheckedUpdateInput>
  }

  /**
   * Enrollment delete
   */
  export type EnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
    /**
     * Filter which Enrollment to delete.
     */
    where: EnrollmentWhereUniqueInput
  }

  /**
   * Enrollment deleteMany
   */
  export type EnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enrollments to delete
     */
    where?: EnrollmentWhereInput
    /**
     * Limit how many Enrollments to delete.
     */
    limit?: number
  }

  /**
   * Enrollment without action
   */
  export type EnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enrollment
     */
    select?: EnrollmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Enrollment
     */
    omit?: EnrollmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model ProgramModule
   */

  export type AggregateProgramModule = {
    _count: ProgramModuleCountAggregateOutputType | null
    _avg: ProgramModuleAvgAggregateOutputType | null
    _sum: ProgramModuleSumAggregateOutputType | null
    _min: ProgramModuleMinAggregateOutputType | null
    _max: ProgramModuleMaxAggregateOutputType | null
  }

  export type ProgramModuleAvgAggregateOutputType = {
    programId: number | null
    moduleId: number | null
    position: number | null
  }

  export type ProgramModuleSumAggregateOutputType = {
    programId: number | null
    moduleId: number | null
    position: number | null
  }

  export type ProgramModuleMinAggregateOutputType = {
    programId: number | null
    moduleId: number | null
    position: number | null
  }

  export type ProgramModuleMaxAggregateOutputType = {
    programId: number | null
    moduleId: number | null
    position: number | null
  }

  export type ProgramModuleCountAggregateOutputType = {
    programId: number
    moduleId: number
    position: number
    _all: number
  }


  export type ProgramModuleAvgAggregateInputType = {
    programId?: true
    moduleId?: true
    position?: true
  }

  export type ProgramModuleSumAggregateInputType = {
    programId?: true
    moduleId?: true
    position?: true
  }

  export type ProgramModuleMinAggregateInputType = {
    programId?: true
    moduleId?: true
    position?: true
  }

  export type ProgramModuleMaxAggregateInputType = {
    programId?: true
    moduleId?: true
    position?: true
  }

  export type ProgramModuleCountAggregateInputType = {
    programId?: true
    moduleId?: true
    position?: true
    _all?: true
  }

  export type ProgramModuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramModule to aggregate.
     */
    where?: ProgramModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramModules to fetch.
     */
    orderBy?: ProgramModuleOrderByWithRelationInput | ProgramModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramModules
    **/
    _count?: true | ProgramModuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramModuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramModuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramModuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramModuleMaxAggregateInputType
  }

  export type GetProgramModuleAggregateType<T extends ProgramModuleAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramModule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramModule[P]>
      : GetScalarType<T[P], AggregateProgramModule[P]>
  }




  export type ProgramModuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramModuleWhereInput
    orderBy?: ProgramModuleOrderByWithAggregationInput | ProgramModuleOrderByWithAggregationInput[]
    by: ProgramModuleScalarFieldEnum[] | ProgramModuleScalarFieldEnum
    having?: ProgramModuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramModuleCountAggregateInputType | true
    _avg?: ProgramModuleAvgAggregateInputType
    _sum?: ProgramModuleSumAggregateInputType
    _min?: ProgramModuleMinAggregateInputType
    _max?: ProgramModuleMaxAggregateInputType
  }

  export type ProgramModuleGroupByOutputType = {
    programId: number
    moduleId: number
    position: number
    _count: ProgramModuleCountAggregateOutputType | null
    _avg: ProgramModuleAvgAggregateOutputType | null
    _sum: ProgramModuleSumAggregateOutputType | null
    _min: ProgramModuleMinAggregateOutputType | null
    _max: ProgramModuleMaxAggregateOutputType | null
  }

  type GetProgramModuleGroupByPayload<T extends ProgramModuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramModuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramModuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramModuleGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramModuleGroupByOutputType[P]>
        }
      >
    >


  export type ProgramModuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    programId?: boolean
    moduleId?: boolean
    position?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programModule"]>

  export type ProgramModuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    programId?: boolean
    moduleId?: boolean
    position?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programModule"]>

  export type ProgramModuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    programId?: boolean
    moduleId?: boolean
    position?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programModule"]>

  export type ProgramModuleSelectScalar = {
    programId?: boolean
    moduleId?: boolean
    position?: boolean
  }

  export type ProgramModuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"programId" | "moduleId" | "position", ExtArgs["result"]["programModule"]>
  export type ProgramModuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type ProgramModuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }
  export type ProgramModuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    module?: boolean | ModuleDefaultArgs<ExtArgs>
  }

  export type $ProgramModulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramModule"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      module: Prisma.$ModulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      programId: number
      moduleId: number
      position: number
    }, ExtArgs["result"]["programModule"]>
    composites: {}
  }

  type ProgramModuleGetPayload<S extends boolean | null | undefined | ProgramModuleDefaultArgs> = $Result.GetResult<Prisma.$ProgramModulePayload, S>

  type ProgramModuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProgramModuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProgramModuleCountAggregateInputType | true
    }

  export interface ProgramModuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramModule'], meta: { name: 'ProgramModule' } }
    /**
     * Find zero or one ProgramModule that matches the filter.
     * @param {ProgramModuleFindUniqueArgs} args - Arguments to find a ProgramModule
     * @example
     * // Get one ProgramModule
     * const programModule = await prisma.programModule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramModuleFindUniqueArgs>(args: SelectSubset<T, ProgramModuleFindUniqueArgs<ExtArgs>>): Prisma__ProgramModuleClient<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProgramModule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProgramModuleFindUniqueOrThrowArgs} args - Arguments to find a ProgramModule
     * @example
     * // Get one ProgramModule
     * const programModule = await prisma.programModule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramModuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramModuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramModuleClient<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramModule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramModuleFindFirstArgs} args - Arguments to find a ProgramModule
     * @example
     * // Get one ProgramModule
     * const programModule = await prisma.programModule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramModuleFindFirstArgs>(args?: SelectSubset<T, ProgramModuleFindFirstArgs<ExtArgs>>): Prisma__ProgramModuleClient<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProgramModule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramModuleFindFirstOrThrowArgs} args - Arguments to find a ProgramModule
     * @example
     * // Get one ProgramModule
     * const programModule = await prisma.programModule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramModuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramModuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramModuleClient<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProgramModules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramModuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramModules
     * const programModules = await prisma.programModule.findMany()
     * 
     * // Get first 10 ProgramModules
     * const programModules = await prisma.programModule.findMany({ take: 10 })
     * 
     * // Only select the `programId`
     * const programModuleWithProgramIdOnly = await prisma.programModule.findMany({ select: { programId: true } })
     * 
     */
    findMany<T extends ProgramModuleFindManyArgs>(args?: SelectSubset<T, ProgramModuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProgramModule.
     * @param {ProgramModuleCreateArgs} args - Arguments to create a ProgramModule.
     * @example
     * // Create one ProgramModule
     * const ProgramModule = await prisma.programModule.create({
     *   data: {
     *     // ... data to create a ProgramModule
     *   }
     * })
     * 
     */
    create<T extends ProgramModuleCreateArgs>(args: SelectSubset<T, ProgramModuleCreateArgs<ExtArgs>>): Prisma__ProgramModuleClient<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProgramModules.
     * @param {ProgramModuleCreateManyArgs} args - Arguments to create many ProgramModules.
     * @example
     * // Create many ProgramModules
     * const programModule = await prisma.programModule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramModuleCreateManyArgs>(args?: SelectSubset<T, ProgramModuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramModules and returns the data saved in the database.
     * @param {ProgramModuleCreateManyAndReturnArgs} args - Arguments to create many ProgramModules.
     * @example
     * // Create many ProgramModules
     * const programModule = await prisma.programModule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramModules and only return the `programId`
     * const programModuleWithProgramIdOnly = await prisma.programModule.createManyAndReturn({
     *   select: { programId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramModuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramModuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProgramModule.
     * @param {ProgramModuleDeleteArgs} args - Arguments to delete one ProgramModule.
     * @example
     * // Delete one ProgramModule
     * const ProgramModule = await prisma.programModule.delete({
     *   where: {
     *     // ... filter to delete one ProgramModule
     *   }
     * })
     * 
     */
    delete<T extends ProgramModuleDeleteArgs>(args: SelectSubset<T, ProgramModuleDeleteArgs<ExtArgs>>): Prisma__ProgramModuleClient<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProgramModule.
     * @param {ProgramModuleUpdateArgs} args - Arguments to update one ProgramModule.
     * @example
     * // Update one ProgramModule
     * const programModule = await prisma.programModule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramModuleUpdateArgs>(args: SelectSubset<T, ProgramModuleUpdateArgs<ExtArgs>>): Prisma__ProgramModuleClient<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProgramModules.
     * @param {ProgramModuleDeleteManyArgs} args - Arguments to filter ProgramModules to delete.
     * @example
     * // Delete a few ProgramModules
     * const { count } = await prisma.programModule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramModuleDeleteManyArgs>(args?: SelectSubset<T, ProgramModuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramModuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramModules
     * const programModule = await prisma.programModule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramModuleUpdateManyArgs>(args: SelectSubset<T, ProgramModuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramModules and returns the data updated in the database.
     * @param {ProgramModuleUpdateManyAndReturnArgs} args - Arguments to update many ProgramModules.
     * @example
     * // Update many ProgramModules
     * const programModule = await prisma.programModule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProgramModules and only return the `programId`
     * const programModuleWithProgramIdOnly = await prisma.programModule.updateManyAndReturn({
     *   select: { programId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProgramModuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ProgramModuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProgramModule.
     * @param {ProgramModuleUpsertArgs} args - Arguments to update or create a ProgramModule.
     * @example
     * // Update or create a ProgramModule
     * const programModule = await prisma.programModule.upsert({
     *   create: {
     *     // ... data to create a ProgramModule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramModule we want to update
     *   }
     * })
     */
    upsert<T extends ProgramModuleUpsertArgs>(args: SelectSubset<T, ProgramModuleUpsertArgs<ExtArgs>>): Prisma__ProgramModuleClient<$Result.GetResult<Prisma.$ProgramModulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProgramModules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramModuleCountArgs} args - Arguments to filter ProgramModules to count.
     * @example
     * // Count the number of ProgramModules
     * const count = await prisma.programModule.count({
     *   where: {
     *     // ... the filter for the ProgramModules we want to count
     *   }
     * })
    **/
    count<T extends ProgramModuleCountArgs>(
      args?: Subset<T, ProgramModuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramModuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramModuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramModuleAggregateArgs>(args: Subset<T, ProgramModuleAggregateArgs>): Prisma.PrismaPromise<GetProgramModuleAggregateType<T>>

    /**
     * Group by ProgramModule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramModuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramModuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramModuleGroupByArgs['orderBy'] }
        : { orderBy?: ProgramModuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramModuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramModuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramModule model
   */
  readonly fields: ProgramModuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramModule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramModuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramModule model
   */
  interface ProgramModuleFieldRefs {
    readonly programId: FieldRef<"ProgramModule", 'Int'>
    readonly moduleId: FieldRef<"ProgramModule", 'Int'>
    readonly position: FieldRef<"ProgramModule", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProgramModule findUnique
   */
  export type ProgramModuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramModule to fetch.
     */
    where: ProgramModuleWhereUniqueInput
  }

  /**
   * ProgramModule findUniqueOrThrow
   */
  export type ProgramModuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramModule to fetch.
     */
    where: ProgramModuleWhereUniqueInput
  }

  /**
   * ProgramModule findFirst
   */
  export type ProgramModuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramModule to fetch.
     */
    where?: ProgramModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramModules to fetch.
     */
    orderBy?: ProgramModuleOrderByWithRelationInput | ProgramModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramModules.
     */
    cursor?: ProgramModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramModules.
     */
    distinct?: ProgramModuleScalarFieldEnum | ProgramModuleScalarFieldEnum[]
  }

  /**
   * ProgramModule findFirstOrThrow
   */
  export type ProgramModuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramModule to fetch.
     */
    where?: ProgramModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramModules to fetch.
     */
    orderBy?: ProgramModuleOrderByWithRelationInput | ProgramModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramModules.
     */
    cursor?: ProgramModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramModules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramModules.
     */
    distinct?: ProgramModuleScalarFieldEnum | ProgramModuleScalarFieldEnum[]
  }

  /**
   * ProgramModule findMany
   */
  export type ProgramModuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    /**
     * Filter, which ProgramModules to fetch.
     */
    where?: ProgramModuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramModules to fetch.
     */
    orderBy?: ProgramModuleOrderByWithRelationInput | ProgramModuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramModules.
     */
    cursor?: ProgramModuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramModules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramModules.
     */
    skip?: number
    distinct?: ProgramModuleScalarFieldEnum | ProgramModuleScalarFieldEnum[]
  }

  /**
   * ProgramModule create
   */
  export type ProgramModuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramModule.
     */
    data: XOR<ProgramModuleCreateInput, ProgramModuleUncheckedCreateInput>
  }

  /**
   * ProgramModule createMany
   */
  export type ProgramModuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramModules.
     */
    data: ProgramModuleCreateManyInput | ProgramModuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramModule createManyAndReturn
   */
  export type ProgramModuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * The data used to create many ProgramModules.
     */
    data: ProgramModuleCreateManyInput | ProgramModuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramModule update
   */
  export type ProgramModuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramModule.
     */
    data: XOR<ProgramModuleUpdateInput, ProgramModuleUncheckedUpdateInput>
    /**
     * Choose, which ProgramModule to update.
     */
    where: ProgramModuleWhereUniqueInput
  }

  /**
   * ProgramModule updateMany
   */
  export type ProgramModuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramModules.
     */
    data: XOR<ProgramModuleUpdateManyMutationInput, ProgramModuleUncheckedUpdateManyInput>
    /**
     * Filter which ProgramModules to update
     */
    where?: ProgramModuleWhereInput
    /**
     * Limit how many ProgramModules to update.
     */
    limit?: number
  }

  /**
   * ProgramModule updateManyAndReturn
   */
  export type ProgramModuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * The data used to update ProgramModules.
     */
    data: XOR<ProgramModuleUpdateManyMutationInput, ProgramModuleUncheckedUpdateManyInput>
    /**
     * Filter which ProgramModules to update
     */
    where?: ProgramModuleWhereInput
    /**
     * Limit how many ProgramModules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramModule upsert
   */
  export type ProgramModuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramModule to update in case it exists.
     */
    where: ProgramModuleWhereUniqueInput
    /**
     * In case the ProgramModule found by the `where` argument doesn't exist, create a new ProgramModule with this data.
     */
    create: XOR<ProgramModuleCreateInput, ProgramModuleUncheckedCreateInput>
    /**
     * In case the ProgramModule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramModuleUpdateInput, ProgramModuleUncheckedUpdateInput>
  }

  /**
   * ProgramModule delete
   */
  export type ProgramModuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
    /**
     * Filter which ProgramModule to delete.
     */
    where: ProgramModuleWhereUniqueInput
  }

  /**
   * ProgramModule deleteMany
   */
  export type ProgramModuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramModules to delete
     */
    where?: ProgramModuleWhereInput
    /**
     * Limit how many ProgramModules to delete.
     */
    limit?: number
  }

  /**
   * ProgramModule without action
   */
  export type ProgramModuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramModule
     */
    select?: ProgramModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProgramModule
     */
    omit?: ProgramModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramModuleInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    id: number | null
    prerequisiteTopicId: number | null
    status: number | null
  }

  export type TopicSumAggregateOutputType = {
    id: number | null
    prerequisiteTopicId: number | null
    status: number | null
  }

  export type TopicMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    prerequisiteTopicId: number | null
    status: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    prerequisiteTopicId: number | null
    status: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    title: number
    content: number
    prerequisiteTopicId: number
    status: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    id?: true
    prerequisiteTopicId?: true
    status?: true
  }

  export type TopicSumAggregateInputType = {
    id?: true
    prerequisiteTopicId?: true
    status?: true
  }

  export type TopicMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    prerequisiteTopicId?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    prerequisiteTopicId?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    prerequisiteTopicId?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: number
    title: string
    content: string | null
    prerequisiteTopicId: number | null
    status: number | null
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    prerequisiteTopicId?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prerequisiteTopic?: boolean | Topic$prerequisiteTopicArgs<ExtArgs>
    dependentTopics?: boolean | Topic$dependentTopicsArgs<ExtArgs>
    measureProgress?: boolean | Topic$measureProgressArgs<ExtArgs>
    moduleTopics?: boolean | Topic$moduleTopicsArgs<ExtArgs>
    topicResources?: boolean | Topic$topicResourcesArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    prerequisiteTopicId?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prerequisiteTopic?: boolean | Topic$prerequisiteTopicArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    prerequisiteTopicId?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    prerequisiteTopic?: boolean | Topic$prerequisiteTopicArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    prerequisiteTopicId?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "prerequisiteTopicId" | "status" | "isDeleted" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["topic"]>
  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prerequisiteTopic?: boolean | Topic$prerequisiteTopicArgs<ExtArgs>
    dependentTopics?: boolean | Topic$dependentTopicsArgs<ExtArgs>
    measureProgress?: boolean | Topic$measureProgressArgs<ExtArgs>
    moduleTopics?: boolean | Topic$moduleTopicsArgs<ExtArgs>
    topicResources?: boolean | Topic$topicResourcesArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prerequisiteTopic?: boolean | Topic$prerequisiteTopicArgs<ExtArgs>
  }
  export type TopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prerequisiteTopic?: boolean | Topic$prerequisiteTopicArgs<ExtArgs>
  }

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      prerequisiteTopic: Prisma.$TopicPayload<ExtArgs> | null
      dependentTopics: Prisma.$TopicPayload<ExtArgs>[]
      measureProgress: Prisma.$MeasureProgressPayload<ExtArgs>[]
      moduleTopics: Prisma.$ModuleTopicPayload<ExtArgs>[]
      topicResources: Prisma.$TopicResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string | null
      prerequisiteTopicId: number | null
      status: number | null
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics and returns the data updated in the database.
     * @param {TopicUpdateManyAndReturnArgs} args - Arguments to update many Topics.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prerequisiteTopic<T extends Topic$prerequisiteTopicArgs<ExtArgs> = {}>(args?: Subset<T, Topic$prerequisiteTopicArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    dependentTopics<T extends Topic$dependentTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$dependentTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    measureProgress<T extends Topic$measureProgressArgs<ExtArgs> = {}>(args?: Subset<T, Topic$measureProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moduleTopics<T extends Topic$moduleTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$moduleTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topicResources<T extends Topic$topicResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Topic$topicResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'Int'>
    readonly title: FieldRef<"Topic", 'String'>
    readonly content: FieldRef<"Topic", 'String'>
    readonly prerequisiteTopicId: FieldRef<"Topic", 'Int'>
    readonly status: FieldRef<"Topic", 'Int'>
    readonly isDeleted: FieldRef<"Topic", 'Boolean'>
    readonly deletedAt: FieldRef<"Topic", 'DateTime'>
    readonly createdAt: FieldRef<"Topic", 'DateTime'>
    readonly updatedAt: FieldRef<"Topic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topic updateManyAndReturn
   */
  export type TopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to delete.
     */
    limit?: number
  }

  /**
   * Topic.prerequisiteTopic
   */
  export type Topic$prerequisiteTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
  }

  /**
   * Topic.dependentTopics
   */
  export type Topic$dependentTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    cursor?: TopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic.measureProgress
   */
  export type Topic$measureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    where?: MeasureProgressWhereInput
    orderBy?: MeasureProgressOrderByWithRelationInput | MeasureProgressOrderByWithRelationInput[]
    cursor?: MeasureProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeasureProgressScalarFieldEnum | MeasureProgressScalarFieldEnum[]
  }

  /**
   * Topic.moduleTopics
   */
  export type Topic$moduleTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    where?: ModuleTopicWhereInput
    orderBy?: ModuleTopicOrderByWithRelationInput | ModuleTopicOrderByWithRelationInput[]
    cursor?: ModuleTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModuleTopicScalarFieldEnum | ModuleTopicScalarFieldEnum[]
  }

  /**
   * Topic.topicResources
   */
  export type Topic$topicResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    where?: TopicResourceWhereInput
    orderBy?: TopicResourceOrderByWithRelationInput | TopicResourceOrderByWithRelationInput[]
    cursor?: TopicResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicResourceScalarFieldEnum | TopicResourceScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model ModuleTopic
   */

  export type AggregateModuleTopic = {
    _count: ModuleTopicCountAggregateOutputType | null
    _avg: ModuleTopicAvgAggregateOutputType | null
    _sum: ModuleTopicSumAggregateOutputType | null
    _min: ModuleTopicMinAggregateOutputType | null
    _max: ModuleTopicMaxAggregateOutputType | null
  }

  export type ModuleTopicAvgAggregateOutputType = {
    moduleId: number | null
    topicId: number | null
    position: number | null
  }

  export type ModuleTopicSumAggregateOutputType = {
    moduleId: number | null
    topicId: number | null
    position: number | null
  }

  export type ModuleTopicMinAggregateOutputType = {
    moduleId: number | null
    topicId: number | null
    position: number | null
  }

  export type ModuleTopicMaxAggregateOutputType = {
    moduleId: number | null
    topicId: number | null
    position: number | null
  }

  export type ModuleTopicCountAggregateOutputType = {
    moduleId: number
    topicId: number
    position: number
    _all: number
  }


  export type ModuleTopicAvgAggregateInputType = {
    moduleId?: true
    topicId?: true
    position?: true
  }

  export type ModuleTopicSumAggregateInputType = {
    moduleId?: true
    topicId?: true
    position?: true
  }

  export type ModuleTopicMinAggregateInputType = {
    moduleId?: true
    topicId?: true
    position?: true
  }

  export type ModuleTopicMaxAggregateInputType = {
    moduleId?: true
    topicId?: true
    position?: true
  }

  export type ModuleTopicCountAggregateInputType = {
    moduleId?: true
    topicId?: true
    position?: true
    _all?: true
  }

  export type ModuleTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleTopic to aggregate.
     */
    where?: ModuleTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleTopics to fetch.
     */
    orderBy?: ModuleTopicOrderByWithRelationInput | ModuleTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModuleTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModuleTopics
    **/
    _count?: true | ModuleTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModuleTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModuleTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModuleTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModuleTopicMaxAggregateInputType
  }

  export type GetModuleTopicAggregateType<T extends ModuleTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateModuleTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModuleTopic[P]>
      : GetScalarType<T[P], AggregateModuleTopic[P]>
  }




  export type ModuleTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModuleTopicWhereInput
    orderBy?: ModuleTopicOrderByWithAggregationInput | ModuleTopicOrderByWithAggregationInput[]
    by: ModuleTopicScalarFieldEnum[] | ModuleTopicScalarFieldEnum
    having?: ModuleTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModuleTopicCountAggregateInputType | true
    _avg?: ModuleTopicAvgAggregateInputType
    _sum?: ModuleTopicSumAggregateInputType
    _min?: ModuleTopicMinAggregateInputType
    _max?: ModuleTopicMaxAggregateInputType
  }

  export type ModuleTopicGroupByOutputType = {
    moduleId: number
    topicId: number
    position: number
    _count: ModuleTopicCountAggregateOutputType | null
    _avg: ModuleTopicAvgAggregateOutputType | null
    _sum: ModuleTopicSumAggregateOutputType | null
    _min: ModuleTopicMinAggregateOutputType | null
    _max: ModuleTopicMaxAggregateOutputType | null
  }

  type GetModuleTopicGroupByPayload<T extends ModuleTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModuleTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModuleTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModuleTopicGroupByOutputType[P]>
            : GetScalarType<T[P], ModuleTopicGroupByOutputType[P]>
        }
      >
    >


  export type ModuleTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleId?: boolean
    topicId?: boolean
    position?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleTopic"]>

  export type ModuleTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleId?: boolean
    topicId?: boolean
    position?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleTopic"]>

  export type ModuleTopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    moduleId?: boolean
    topicId?: boolean
    position?: boolean
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moduleTopic"]>

  export type ModuleTopicSelectScalar = {
    moduleId?: boolean
    topicId?: boolean
    position?: boolean
  }

  export type ModuleTopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"moduleId" | "topicId" | "position", ExtArgs["result"]["moduleTopic"]>
  export type ModuleTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type ModuleTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type ModuleTopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    module?: boolean | ModuleDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $ModuleTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModuleTopic"
    objects: {
      module: Prisma.$ModulePayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      moduleId: number
      topicId: number
      position: number
    }, ExtArgs["result"]["moduleTopic"]>
    composites: {}
  }

  type ModuleTopicGetPayload<S extends boolean | null | undefined | ModuleTopicDefaultArgs> = $Result.GetResult<Prisma.$ModuleTopicPayload, S>

  type ModuleTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModuleTopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModuleTopicCountAggregateInputType | true
    }

  export interface ModuleTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModuleTopic'], meta: { name: 'ModuleTopic' } }
    /**
     * Find zero or one ModuleTopic that matches the filter.
     * @param {ModuleTopicFindUniqueArgs} args - Arguments to find a ModuleTopic
     * @example
     * // Get one ModuleTopic
     * const moduleTopic = await prisma.moduleTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModuleTopicFindUniqueArgs>(args: SelectSubset<T, ModuleTopicFindUniqueArgs<ExtArgs>>): Prisma__ModuleTopicClient<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModuleTopic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModuleTopicFindUniqueOrThrowArgs} args - Arguments to find a ModuleTopic
     * @example
     * // Get one ModuleTopic
     * const moduleTopic = await prisma.moduleTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModuleTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, ModuleTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModuleTopicClient<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleTopicFindFirstArgs} args - Arguments to find a ModuleTopic
     * @example
     * // Get one ModuleTopic
     * const moduleTopic = await prisma.moduleTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModuleTopicFindFirstArgs>(args?: SelectSubset<T, ModuleTopicFindFirstArgs<ExtArgs>>): Prisma__ModuleTopicClient<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModuleTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleTopicFindFirstOrThrowArgs} args - Arguments to find a ModuleTopic
     * @example
     * // Get one ModuleTopic
     * const moduleTopic = await prisma.moduleTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModuleTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, ModuleTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModuleTopicClient<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModuleTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModuleTopics
     * const moduleTopics = await prisma.moduleTopic.findMany()
     * 
     * // Get first 10 ModuleTopics
     * const moduleTopics = await prisma.moduleTopic.findMany({ take: 10 })
     * 
     * // Only select the `moduleId`
     * const moduleTopicWithModuleIdOnly = await prisma.moduleTopic.findMany({ select: { moduleId: true } })
     * 
     */
    findMany<T extends ModuleTopicFindManyArgs>(args?: SelectSubset<T, ModuleTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModuleTopic.
     * @param {ModuleTopicCreateArgs} args - Arguments to create a ModuleTopic.
     * @example
     * // Create one ModuleTopic
     * const ModuleTopic = await prisma.moduleTopic.create({
     *   data: {
     *     // ... data to create a ModuleTopic
     *   }
     * })
     * 
     */
    create<T extends ModuleTopicCreateArgs>(args: SelectSubset<T, ModuleTopicCreateArgs<ExtArgs>>): Prisma__ModuleTopicClient<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModuleTopics.
     * @param {ModuleTopicCreateManyArgs} args - Arguments to create many ModuleTopics.
     * @example
     * // Create many ModuleTopics
     * const moduleTopic = await prisma.moduleTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModuleTopicCreateManyArgs>(args?: SelectSubset<T, ModuleTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModuleTopics and returns the data saved in the database.
     * @param {ModuleTopicCreateManyAndReturnArgs} args - Arguments to create many ModuleTopics.
     * @example
     * // Create many ModuleTopics
     * const moduleTopic = await prisma.moduleTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModuleTopics and only return the `moduleId`
     * const moduleTopicWithModuleIdOnly = await prisma.moduleTopic.createManyAndReturn({
     *   select: { moduleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModuleTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, ModuleTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModuleTopic.
     * @param {ModuleTopicDeleteArgs} args - Arguments to delete one ModuleTopic.
     * @example
     * // Delete one ModuleTopic
     * const ModuleTopic = await prisma.moduleTopic.delete({
     *   where: {
     *     // ... filter to delete one ModuleTopic
     *   }
     * })
     * 
     */
    delete<T extends ModuleTopicDeleteArgs>(args: SelectSubset<T, ModuleTopicDeleteArgs<ExtArgs>>): Prisma__ModuleTopicClient<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModuleTopic.
     * @param {ModuleTopicUpdateArgs} args - Arguments to update one ModuleTopic.
     * @example
     * // Update one ModuleTopic
     * const moduleTopic = await prisma.moduleTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModuleTopicUpdateArgs>(args: SelectSubset<T, ModuleTopicUpdateArgs<ExtArgs>>): Prisma__ModuleTopicClient<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModuleTopics.
     * @param {ModuleTopicDeleteManyArgs} args - Arguments to filter ModuleTopics to delete.
     * @example
     * // Delete a few ModuleTopics
     * const { count } = await prisma.moduleTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModuleTopicDeleteManyArgs>(args?: SelectSubset<T, ModuleTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModuleTopics
     * const moduleTopic = await prisma.moduleTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModuleTopicUpdateManyArgs>(args: SelectSubset<T, ModuleTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModuleTopics and returns the data updated in the database.
     * @param {ModuleTopicUpdateManyAndReturnArgs} args - Arguments to update many ModuleTopics.
     * @example
     * // Update many ModuleTopics
     * const moduleTopic = await prisma.moduleTopic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModuleTopics and only return the `moduleId`
     * const moduleTopicWithModuleIdOnly = await prisma.moduleTopic.updateManyAndReturn({
     *   select: { moduleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModuleTopicUpdateManyAndReturnArgs>(args: SelectSubset<T, ModuleTopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModuleTopic.
     * @param {ModuleTopicUpsertArgs} args - Arguments to update or create a ModuleTopic.
     * @example
     * // Update or create a ModuleTopic
     * const moduleTopic = await prisma.moduleTopic.upsert({
     *   create: {
     *     // ... data to create a ModuleTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModuleTopic we want to update
     *   }
     * })
     */
    upsert<T extends ModuleTopicUpsertArgs>(args: SelectSubset<T, ModuleTopicUpsertArgs<ExtArgs>>): Prisma__ModuleTopicClient<$Result.GetResult<Prisma.$ModuleTopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModuleTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleTopicCountArgs} args - Arguments to filter ModuleTopics to count.
     * @example
     * // Count the number of ModuleTopics
     * const count = await prisma.moduleTopic.count({
     *   where: {
     *     // ... the filter for the ModuleTopics we want to count
     *   }
     * })
    **/
    count<T extends ModuleTopicCountArgs>(
      args?: Subset<T, ModuleTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModuleTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModuleTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModuleTopicAggregateArgs>(args: Subset<T, ModuleTopicAggregateArgs>): Prisma.PrismaPromise<GetModuleTopicAggregateType<T>>

    /**
     * Group by ModuleTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModuleTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModuleTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModuleTopicGroupByArgs['orderBy'] }
        : { orderBy?: ModuleTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModuleTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModuleTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModuleTopic model
   */
  readonly fields: ModuleTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModuleTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModuleTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    module<T extends ModuleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ModuleDefaultArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModuleTopic model
   */
  interface ModuleTopicFieldRefs {
    readonly moduleId: FieldRef<"ModuleTopic", 'Int'>
    readonly topicId: FieldRef<"ModuleTopic", 'Int'>
    readonly position: FieldRef<"ModuleTopic", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ModuleTopic findUnique
   */
  export type ModuleTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    /**
     * Filter, which ModuleTopic to fetch.
     */
    where: ModuleTopicWhereUniqueInput
  }

  /**
   * ModuleTopic findUniqueOrThrow
   */
  export type ModuleTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    /**
     * Filter, which ModuleTopic to fetch.
     */
    where: ModuleTopicWhereUniqueInput
  }

  /**
   * ModuleTopic findFirst
   */
  export type ModuleTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    /**
     * Filter, which ModuleTopic to fetch.
     */
    where?: ModuleTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleTopics to fetch.
     */
    orderBy?: ModuleTopicOrderByWithRelationInput | ModuleTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleTopics.
     */
    cursor?: ModuleTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleTopics.
     */
    distinct?: ModuleTopicScalarFieldEnum | ModuleTopicScalarFieldEnum[]
  }

  /**
   * ModuleTopic findFirstOrThrow
   */
  export type ModuleTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    /**
     * Filter, which ModuleTopic to fetch.
     */
    where?: ModuleTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleTopics to fetch.
     */
    orderBy?: ModuleTopicOrderByWithRelationInput | ModuleTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModuleTopics.
     */
    cursor?: ModuleTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModuleTopics.
     */
    distinct?: ModuleTopicScalarFieldEnum | ModuleTopicScalarFieldEnum[]
  }

  /**
   * ModuleTopic findMany
   */
  export type ModuleTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    /**
     * Filter, which ModuleTopics to fetch.
     */
    where?: ModuleTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModuleTopics to fetch.
     */
    orderBy?: ModuleTopicOrderByWithRelationInput | ModuleTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModuleTopics.
     */
    cursor?: ModuleTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ModuleTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModuleTopics.
     */
    skip?: number
    distinct?: ModuleTopicScalarFieldEnum | ModuleTopicScalarFieldEnum[]
  }

  /**
   * ModuleTopic create
   */
  export type ModuleTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a ModuleTopic.
     */
    data: XOR<ModuleTopicCreateInput, ModuleTopicUncheckedCreateInput>
  }

  /**
   * ModuleTopic createMany
   */
  export type ModuleTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModuleTopics.
     */
    data: ModuleTopicCreateManyInput | ModuleTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModuleTopic createManyAndReturn
   */
  export type ModuleTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * The data used to create many ModuleTopics.
     */
    data: ModuleTopicCreateManyInput | ModuleTopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleTopic update
   */
  export type ModuleTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a ModuleTopic.
     */
    data: XOR<ModuleTopicUpdateInput, ModuleTopicUncheckedUpdateInput>
    /**
     * Choose, which ModuleTopic to update.
     */
    where: ModuleTopicWhereUniqueInput
  }

  /**
   * ModuleTopic updateMany
   */
  export type ModuleTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModuleTopics.
     */
    data: XOR<ModuleTopicUpdateManyMutationInput, ModuleTopicUncheckedUpdateManyInput>
    /**
     * Filter which ModuleTopics to update
     */
    where?: ModuleTopicWhereInput
    /**
     * Limit how many ModuleTopics to update.
     */
    limit?: number
  }

  /**
   * ModuleTopic updateManyAndReturn
   */
  export type ModuleTopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * The data used to update ModuleTopics.
     */
    data: XOR<ModuleTopicUpdateManyMutationInput, ModuleTopicUncheckedUpdateManyInput>
    /**
     * Filter which ModuleTopics to update
     */
    where?: ModuleTopicWhereInput
    /**
     * Limit how many ModuleTopics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ModuleTopic upsert
   */
  export type ModuleTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the ModuleTopic to update in case it exists.
     */
    where: ModuleTopicWhereUniqueInput
    /**
     * In case the ModuleTopic found by the `where` argument doesn't exist, create a new ModuleTopic with this data.
     */
    create: XOR<ModuleTopicCreateInput, ModuleTopicUncheckedCreateInput>
    /**
     * In case the ModuleTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModuleTopicUpdateInput, ModuleTopicUncheckedUpdateInput>
  }

  /**
   * ModuleTopic delete
   */
  export type ModuleTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
    /**
     * Filter which ModuleTopic to delete.
     */
    where: ModuleTopicWhereUniqueInput
  }

  /**
   * ModuleTopic deleteMany
   */
  export type ModuleTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModuleTopics to delete
     */
    where?: ModuleTopicWhereInput
    /**
     * Limit how many ModuleTopics to delete.
     */
    limit?: number
  }

  /**
   * ModuleTopic without action
   */
  export type ModuleTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModuleTopic
     */
    select?: ModuleTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModuleTopic
     */
    omit?: ModuleTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleTopicInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type ResourceSumAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: number | null
    resourceType: $Enums.ResourceType | null
    url: string | null
    title: string | null
    description: string | null
    status: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: number | null
    resourceType: $Enums.ResourceType | null
    url: string | null
    title: string | null
    description: string | null
    status: number | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    resourceType: number
    url: number
    title: number
    description: number
    status: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    id?: true
    status?: true
  }

  export type ResourceSumAggregateInputType = {
    id?: true
    status?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    resourceType?: true
    url?: true
    title?: true
    description?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    resourceType?: true
    url?: true
    title?: true
    description?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    resourceType?: true
    url?: true
    title?: true
    description?: true
    status?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: number
    resourceType: $Enums.ResourceType
    url: string
    title: string | null
    description: string | null
    status: number | null
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceType?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    resourceViews?: boolean | Resource$resourceViewsArgs<ExtArgs>
    measureProgress?: boolean | Resource$measureProgressArgs<ExtArgs>
    topicResources?: boolean | Resource$topicResourcesArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceType?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resourceType?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["resource"]>

  export type ResourceSelectScalar = {
    id?: boolean
    resourceType?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type ResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resourceType" | "url" | "title" | "description" | "status" | "isDeleted" | "deletedAt" | "createdAt", ExtArgs["result"]["resource"]>
  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resourceViews?: boolean | Resource$resourceViewsArgs<ExtArgs>
    measureProgress?: boolean | Resource$measureProgressArgs<ExtArgs>
    topicResources?: boolean | Resource$topicResourcesArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      resourceViews: Prisma.$ResourceViewPayload<ExtArgs>[]
      measureProgress: Prisma.$MeasureProgressPayload<ExtArgs>[]
      topicResources: Prisma.$TopicResourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      resourceType: $Enums.ResourceType
      url: string
      title: string | null
      description: string | null
      status: number | null
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resources and returns the data saved in the database.
     * @param {ResourceCreateManyAndReturnArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources and returns the data updated in the database.
     * @param {ResourceUpdateManyAndReturnArgs} args - Arguments to update many Resources.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resources and only return the `id`
     * const resourceWithIdOnly = await prisma.resource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resourceViews<T extends Resource$resourceViewsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$resourceViewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    measureProgress<T extends Resource$measureProgressArgs<ExtArgs> = {}>(args?: Subset<T, Resource$measureProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topicResources<T extends Resource$topicResourcesArgs<ExtArgs> = {}>(args?: Subset<T, Resource$topicResourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'Int'>
    readonly resourceType: FieldRef<"Resource", 'ResourceType'>
    readonly url: FieldRef<"Resource", 'String'>
    readonly title: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly status: FieldRef<"Resource", 'Int'>
    readonly isDeleted: FieldRef<"Resource", 'Boolean'>
    readonly deletedAt: FieldRef<"Resource", 'DateTime'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource createManyAndReturn
   */
  export type ResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource updateManyAndReturn
   */
  export type ResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to update.
     */
    limit?: number
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
    /**
     * Limit how many Resources to delete.
     */
    limit?: number
  }

  /**
   * Resource.resourceViews
   */
  export type Resource$resourceViewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    where?: ResourceViewWhereInput
    orderBy?: ResourceViewOrderByWithRelationInput | ResourceViewOrderByWithRelationInput[]
    cursor?: ResourceViewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResourceViewScalarFieldEnum | ResourceViewScalarFieldEnum[]
  }

  /**
   * Resource.measureProgress
   */
  export type Resource$measureProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    where?: MeasureProgressWhereInput
    orderBy?: MeasureProgressOrderByWithRelationInput | MeasureProgressOrderByWithRelationInput[]
    cursor?: MeasureProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeasureProgressScalarFieldEnum | MeasureProgressScalarFieldEnum[]
  }

  /**
   * Resource.topicResources
   */
  export type Resource$topicResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    where?: TopicResourceWhereInput
    orderBy?: TopicResourceOrderByWithRelationInput | TopicResourceOrderByWithRelationInput[]
    cursor?: TopicResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicResourceScalarFieldEnum | TopicResourceScalarFieldEnum[]
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model TopicResource
   */

  export type AggregateTopicResource = {
    _count: TopicResourceCountAggregateOutputType | null
    _avg: TopicResourceAvgAggregateOutputType | null
    _sum: TopicResourceSumAggregateOutputType | null
    _min: TopicResourceMinAggregateOutputType | null
    _max: TopicResourceMaxAggregateOutputType | null
  }

  export type TopicResourceAvgAggregateOutputType = {
    topicId: number | null
    resourceId: number | null
    position: number | null
  }

  export type TopicResourceSumAggregateOutputType = {
    topicId: number | null
    resourceId: number | null
    position: number | null
  }

  export type TopicResourceMinAggregateOutputType = {
    topicId: number | null
    resourceId: number | null
    position: number | null
  }

  export type TopicResourceMaxAggregateOutputType = {
    topicId: number | null
    resourceId: number | null
    position: number | null
  }

  export type TopicResourceCountAggregateOutputType = {
    topicId: number
    resourceId: number
    position: number
    _all: number
  }


  export type TopicResourceAvgAggregateInputType = {
    topicId?: true
    resourceId?: true
    position?: true
  }

  export type TopicResourceSumAggregateInputType = {
    topicId?: true
    resourceId?: true
    position?: true
  }

  export type TopicResourceMinAggregateInputType = {
    topicId?: true
    resourceId?: true
    position?: true
  }

  export type TopicResourceMaxAggregateInputType = {
    topicId?: true
    resourceId?: true
    position?: true
  }

  export type TopicResourceCountAggregateInputType = {
    topicId?: true
    resourceId?: true
    position?: true
    _all?: true
  }

  export type TopicResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicResource to aggregate.
     */
    where?: TopicResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicResources to fetch.
     */
    orderBy?: TopicResourceOrderByWithRelationInput | TopicResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopicResources
    **/
    _count?: true | TopicResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicResourceMaxAggregateInputType
  }

  export type GetTopicResourceAggregateType<T extends TopicResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateTopicResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopicResource[P]>
      : GetScalarType<T[P], AggregateTopicResource[P]>
  }




  export type TopicResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicResourceWhereInput
    orderBy?: TopicResourceOrderByWithAggregationInput | TopicResourceOrderByWithAggregationInput[]
    by: TopicResourceScalarFieldEnum[] | TopicResourceScalarFieldEnum
    having?: TopicResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicResourceCountAggregateInputType | true
    _avg?: TopicResourceAvgAggregateInputType
    _sum?: TopicResourceSumAggregateInputType
    _min?: TopicResourceMinAggregateInputType
    _max?: TopicResourceMaxAggregateInputType
  }

  export type TopicResourceGroupByOutputType = {
    topicId: number
    resourceId: number
    position: number
    _count: TopicResourceCountAggregateOutputType | null
    _avg: TopicResourceAvgAggregateOutputType | null
    _sum: TopicResourceSumAggregateOutputType | null
    _min: TopicResourceMinAggregateOutputType | null
    _max: TopicResourceMaxAggregateOutputType | null
  }

  type GetTopicResourceGroupByPayload<T extends TopicResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicResourceGroupByOutputType[P]>
            : GetScalarType<T[P], TopicResourceGroupByOutputType[P]>
        }
      >
    >


  export type TopicResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    topicId?: boolean
    resourceId?: boolean
    position?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicResource"]>

  export type TopicResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    topicId?: boolean
    resourceId?: boolean
    position?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicResource"]>

  export type TopicResourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    topicId?: boolean
    resourceId?: boolean
    position?: boolean
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicResource"]>

  export type TopicResourceSelectScalar = {
    topicId?: boolean
    resourceId?: boolean
    position?: boolean
  }

  export type TopicResourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"topicId" | "resourceId" | "position", ExtArgs["result"]["topicResource"]>
  export type TopicResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type TopicResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type TopicResourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $TopicResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TopicResource"
    objects: {
      topic: Prisma.$TopicPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      topicId: number
      resourceId: number
      position: number
    }, ExtArgs["result"]["topicResource"]>
    composites: {}
  }

  type TopicResourceGetPayload<S extends boolean | null | undefined | TopicResourceDefaultArgs> = $Result.GetResult<Prisma.$TopicResourcePayload, S>

  type TopicResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicResourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicResourceCountAggregateInputType | true
    }

  export interface TopicResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TopicResource'], meta: { name: 'TopicResource' } }
    /**
     * Find zero or one TopicResource that matches the filter.
     * @param {TopicResourceFindUniqueArgs} args - Arguments to find a TopicResource
     * @example
     * // Get one TopicResource
     * const topicResource = await prisma.topicResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicResourceFindUniqueArgs>(args: SelectSubset<T, TopicResourceFindUniqueArgs<ExtArgs>>): Prisma__TopicResourceClient<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TopicResource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicResourceFindUniqueOrThrowArgs} args - Arguments to find a TopicResource
     * @example
     * // Get one TopicResource
     * const topicResource = await prisma.topicResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicResourceClient<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicResourceFindFirstArgs} args - Arguments to find a TopicResource
     * @example
     * // Get one TopicResource
     * const topicResource = await prisma.topicResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicResourceFindFirstArgs>(args?: SelectSubset<T, TopicResourceFindFirstArgs<ExtArgs>>): Prisma__TopicResourceClient<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicResourceFindFirstOrThrowArgs} args - Arguments to find a TopicResource
     * @example
     * // Get one TopicResource
     * const topicResource = await prisma.topicResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicResourceClient<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TopicResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopicResources
     * const topicResources = await prisma.topicResource.findMany()
     * 
     * // Get first 10 TopicResources
     * const topicResources = await prisma.topicResource.findMany({ take: 10 })
     * 
     * // Only select the `topicId`
     * const topicResourceWithTopicIdOnly = await prisma.topicResource.findMany({ select: { topicId: true } })
     * 
     */
    findMany<T extends TopicResourceFindManyArgs>(args?: SelectSubset<T, TopicResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TopicResource.
     * @param {TopicResourceCreateArgs} args - Arguments to create a TopicResource.
     * @example
     * // Create one TopicResource
     * const TopicResource = await prisma.topicResource.create({
     *   data: {
     *     // ... data to create a TopicResource
     *   }
     * })
     * 
     */
    create<T extends TopicResourceCreateArgs>(args: SelectSubset<T, TopicResourceCreateArgs<ExtArgs>>): Prisma__TopicResourceClient<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TopicResources.
     * @param {TopicResourceCreateManyArgs} args - Arguments to create many TopicResources.
     * @example
     * // Create many TopicResources
     * const topicResource = await prisma.topicResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicResourceCreateManyArgs>(args?: SelectSubset<T, TopicResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TopicResources and returns the data saved in the database.
     * @param {TopicResourceCreateManyAndReturnArgs} args - Arguments to create many TopicResources.
     * @example
     * // Create many TopicResources
     * const topicResource = await prisma.topicResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TopicResources and only return the `topicId`
     * const topicResourceWithTopicIdOnly = await prisma.topicResource.createManyAndReturn({
     *   select: { topicId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TopicResource.
     * @param {TopicResourceDeleteArgs} args - Arguments to delete one TopicResource.
     * @example
     * // Delete one TopicResource
     * const TopicResource = await prisma.topicResource.delete({
     *   where: {
     *     // ... filter to delete one TopicResource
     *   }
     * })
     * 
     */
    delete<T extends TopicResourceDeleteArgs>(args: SelectSubset<T, TopicResourceDeleteArgs<ExtArgs>>): Prisma__TopicResourceClient<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TopicResource.
     * @param {TopicResourceUpdateArgs} args - Arguments to update one TopicResource.
     * @example
     * // Update one TopicResource
     * const topicResource = await prisma.topicResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicResourceUpdateArgs>(args: SelectSubset<T, TopicResourceUpdateArgs<ExtArgs>>): Prisma__TopicResourceClient<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TopicResources.
     * @param {TopicResourceDeleteManyArgs} args - Arguments to filter TopicResources to delete.
     * @example
     * // Delete a few TopicResources
     * const { count } = await prisma.topicResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicResourceDeleteManyArgs>(args?: SelectSubset<T, TopicResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopicResources
     * const topicResource = await prisma.topicResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicResourceUpdateManyArgs>(args: SelectSubset<T, TopicResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicResources and returns the data updated in the database.
     * @param {TopicResourceUpdateManyAndReturnArgs} args - Arguments to update many TopicResources.
     * @example
     * // Update many TopicResources
     * const topicResource = await prisma.topicResource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TopicResources and only return the `topicId`
     * const topicResourceWithTopicIdOnly = await prisma.topicResource.updateManyAndReturn({
     *   select: { topicId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicResourceUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicResourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TopicResource.
     * @param {TopicResourceUpsertArgs} args - Arguments to update or create a TopicResource.
     * @example
     * // Update or create a TopicResource
     * const topicResource = await prisma.topicResource.upsert({
     *   create: {
     *     // ... data to create a TopicResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopicResource we want to update
     *   }
     * })
     */
    upsert<T extends TopicResourceUpsertArgs>(args: SelectSubset<T, TopicResourceUpsertArgs<ExtArgs>>): Prisma__TopicResourceClient<$Result.GetResult<Prisma.$TopicResourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TopicResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicResourceCountArgs} args - Arguments to filter TopicResources to count.
     * @example
     * // Count the number of TopicResources
     * const count = await prisma.topicResource.count({
     *   where: {
     *     // ... the filter for the TopicResources we want to count
     *   }
     * })
    **/
    count<T extends TopicResourceCountArgs>(
      args?: Subset<T, TopicResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopicResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicResourceAggregateArgs>(args: Subset<T, TopicResourceAggregateArgs>): Prisma.PrismaPromise<GetTopicResourceAggregateType<T>>

    /**
     * Group by TopicResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicResourceGroupByArgs['orderBy'] }
        : { orderBy?: TopicResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TopicResource model
   */
  readonly fields: TopicResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TopicResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TopicResource model
   */
  interface TopicResourceFieldRefs {
    readonly topicId: FieldRef<"TopicResource", 'Int'>
    readonly resourceId: FieldRef<"TopicResource", 'Int'>
    readonly position: FieldRef<"TopicResource", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TopicResource findUnique
   */
  export type TopicResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    /**
     * Filter, which TopicResource to fetch.
     */
    where: TopicResourceWhereUniqueInput
  }

  /**
   * TopicResource findUniqueOrThrow
   */
  export type TopicResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    /**
     * Filter, which TopicResource to fetch.
     */
    where: TopicResourceWhereUniqueInput
  }

  /**
   * TopicResource findFirst
   */
  export type TopicResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    /**
     * Filter, which TopicResource to fetch.
     */
    where?: TopicResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicResources to fetch.
     */
    orderBy?: TopicResourceOrderByWithRelationInput | TopicResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicResources.
     */
    cursor?: TopicResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicResources.
     */
    distinct?: TopicResourceScalarFieldEnum | TopicResourceScalarFieldEnum[]
  }

  /**
   * TopicResource findFirstOrThrow
   */
  export type TopicResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    /**
     * Filter, which TopicResource to fetch.
     */
    where?: TopicResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicResources to fetch.
     */
    orderBy?: TopicResourceOrderByWithRelationInput | TopicResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicResources.
     */
    cursor?: TopicResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicResources.
     */
    distinct?: TopicResourceScalarFieldEnum | TopicResourceScalarFieldEnum[]
  }

  /**
   * TopicResource findMany
   */
  export type TopicResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    /**
     * Filter, which TopicResources to fetch.
     */
    where?: TopicResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicResources to fetch.
     */
    orderBy?: TopicResourceOrderByWithRelationInput | TopicResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopicResources.
     */
    cursor?: TopicResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicResources.
     */
    skip?: number
    distinct?: TopicResourceScalarFieldEnum | TopicResourceScalarFieldEnum[]
  }

  /**
   * TopicResource create
   */
  export type TopicResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a TopicResource.
     */
    data: XOR<TopicResourceCreateInput, TopicResourceUncheckedCreateInput>
  }

  /**
   * TopicResource createMany
   */
  export type TopicResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TopicResources.
     */
    data: TopicResourceCreateManyInput | TopicResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TopicResource createManyAndReturn
   */
  export type TopicResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * The data used to create many TopicResources.
     */
    data: TopicResourceCreateManyInput | TopicResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TopicResource update
   */
  export type TopicResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a TopicResource.
     */
    data: XOR<TopicResourceUpdateInput, TopicResourceUncheckedUpdateInput>
    /**
     * Choose, which TopicResource to update.
     */
    where: TopicResourceWhereUniqueInput
  }

  /**
   * TopicResource updateMany
   */
  export type TopicResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TopicResources.
     */
    data: XOR<TopicResourceUpdateManyMutationInput, TopicResourceUncheckedUpdateManyInput>
    /**
     * Filter which TopicResources to update
     */
    where?: TopicResourceWhereInput
    /**
     * Limit how many TopicResources to update.
     */
    limit?: number
  }

  /**
   * TopicResource updateManyAndReturn
   */
  export type TopicResourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * The data used to update TopicResources.
     */
    data: XOR<TopicResourceUpdateManyMutationInput, TopicResourceUncheckedUpdateManyInput>
    /**
     * Filter which TopicResources to update
     */
    where?: TopicResourceWhereInput
    /**
     * Limit how many TopicResources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TopicResource upsert
   */
  export type TopicResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the TopicResource to update in case it exists.
     */
    where: TopicResourceWhereUniqueInput
    /**
     * In case the TopicResource found by the `where` argument doesn't exist, create a new TopicResource with this data.
     */
    create: XOR<TopicResourceCreateInput, TopicResourceUncheckedCreateInput>
    /**
     * In case the TopicResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicResourceUpdateInput, TopicResourceUncheckedUpdateInput>
  }

  /**
   * TopicResource delete
   */
  export type TopicResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
    /**
     * Filter which TopicResource to delete.
     */
    where: TopicResourceWhereUniqueInput
  }

  /**
   * TopicResource deleteMany
   */
  export type TopicResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicResources to delete
     */
    where?: TopicResourceWhereInput
    /**
     * Limit how many TopicResources to delete.
     */
    limit?: number
  }

  /**
   * TopicResource without action
   */
  export type TopicResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicResource
     */
    select?: TopicResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicResource
     */
    omit?: TopicResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicResourceInclude<ExtArgs> | null
  }


  /**
   * Model QuestionPool
   */

  export type AggregateQuestionPool = {
    _count: QuestionPoolCountAggregateOutputType | null
    _avg: QuestionPoolAvgAggregateOutputType | null
    _sum: QuestionPoolSumAggregateOutputType | null
    _min: QuestionPoolMinAggregateOutputType | null
    _max: QuestionPoolMaxAggregateOutputType | null
  }

  export type QuestionPoolAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    timeLimitSec: number | null
    points: number | null
  }

  export type QuestionPoolSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    timeLimitSec: number | null
    points: number | null
  }

  export type QuestionPoolMinAggregateOutputType = {
    id: number | null
    authorId: number | null
    questionText: string | null
    questionType: $Enums.QuestionType | null
    explanation: string | null
    timeLimitSec: number | null
    points: number | null
    option1: string | null
    option2: string | null
    option3: string | null
    option4: string | null
    option5: string | null
    option6: string | null
    answer: string | null
    createdAt: Date | null
  }

  export type QuestionPoolMaxAggregateOutputType = {
    id: number | null
    authorId: number | null
    questionText: string | null
    questionType: $Enums.QuestionType | null
    explanation: string | null
    timeLimitSec: number | null
    points: number | null
    option1: string | null
    option2: string | null
    option3: string | null
    option4: string | null
    option5: string | null
    option6: string | null
    answer: string | null
    createdAt: Date | null
  }

  export type QuestionPoolCountAggregateOutputType = {
    id: number
    authorId: number
    questionText: number
    questionType: number
    metadata: number
    explanation: number
    timeLimitSec: number
    points: number
    option1: number
    option2: number
    option3: number
    option4: number
    option5: number
    option6: number
    answer: number
    createdAt: number
    _all: number
  }


  export type QuestionPoolAvgAggregateInputType = {
    id?: true
    authorId?: true
    timeLimitSec?: true
    points?: true
  }

  export type QuestionPoolSumAggregateInputType = {
    id?: true
    authorId?: true
    timeLimitSec?: true
    points?: true
  }

  export type QuestionPoolMinAggregateInputType = {
    id?: true
    authorId?: true
    questionText?: true
    questionType?: true
    explanation?: true
    timeLimitSec?: true
    points?: true
    option1?: true
    option2?: true
    option3?: true
    option4?: true
    option5?: true
    option6?: true
    answer?: true
    createdAt?: true
  }

  export type QuestionPoolMaxAggregateInputType = {
    id?: true
    authorId?: true
    questionText?: true
    questionType?: true
    explanation?: true
    timeLimitSec?: true
    points?: true
    option1?: true
    option2?: true
    option3?: true
    option4?: true
    option5?: true
    option6?: true
    answer?: true
    createdAt?: true
  }

  export type QuestionPoolCountAggregateInputType = {
    id?: true
    authorId?: true
    questionText?: true
    questionType?: true
    metadata?: true
    explanation?: true
    timeLimitSec?: true
    points?: true
    option1?: true
    option2?: true
    option3?: true
    option4?: true
    option5?: true
    option6?: true
    answer?: true
    createdAt?: true
    _all?: true
  }

  export type QuestionPoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionPool to aggregate.
     */
    where?: QuestionPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionPools to fetch.
     */
    orderBy?: QuestionPoolOrderByWithRelationInput | QuestionPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionPools
    **/
    _count?: true | QuestionPoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionPoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionPoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionPoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionPoolMaxAggregateInputType
  }

  export type GetQuestionPoolAggregateType<T extends QuestionPoolAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionPool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionPool[P]>
      : GetScalarType<T[P], AggregateQuestionPool[P]>
  }




  export type QuestionPoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionPoolWhereInput
    orderBy?: QuestionPoolOrderByWithAggregationInput | QuestionPoolOrderByWithAggregationInput[]
    by: QuestionPoolScalarFieldEnum[] | QuestionPoolScalarFieldEnum
    having?: QuestionPoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionPoolCountAggregateInputType | true
    _avg?: QuestionPoolAvgAggregateInputType
    _sum?: QuestionPoolSumAggregateInputType
    _min?: QuestionPoolMinAggregateInputType
    _max?: QuestionPoolMaxAggregateInputType
  }

  export type QuestionPoolGroupByOutputType = {
    id: number
    authorId: number
    questionText: string
    questionType: $Enums.QuestionType
    metadata: JsonValue | null
    explanation: string | null
    timeLimitSec: number | null
    points: number
    option1: string | null
    option2: string | null
    option3: string | null
    option4: string | null
    option5: string | null
    option6: string | null
    answer: string | null
    createdAt: Date
    _count: QuestionPoolCountAggregateOutputType | null
    _avg: QuestionPoolAvgAggregateOutputType | null
    _sum: QuestionPoolSumAggregateOutputType | null
    _min: QuestionPoolMinAggregateOutputType | null
    _max: QuestionPoolMaxAggregateOutputType | null
  }

  type GetQuestionPoolGroupByPayload<T extends QuestionPoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionPoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionPoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionPoolGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionPoolGroupByOutputType[P]>
        }
      >
    >


  export type QuestionPoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    questionText?: boolean
    questionType?: boolean
    metadata?: boolean
    explanation?: boolean
    timeLimitSec?: boolean
    points?: boolean
    option1?: boolean
    option2?: boolean
    option3?: boolean
    option4?: boolean
    option5?: boolean
    option6?: boolean
    answer?: boolean
    createdAt?: boolean
    author?: boolean | AdminDefaultArgs<ExtArgs>
    quizPaperQuestions?: boolean | QuestionPool$quizPaperQuestionsArgs<ExtArgs>
    questionAttempts?: boolean | QuestionPool$questionAttemptsArgs<ExtArgs>
    _count?: boolean | QuestionPoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionPool"]>

  export type QuestionPoolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    questionText?: boolean
    questionType?: boolean
    metadata?: boolean
    explanation?: boolean
    timeLimitSec?: boolean
    points?: boolean
    option1?: boolean
    option2?: boolean
    option3?: boolean
    option4?: boolean
    option5?: boolean
    option6?: boolean
    answer?: boolean
    createdAt?: boolean
    author?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionPool"]>

  export type QuestionPoolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    questionText?: boolean
    questionType?: boolean
    metadata?: boolean
    explanation?: boolean
    timeLimitSec?: boolean
    points?: boolean
    option1?: boolean
    option2?: boolean
    option3?: boolean
    option4?: boolean
    option5?: boolean
    option6?: boolean
    answer?: boolean
    createdAt?: boolean
    author?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionPool"]>

  export type QuestionPoolSelectScalar = {
    id?: boolean
    authorId?: boolean
    questionText?: boolean
    questionType?: boolean
    metadata?: boolean
    explanation?: boolean
    timeLimitSec?: boolean
    points?: boolean
    option1?: boolean
    option2?: boolean
    option3?: boolean
    option4?: boolean
    option5?: boolean
    option6?: boolean
    answer?: boolean
    createdAt?: boolean
  }

  export type QuestionPoolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authorId" | "questionText" | "questionType" | "metadata" | "explanation" | "timeLimitSec" | "points" | "option1" | "option2" | "option3" | "option4" | "option5" | "option6" | "answer" | "createdAt", ExtArgs["result"]["questionPool"]>
  export type QuestionPoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AdminDefaultArgs<ExtArgs>
    quizPaperQuestions?: boolean | QuestionPool$quizPaperQuestionsArgs<ExtArgs>
    questionAttempts?: boolean | QuestionPool$questionAttemptsArgs<ExtArgs>
    _count?: boolean | QuestionPoolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionPoolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type QuestionPoolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $QuestionPoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionPool"
    objects: {
      author: Prisma.$AdminPayload<ExtArgs>
      quizPaperQuestions: Prisma.$QuizPaperQuestionPayload<ExtArgs>[]
      questionAttempts: Prisma.$QuestionAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      authorId: number
      questionText: string
      questionType: $Enums.QuestionType
      metadata: Prisma.JsonValue | null
      explanation: string | null
      timeLimitSec: number | null
      points: number
      option1: string | null
      option2: string | null
      option3: string | null
      option4: string | null
      option5: string | null
      option6: string | null
      answer: string | null
      createdAt: Date
    }, ExtArgs["result"]["questionPool"]>
    composites: {}
  }

  type QuestionPoolGetPayload<S extends boolean | null | undefined | QuestionPoolDefaultArgs> = $Result.GetResult<Prisma.$QuestionPoolPayload, S>

  type QuestionPoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionPoolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionPoolCountAggregateInputType | true
    }

  export interface QuestionPoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionPool'], meta: { name: 'QuestionPool' } }
    /**
     * Find zero or one QuestionPool that matches the filter.
     * @param {QuestionPoolFindUniqueArgs} args - Arguments to find a QuestionPool
     * @example
     * // Get one QuestionPool
     * const questionPool = await prisma.questionPool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionPoolFindUniqueArgs>(args: SelectSubset<T, QuestionPoolFindUniqueArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionPool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionPoolFindUniqueOrThrowArgs} args - Arguments to find a QuestionPool
     * @example
     * // Get one QuestionPool
     * const questionPool = await prisma.questionPool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionPoolFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionPoolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionPool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPoolFindFirstArgs} args - Arguments to find a QuestionPool
     * @example
     * // Get one QuestionPool
     * const questionPool = await prisma.questionPool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionPoolFindFirstArgs>(args?: SelectSubset<T, QuestionPoolFindFirstArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionPool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPoolFindFirstOrThrowArgs} args - Arguments to find a QuestionPool
     * @example
     * // Get one QuestionPool
     * const questionPool = await prisma.questionPool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionPoolFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionPoolFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionPools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPoolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionPools
     * const questionPools = await prisma.questionPool.findMany()
     * 
     * // Get first 10 QuestionPools
     * const questionPools = await prisma.questionPool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionPoolWithIdOnly = await prisma.questionPool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionPoolFindManyArgs>(args?: SelectSubset<T, QuestionPoolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionPool.
     * @param {QuestionPoolCreateArgs} args - Arguments to create a QuestionPool.
     * @example
     * // Create one QuestionPool
     * const QuestionPool = await prisma.questionPool.create({
     *   data: {
     *     // ... data to create a QuestionPool
     *   }
     * })
     * 
     */
    create<T extends QuestionPoolCreateArgs>(args: SelectSubset<T, QuestionPoolCreateArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionPools.
     * @param {QuestionPoolCreateManyArgs} args - Arguments to create many QuestionPools.
     * @example
     * // Create many QuestionPools
     * const questionPool = await prisma.questionPool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionPoolCreateManyArgs>(args?: SelectSubset<T, QuestionPoolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionPools and returns the data saved in the database.
     * @param {QuestionPoolCreateManyAndReturnArgs} args - Arguments to create many QuestionPools.
     * @example
     * // Create many QuestionPools
     * const questionPool = await prisma.questionPool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionPools and only return the `id`
     * const questionPoolWithIdOnly = await prisma.questionPool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionPoolCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionPoolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionPool.
     * @param {QuestionPoolDeleteArgs} args - Arguments to delete one QuestionPool.
     * @example
     * // Delete one QuestionPool
     * const QuestionPool = await prisma.questionPool.delete({
     *   where: {
     *     // ... filter to delete one QuestionPool
     *   }
     * })
     * 
     */
    delete<T extends QuestionPoolDeleteArgs>(args: SelectSubset<T, QuestionPoolDeleteArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionPool.
     * @param {QuestionPoolUpdateArgs} args - Arguments to update one QuestionPool.
     * @example
     * // Update one QuestionPool
     * const questionPool = await prisma.questionPool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionPoolUpdateArgs>(args: SelectSubset<T, QuestionPoolUpdateArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionPools.
     * @param {QuestionPoolDeleteManyArgs} args - Arguments to filter QuestionPools to delete.
     * @example
     * // Delete a few QuestionPools
     * const { count } = await prisma.questionPool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionPoolDeleteManyArgs>(args?: SelectSubset<T, QuestionPoolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionPools
     * const questionPool = await prisma.questionPool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionPoolUpdateManyArgs>(args: SelectSubset<T, QuestionPoolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionPools and returns the data updated in the database.
     * @param {QuestionPoolUpdateManyAndReturnArgs} args - Arguments to update many QuestionPools.
     * @example
     * // Update many QuestionPools
     * const questionPool = await prisma.questionPool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionPools and only return the `id`
     * const questionPoolWithIdOnly = await prisma.questionPool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionPoolUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionPoolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionPool.
     * @param {QuestionPoolUpsertArgs} args - Arguments to update or create a QuestionPool.
     * @example
     * // Update or create a QuestionPool
     * const questionPool = await prisma.questionPool.upsert({
     *   create: {
     *     // ... data to create a QuestionPool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionPool we want to update
     *   }
     * })
     */
    upsert<T extends QuestionPoolUpsertArgs>(args: SelectSubset<T, QuestionPoolUpsertArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionPools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPoolCountArgs} args - Arguments to filter QuestionPools to count.
     * @example
     * // Count the number of QuestionPools
     * const count = await prisma.questionPool.count({
     *   where: {
     *     // ... the filter for the QuestionPools we want to count
     *   }
     * })
    **/
    count<T extends QuestionPoolCountArgs>(
      args?: Subset<T, QuestionPoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionPoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionPoolAggregateArgs>(args: Subset<T, QuestionPoolAggregateArgs>): Prisma.PrismaPromise<GetQuestionPoolAggregateType<T>>

    /**
     * Group by QuestionPool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionPoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionPoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionPoolGroupByArgs['orderBy'] }
        : { orderBy?: QuestionPoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionPoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionPoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionPool model
   */
  readonly fields: QuestionPoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionPool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionPoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quizPaperQuestions<T extends QuestionPool$quizPaperQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, QuestionPool$quizPaperQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questionAttempts<T extends QuestionPool$questionAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, QuestionPool$questionAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionPool model
   */
  interface QuestionPoolFieldRefs {
    readonly id: FieldRef<"QuestionPool", 'Int'>
    readonly authorId: FieldRef<"QuestionPool", 'Int'>
    readonly questionText: FieldRef<"QuestionPool", 'String'>
    readonly questionType: FieldRef<"QuestionPool", 'QuestionType'>
    readonly metadata: FieldRef<"QuestionPool", 'Json'>
    readonly explanation: FieldRef<"QuestionPool", 'String'>
    readonly timeLimitSec: FieldRef<"QuestionPool", 'Int'>
    readonly points: FieldRef<"QuestionPool", 'Int'>
    readonly option1: FieldRef<"QuestionPool", 'String'>
    readonly option2: FieldRef<"QuestionPool", 'String'>
    readonly option3: FieldRef<"QuestionPool", 'String'>
    readonly option4: FieldRef<"QuestionPool", 'String'>
    readonly option5: FieldRef<"QuestionPool", 'String'>
    readonly option6: FieldRef<"QuestionPool", 'String'>
    readonly answer: FieldRef<"QuestionPool", 'String'>
    readonly createdAt: FieldRef<"QuestionPool", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionPool findUnique
   */
  export type QuestionPoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPool to fetch.
     */
    where: QuestionPoolWhereUniqueInput
  }

  /**
   * QuestionPool findUniqueOrThrow
   */
  export type QuestionPoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPool to fetch.
     */
    where: QuestionPoolWhereUniqueInput
  }

  /**
   * QuestionPool findFirst
   */
  export type QuestionPoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPool to fetch.
     */
    where?: QuestionPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionPools to fetch.
     */
    orderBy?: QuestionPoolOrderByWithRelationInput | QuestionPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionPools.
     */
    cursor?: QuestionPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionPools.
     */
    distinct?: QuestionPoolScalarFieldEnum | QuestionPoolScalarFieldEnum[]
  }

  /**
   * QuestionPool findFirstOrThrow
   */
  export type QuestionPoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPool to fetch.
     */
    where?: QuestionPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionPools to fetch.
     */
    orderBy?: QuestionPoolOrderByWithRelationInput | QuestionPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionPools.
     */
    cursor?: QuestionPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionPools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionPools.
     */
    distinct?: QuestionPoolScalarFieldEnum | QuestionPoolScalarFieldEnum[]
  }

  /**
   * QuestionPool findMany
   */
  export type QuestionPoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    /**
     * Filter, which QuestionPools to fetch.
     */
    where?: QuestionPoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionPools to fetch.
     */
    orderBy?: QuestionPoolOrderByWithRelationInput | QuestionPoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionPools.
     */
    cursor?: QuestionPoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionPools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionPools.
     */
    skip?: number
    distinct?: QuestionPoolScalarFieldEnum | QuestionPoolScalarFieldEnum[]
  }

  /**
   * QuestionPool create
   */
  export type QuestionPoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionPool.
     */
    data: XOR<QuestionPoolCreateInput, QuestionPoolUncheckedCreateInput>
  }

  /**
   * QuestionPool createMany
   */
  export type QuestionPoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionPools.
     */
    data: QuestionPoolCreateManyInput | QuestionPoolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionPool createManyAndReturn
   */
  export type QuestionPoolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionPools.
     */
    data: QuestionPoolCreateManyInput | QuestionPoolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionPool update
   */
  export type QuestionPoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionPool.
     */
    data: XOR<QuestionPoolUpdateInput, QuestionPoolUncheckedUpdateInput>
    /**
     * Choose, which QuestionPool to update.
     */
    where: QuestionPoolWhereUniqueInput
  }

  /**
   * QuestionPool updateMany
   */
  export type QuestionPoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionPools.
     */
    data: XOR<QuestionPoolUpdateManyMutationInput, QuestionPoolUncheckedUpdateManyInput>
    /**
     * Filter which QuestionPools to update
     */
    where?: QuestionPoolWhereInput
    /**
     * Limit how many QuestionPools to update.
     */
    limit?: number
  }

  /**
   * QuestionPool updateManyAndReturn
   */
  export type QuestionPoolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * The data used to update QuestionPools.
     */
    data: XOR<QuestionPoolUpdateManyMutationInput, QuestionPoolUncheckedUpdateManyInput>
    /**
     * Filter which QuestionPools to update
     */
    where?: QuestionPoolWhereInput
    /**
     * Limit how many QuestionPools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionPool upsert
   */
  export type QuestionPoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionPool to update in case it exists.
     */
    where: QuestionPoolWhereUniqueInput
    /**
     * In case the QuestionPool found by the `where` argument doesn't exist, create a new QuestionPool with this data.
     */
    create: XOR<QuestionPoolCreateInput, QuestionPoolUncheckedCreateInput>
    /**
     * In case the QuestionPool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionPoolUpdateInput, QuestionPoolUncheckedUpdateInput>
  }

  /**
   * QuestionPool delete
   */
  export type QuestionPoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
    /**
     * Filter which QuestionPool to delete.
     */
    where: QuestionPoolWhereUniqueInput
  }

  /**
   * QuestionPool deleteMany
   */
  export type QuestionPoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionPools to delete
     */
    where?: QuestionPoolWhereInput
    /**
     * Limit how many QuestionPools to delete.
     */
    limit?: number
  }

  /**
   * QuestionPool.quizPaperQuestions
   */
  export type QuestionPool$quizPaperQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    where?: QuizPaperQuestionWhereInput
    orderBy?: QuizPaperQuestionOrderByWithRelationInput | QuizPaperQuestionOrderByWithRelationInput[]
    cursor?: QuizPaperQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizPaperQuestionScalarFieldEnum | QuizPaperQuestionScalarFieldEnum[]
  }

  /**
   * QuestionPool.questionAttempts
   */
  export type QuestionPool$questionAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    where?: QuestionAttemptWhereInput
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    cursor?: QuestionAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * QuestionPool without action
   */
  export type QuestionPoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionPool
     */
    select?: QuestionPoolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionPool
     */
    omit?: QuestionPoolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionPoolInclude<ExtArgs> | null
  }


  /**
   * Model QuizPaper
   */

  export type AggregateQuizPaper = {
    _count: QuizPaperCountAggregateOutputType | null
    _avg: QuizPaperAvgAggregateOutputType | null
    _sum: QuizPaperSumAggregateOutputType | null
    _min: QuizPaperMinAggregateOutputType | null
    _max: QuizPaperMaxAggregateOutputType | null
  }

  export type QuizPaperAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type QuizPaperSumAggregateOutputType = {
    id: number | null
    authorId: number | null
  }

  export type QuizPaperMinAggregateOutputType = {
    id: number | null
    authorId: number | null
    title: string | null
    createdAt: Date | null
  }

  export type QuizPaperMaxAggregateOutputType = {
    id: number | null
    authorId: number | null
    title: string | null
    createdAt: Date | null
  }

  export type QuizPaperCountAggregateOutputType = {
    id: number
    authorId: number
    title: number
    createdAt: number
    _all: number
  }


  export type QuizPaperAvgAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type QuizPaperSumAggregateInputType = {
    id?: true
    authorId?: true
  }

  export type QuizPaperMinAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    createdAt?: true
  }

  export type QuizPaperMaxAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    createdAt?: true
  }

  export type QuizPaperCountAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    createdAt?: true
    _all?: true
  }

  export type QuizPaperAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizPaper to aggregate.
     */
    where?: QuizPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizPapers to fetch.
     */
    orderBy?: QuizPaperOrderByWithRelationInput | QuizPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizPapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizPapers
    **/
    _count?: true | QuizPaperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizPaperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizPaperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizPaperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizPaperMaxAggregateInputType
  }

  export type GetQuizPaperAggregateType<T extends QuizPaperAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizPaper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizPaper[P]>
      : GetScalarType<T[P], AggregateQuizPaper[P]>
  }




  export type QuizPaperGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizPaperWhereInput
    orderBy?: QuizPaperOrderByWithAggregationInput | QuizPaperOrderByWithAggregationInput[]
    by: QuizPaperScalarFieldEnum[] | QuizPaperScalarFieldEnum
    having?: QuizPaperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizPaperCountAggregateInputType | true
    _avg?: QuizPaperAvgAggregateInputType
    _sum?: QuizPaperSumAggregateInputType
    _min?: QuizPaperMinAggregateInputType
    _max?: QuizPaperMaxAggregateInputType
  }

  export type QuizPaperGroupByOutputType = {
    id: number
    authorId: number
    title: string
    createdAt: Date
    _count: QuizPaperCountAggregateOutputType | null
    _avg: QuizPaperAvgAggregateOutputType | null
    _sum: QuizPaperSumAggregateOutputType | null
    _min: QuizPaperMinAggregateOutputType | null
    _max: QuizPaperMaxAggregateOutputType | null
  }

  type GetQuizPaperGroupByPayload<T extends QuizPaperGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizPaperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizPaperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizPaperGroupByOutputType[P]>
            : GetScalarType<T[P], QuizPaperGroupByOutputType[P]>
        }
      >
    >


  export type QuizPaperSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    title?: boolean
    createdAt?: boolean
    author?: boolean | AdminDefaultArgs<ExtArgs>
    questions?: boolean | QuizPaper$questionsArgs<ExtArgs>
    assignments?: boolean | QuizPaper$assignmentsArgs<ExtArgs>
    _count?: boolean | QuizPaperCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizPaper"]>

  export type QuizPaperSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    title?: boolean
    createdAt?: boolean
    author?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizPaper"]>

  export type QuizPaperSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    title?: boolean
    createdAt?: boolean
    author?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizPaper"]>

  export type QuizPaperSelectScalar = {
    id?: boolean
    authorId?: boolean
    title?: boolean
    createdAt?: boolean
  }

  export type QuizPaperOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authorId" | "title" | "createdAt", ExtArgs["result"]["quizPaper"]>
  export type QuizPaperInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AdminDefaultArgs<ExtArgs>
    questions?: boolean | QuizPaper$questionsArgs<ExtArgs>
    assignments?: boolean | QuizPaper$assignmentsArgs<ExtArgs>
    _count?: boolean | QuizPaperCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizPaperIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type QuizPaperIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $QuizPaperPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizPaper"
    objects: {
      author: Prisma.$AdminPayload<ExtArgs>
      questions: Prisma.$QuizPaperQuestionPayload<ExtArgs>[]
      assignments: Prisma.$QuizAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      authorId: number
      title: string
      createdAt: Date
    }, ExtArgs["result"]["quizPaper"]>
    composites: {}
  }

  type QuizPaperGetPayload<S extends boolean | null | undefined | QuizPaperDefaultArgs> = $Result.GetResult<Prisma.$QuizPaperPayload, S>

  type QuizPaperCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizPaperFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizPaperCountAggregateInputType | true
    }

  export interface QuizPaperDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizPaper'], meta: { name: 'QuizPaper' } }
    /**
     * Find zero or one QuizPaper that matches the filter.
     * @param {QuizPaperFindUniqueArgs} args - Arguments to find a QuizPaper
     * @example
     * // Get one QuizPaper
     * const quizPaper = await prisma.quizPaper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizPaperFindUniqueArgs>(args: SelectSubset<T, QuizPaperFindUniqueArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizPaper that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizPaperFindUniqueOrThrowArgs} args - Arguments to find a QuizPaper
     * @example
     * // Get one QuizPaper
     * const quizPaper = await prisma.quizPaper.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizPaperFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizPaperFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizPaper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperFindFirstArgs} args - Arguments to find a QuizPaper
     * @example
     * // Get one QuizPaper
     * const quizPaper = await prisma.quizPaper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizPaperFindFirstArgs>(args?: SelectSubset<T, QuizPaperFindFirstArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizPaper that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperFindFirstOrThrowArgs} args - Arguments to find a QuizPaper
     * @example
     * // Get one QuizPaper
     * const quizPaper = await prisma.quizPaper.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizPaperFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizPaperFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizPapers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizPapers
     * const quizPapers = await prisma.quizPaper.findMany()
     * 
     * // Get first 10 QuizPapers
     * const quizPapers = await prisma.quizPaper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizPaperWithIdOnly = await prisma.quizPaper.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizPaperFindManyArgs>(args?: SelectSubset<T, QuizPaperFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizPaper.
     * @param {QuizPaperCreateArgs} args - Arguments to create a QuizPaper.
     * @example
     * // Create one QuizPaper
     * const QuizPaper = await prisma.quizPaper.create({
     *   data: {
     *     // ... data to create a QuizPaper
     *   }
     * })
     * 
     */
    create<T extends QuizPaperCreateArgs>(args: SelectSubset<T, QuizPaperCreateArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizPapers.
     * @param {QuizPaperCreateManyArgs} args - Arguments to create many QuizPapers.
     * @example
     * // Create many QuizPapers
     * const quizPaper = await prisma.quizPaper.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizPaperCreateManyArgs>(args?: SelectSubset<T, QuizPaperCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizPapers and returns the data saved in the database.
     * @param {QuizPaperCreateManyAndReturnArgs} args - Arguments to create many QuizPapers.
     * @example
     * // Create many QuizPapers
     * const quizPaper = await prisma.quizPaper.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizPapers and only return the `id`
     * const quizPaperWithIdOnly = await prisma.quizPaper.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizPaperCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizPaperCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizPaper.
     * @param {QuizPaperDeleteArgs} args - Arguments to delete one QuizPaper.
     * @example
     * // Delete one QuizPaper
     * const QuizPaper = await prisma.quizPaper.delete({
     *   where: {
     *     // ... filter to delete one QuizPaper
     *   }
     * })
     * 
     */
    delete<T extends QuizPaperDeleteArgs>(args: SelectSubset<T, QuizPaperDeleteArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizPaper.
     * @param {QuizPaperUpdateArgs} args - Arguments to update one QuizPaper.
     * @example
     * // Update one QuizPaper
     * const quizPaper = await prisma.quizPaper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizPaperUpdateArgs>(args: SelectSubset<T, QuizPaperUpdateArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizPapers.
     * @param {QuizPaperDeleteManyArgs} args - Arguments to filter QuizPapers to delete.
     * @example
     * // Delete a few QuizPapers
     * const { count } = await prisma.quizPaper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizPaperDeleteManyArgs>(args?: SelectSubset<T, QuizPaperDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizPapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizPapers
     * const quizPaper = await prisma.quizPaper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizPaperUpdateManyArgs>(args: SelectSubset<T, QuizPaperUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizPapers and returns the data updated in the database.
     * @param {QuizPaperUpdateManyAndReturnArgs} args - Arguments to update many QuizPapers.
     * @example
     * // Update many QuizPapers
     * const quizPaper = await prisma.quizPaper.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizPapers and only return the `id`
     * const quizPaperWithIdOnly = await prisma.quizPaper.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizPaperUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizPaperUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizPaper.
     * @param {QuizPaperUpsertArgs} args - Arguments to update or create a QuizPaper.
     * @example
     * // Update or create a QuizPaper
     * const quizPaper = await prisma.quizPaper.upsert({
     *   create: {
     *     // ... data to create a QuizPaper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizPaper we want to update
     *   }
     * })
     */
    upsert<T extends QuizPaperUpsertArgs>(args: SelectSubset<T, QuizPaperUpsertArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizPapers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperCountArgs} args - Arguments to filter QuizPapers to count.
     * @example
     * // Count the number of QuizPapers
     * const count = await prisma.quizPaper.count({
     *   where: {
     *     // ... the filter for the QuizPapers we want to count
     *   }
     * })
    **/
    count<T extends QuizPaperCountArgs>(
      args?: Subset<T, QuizPaperCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizPaperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizPaper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizPaperAggregateArgs>(args: Subset<T, QuizPaperAggregateArgs>): Prisma.PrismaPromise<GetQuizPaperAggregateType<T>>

    /**
     * Group by QuizPaper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizPaperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizPaperGroupByArgs['orderBy'] }
        : { orderBy?: QuizPaperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizPaperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizPaperGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizPaper model
   */
  readonly fields: QuizPaperFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizPaper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizPaperClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends QuizPaper$questionsArgs<ExtArgs> = {}>(args?: Subset<T, QuizPaper$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignments<T extends QuizPaper$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, QuizPaper$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizPaper model
   */
  interface QuizPaperFieldRefs {
    readonly id: FieldRef<"QuizPaper", 'Int'>
    readonly authorId: FieldRef<"QuizPaper", 'Int'>
    readonly title: FieldRef<"QuizPaper", 'String'>
    readonly createdAt: FieldRef<"QuizPaper", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizPaper findUnique
   */
  export type QuizPaperFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuizPaper to fetch.
     */
    where: QuizPaperWhereUniqueInput
  }

  /**
   * QuizPaper findUniqueOrThrow
   */
  export type QuizPaperFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuizPaper to fetch.
     */
    where: QuizPaperWhereUniqueInput
  }

  /**
   * QuizPaper findFirst
   */
  export type QuizPaperFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuizPaper to fetch.
     */
    where?: QuizPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizPapers to fetch.
     */
    orderBy?: QuizPaperOrderByWithRelationInput | QuizPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizPapers.
     */
    cursor?: QuizPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizPapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizPapers.
     */
    distinct?: QuizPaperScalarFieldEnum | QuizPaperScalarFieldEnum[]
  }

  /**
   * QuizPaper findFirstOrThrow
   */
  export type QuizPaperFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuizPaper to fetch.
     */
    where?: QuizPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizPapers to fetch.
     */
    orderBy?: QuizPaperOrderByWithRelationInput | QuizPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizPapers.
     */
    cursor?: QuizPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizPapers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizPapers.
     */
    distinct?: QuizPaperScalarFieldEnum | QuizPaperScalarFieldEnum[]
  }

  /**
   * QuizPaper findMany
   */
  export type QuizPaperFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    /**
     * Filter, which QuizPapers to fetch.
     */
    where?: QuizPaperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizPapers to fetch.
     */
    orderBy?: QuizPaperOrderByWithRelationInput | QuizPaperOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizPapers.
     */
    cursor?: QuizPaperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizPapers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizPapers.
     */
    skip?: number
    distinct?: QuizPaperScalarFieldEnum | QuizPaperScalarFieldEnum[]
  }

  /**
   * QuizPaper create
   */
  export type QuizPaperCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizPaper.
     */
    data: XOR<QuizPaperCreateInput, QuizPaperUncheckedCreateInput>
  }

  /**
   * QuizPaper createMany
   */
  export type QuizPaperCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizPapers.
     */
    data: QuizPaperCreateManyInput | QuizPaperCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizPaper createManyAndReturn
   */
  export type QuizPaperCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * The data used to create many QuizPapers.
     */
    data: QuizPaperCreateManyInput | QuizPaperCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizPaper update
   */
  export type QuizPaperUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizPaper.
     */
    data: XOR<QuizPaperUpdateInput, QuizPaperUncheckedUpdateInput>
    /**
     * Choose, which QuizPaper to update.
     */
    where: QuizPaperWhereUniqueInput
  }

  /**
   * QuizPaper updateMany
   */
  export type QuizPaperUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizPapers.
     */
    data: XOR<QuizPaperUpdateManyMutationInput, QuizPaperUncheckedUpdateManyInput>
    /**
     * Filter which QuizPapers to update
     */
    where?: QuizPaperWhereInput
    /**
     * Limit how many QuizPapers to update.
     */
    limit?: number
  }

  /**
   * QuizPaper updateManyAndReturn
   */
  export type QuizPaperUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * The data used to update QuizPapers.
     */
    data: XOR<QuizPaperUpdateManyMutationInput, QuizPaperUncheckedUpdateManyInput>
    /**
     * Filter which QuizPapers to update
     */
    where?: QuizPaperWhereInput
    /**
     * Limit how many QuizPapers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizPaper upsert
   */
  export type QuizPaperUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizPaper to update in case it exists.
     */
    where: QuizPaperWhereUniqueInput
    /**
     * In case the QuizPaper found by the `where` argument doesn't exist, create a new QuizPaper with this data.
     */
    create: XOR<QuizPaperCreateInput, QuizPaperUncheckedCreateInput>
    /**
     * In case the QuizPaper was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizPaperUpdateInput, QuizPaperUncheckedUpdateInput>
  }

  /**
   * QuizPaper delete
   */
  export type QuizPaperDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
    /**
     * Filter which QuizPaper to delete.
     */
    where: QuizPaperWhereUniqueInput
  }

  /**
   * QuizPaper deleteMany
   */
  export type QuizPaperDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizPapers to delete
     */
    where?: QuizPaperWhereInput
    /**
     * Limit how many QuizPapers to delete.
     */
    limit?: number
  }

  /**
   * QuizPaper.questions
   */
  export type QuizPaper$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    where?: QuizPaperQuestionWhereInput
    orderBy?: QuizPaperQuestionOrderByWithRelationInput | QuizPaperQuestionOrderByWithRelationInput[]
    cursor?: QuizPaperQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizPaperQuestionScalarFieldEnum | QuizPaperQuestionScalarFieldEnum[]
  }

  /**
   * QuizPaper.assignments
   */
  export type QuizPaper$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    where?: QuizAssignmentWhereInput
    orderBy?: QuizAssignmentOrderByWithRelationInput | QuizAssignmentOrderByWithRelationInput[]
    cursor?: QuizAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAssignmentScalarFieldEnum | QuizAssignmentScalarFieldEnum[]
  }

  /**
   * QuizPaper without action
   */
  export type QuizPaperDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaper
     */
    select?: QuizPaperSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaper
     */
    omit?: QuizPaperOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperInclude<ExtArgs> | null
  }


  /**
   * Model QuizPaperQuestion
   */

  export type AggregateQuizPaperQuestion = {
    _count: QuizPaperQuestionCountAggregateOutputType | null
    _avg: QuizPaperQuestionAvgAggregateOutputType | null
    _sum: QuizPaperQuestionSumAggregateOutputType | null
    _min: QuizPaperQuestionMinAggregateOutputType | null
    _max: QuizPaperQuestionMaxAggregateOutputType | null
  }

  export type QuizPaperQuestionAvgAggregateOutputType = {
    quizPaperId: number | null
    questionId: number | null
    position: number | null
    timeLimit: number | null
  }

  export type QuizPaperQuestionSumAggregateOutputType = {
    quizPaperId: number | null
    questionId: number | null
    position: number | null
    timeLimit: number | null
  }

  export type QuizPaperQuestionMinAggregateOutputType = {
    quizPaperId: number | null
    questionId: number | null
    position: number | null
    timeMode: boolean | null
    timeLimit: number | null
  }

  export type QuizPaperQuestionMaxAggregateOutputType = {
    quizPaperId: number | null
    questionId: number | null
    position: number | null
    timeMode: boolean | null
    timeLimit: number | null
  }

  export type QuizPaperQuestionCountAggregateOutputType = {
    quizPaperId: number
    questionId: number
    position: number
    timeMode: number
    timeLimit: number
    _all: number
  }


  export type QuizPaperQuestionAvgAggregateInputType = {
    quizPaperId?: true
    questionId?: true
    position?: true
    timeLimit?: true
  }

  export type QuizPaperQuestionSumAggregateInputType = {
    quizPaperId?: true
    questionId?: true
    position?: true
    timeLimit?: true
  }

  export type QuizPaperQuestionMinAggregateInputType = {
    quizPaperId?: true
    questionId?: true
    position?: true
    timeMode?: true
    timeLimit?: true
  }

  export type QuizPaperQuestionMaxAggregateInputType = {
    quizPaperId?: true
    questionId?: true
    position?: true
    timeMode?: true
    timeLimit?: true
  }

  export type QuizPaperQuestionCountAggregateInputType = {
    quizPaperId?: true
    questionId?: true
    position?: true
    timeMode?: true
    timeLimit?: true
    _all?: true
  }

  export type QuizPaperQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizPaperQuestion to aggregate.
     */
    where?: QuizPaperQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizPaperQuestions to fetch.
     */
    orderBy?: QuizPaperQuestionOrderByWithRelationInput | QuizPaperQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizPaperQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizPaperQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizPaperQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizPaperQuestions
    **/
    _count?: true | QuizPaperQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizPaperQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizPaperQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizPaperQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizPaperQuestionMaxAggregateInputType
  }

  export type GetQuizPaperQuestionAggregateType<T extends QuizPaperQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizPaperQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizPaperQuestion[P]>
      : GetScalarType<T[P], AggregateQuizPaperQuestion[P]>
  }




  export type QuizPaperQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizPaperQuestionWhereInput
    orderBy?: QuizPaperQuestionOrderByWithAggregationInput | QuizPaperQuestionOrderByWithAggregationInput[]
    by: QuizPaperQuestionScalarFieldEnum[] | QuizPaperQuestionScalarFieldEnum
    having?: QuizPaperQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizPaperQuestionCountAggregateInputType | true
    _avg?: QuizPaperQuestionAvgAggregateInputType
    _sum?: QuizPaperQuestionSumAggregateInputType
    _min?: QuizPaperQuestionMinAggregateInputType
    _max?: QuizPaperQuestionMaxAggregateInputType
  }

  export type QuizPaperQuestionGroupByOutputType = {
    quizPaperId: number
    questionId: number
    position: number | null
    timeMode: boolean
    timeLimit: number | null
    _count: QuizPaperQuestionCountAggregateOutputType | null
    _avg: QuizPaperQuestionAvgAggregateOutputType | null
    _sum: QuizPaperQuestionSumAggregateOutputType | null
    _min: QuizPaperQuestionMinAggregateOutputType | null
    _max: QuizPaperQuestionMaxAggregateOutputType | null
  }

  type GetQuizPaperQuestionGroupByPayload<T extends QuizPaperQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizPaperQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizPaperQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizPaperQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizPaperQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizPaperQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quizPaperId?: boolean
    questionId?: boolean
    position?: boolean
    timeMode?: boolean
    timeLimit?: boolean
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizPaperQuestion"]>

  export type QuizPaperQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quizPaperId?: boolean
    questionId?: boolean
    position?: boolean
    timeMode?: boolean
    timeLimit?: boolean
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizPaperQuestion"]>

  export type QuizPaperQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    quizPaperId?: boolean
    questionId?: boolean
    position?: boolean
    timeMode?: boolean
    timeLimit?: boolean
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizPaperQuestion"]>

  export type QuizPaperQuestionSelectScalar = {
    quizPaperId?: boolean
    questionId?: boolean
    position?: boolean
    timeMode?: boolean
    timeLimit?: boolean
  }

  export type QuizPaperQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"quizPaperId" | "questionId" | "position" | "timeMode" | "timeLimit", ExtArgs["result"]["quizPaperQuestion"]>
  export type QuizPaperQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }
  export type QuizPaperQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }
  export type QuizPaperQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }

  export type $QuizPaperQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizPaperQuestion"
    objects: {
      quizPaper: Prisma.$QuizPaperPayload<ExtArgs>
      question: Prisma.$QuestionPoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      quizPaperId: number
      questionId: number
      position: number | null
      timeMode: boolean
      timeLimit: number | null
    }, ExtArgs["result"]["quizPaperQuestion"]>
    composites: {}
  }

  type QuizPaperQuestionGetPayload<S extends boolean | null | undefined | QuizPaperQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizPaperQuestionPayload, S>

  type QuizPaperQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizPaperQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizPaperQuestionCountAggregateInputType | true
    }

  export interface QuizPaperQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizPaperQuestion'], meta: { name: 'QuizPaperQuestion' } }
    /**
     * Find zero or one QuizPaperQuestion that matches the filter.
     * @param {QuizPaperQuestionFindUniqueArgs} args - Arguments to find a QuizPaperQuestion
     * @example
     * // Get one QuizPaperQuestion
     * const quizPaperQuestion = await prisma.quizPaperQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizPaperQuestionFindUniqueArgs>(args: SelectSubset<T, QuizPaperQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizPaperQuestionClient<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizPaperQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizPaperQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizPaperQuestion
     * @example
     * // Get one QuizPaperQuestion
     * const quizPaperQuestion = await prisma.quizPaperQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizPaperQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizPaperQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizPaperQuestionClient<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizPaperQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperQuestionFindFirstArgs} args - Arguments to find a QuizPaperQuestion
     * @example
     * // Get one QuizPaperQuestion
     * const quizPaperQuestion = await prisma.quizPaperQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizPaperQuestionFindFirstArgs>(args?: SelectSubset<T, QuizPaperQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizPaperQuestionClient<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizPaperQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizPaperQuestion
     * @example
     * // Get one QuizPaperQuestion
     * const quizPaperQuestion = await prisma.quizPaperQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizPaperQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizPaperQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizPaperQuestionClient<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizPaperQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizPaperQuestions
     * const quizPaperQuestions = await prisma.quizPaperQuestion.findMany()
     * 
     * // Get first 10 QuizPaperQuestions
     * const quizPaperQuestions = await prisma.quizPaperQuestion.findMany({ take: 10 })
     * 
     * // Only select the `quizPaperId`
     * const quizPaperQuestionWithQuizPaperIdOnly = await prisma.quizPaperQuestion.findMany({ select: { quizPaperId: true } })
     * 
     */
    findMany<T extends QuizPaperQuestionFindManyArgs>(args?: SelectSubset<T, QuizPaperQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizPaperQuestion.
     * @param {QuizPaperQuestionCreateArgs} args - Arguments to create a QuizPaperQuestion.
     * @example
     * // Create one QuizPaperQuestion
     * const QuizPaperQuestion = await prisma.quizPaperQuestion.create({
     *   data: {
     *     // ... data to create a QuizPaperQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizPaperQuestionCreateArgs>(args: SelectSubset<T, QuizPaperQuestionCreateArgs<ExtArgs>>): Prisma__QuizPaperQuestionClient<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizPaperQuestions.
     * @param {QuizPaperQuestionCreateManyArgs} args - Arguments to create many QuizPaperQuestions.
     * @example
     * // Create many QuizPaperQuestions
     * const quizPaperQuestion = await prisma.quizPaperQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizPaperQuestionCreateManyArgs>(args?: SelectSubset<T, QuizPaperQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizPaperQuestions and returns the data saved in the database.
     * @param {QuizPaperQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizPaperQuestions.
     * @example
     * // Create many QuizPaperQuestions
     * const quizPaperQuestion = await prisma.quizPaperQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizPaperQuestions and only return the `quizPaperId`
     * const quizPaperQuestionWithQuizPaperIdOnly = await prisma.quizPaperQuestion.createManyAndReturn({
     *   select: { quizPaperId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizPaperQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizPaperQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizPaperQuestion.
     * @param {QuizPaperQuestionDeleteArgs} args - Arguments to delete one QuizPaperQuestion.
     * @example
     * // Delete one QuizPaperQuestion
     * const QuizPaperQuestion = await prisma.quizPaperQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizPaperQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizPaperQuestionDeleteArgs>(args: SelectSubset<T, QuizPaperQuestionDeleteArgs<ExtArgs>>): Prisma__QuizPaperQuestionClient<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizPaperQuestion.
     * @param {QuizPaperQuestionUpdateArgs} args - Arguments to update one QuizPaperQuestion.
     * @example
     * // Update one QuizPaperQuestion
     * const quizPaperQuestion = await prisma.quizPaperQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizPaperQuestionUpdateArgs>(args: SelectSubset<T, QuizPaperQuestionUpdateArgs<ExtArgs>>): Prisma__QuizPaperQuestionClient<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizPaperQuestions.
     * @param {QuizPaperQuestionDeleteManyArgs} args - Arguments to filter QuizPaperQuestions to delete.
     * @example
     * // Delete a few QuizPaperQuestions
     * const { count } = await prisma.quizPaperQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizPaperQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizPaperQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizPaperQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizPaperQuestions
     * const quizPaperQuestion = await prisma.quizPaperQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizPaperQuestionUpdateManyArgs>(args: SelectSubset<T, QuizPaperQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizPaperQuestions and returns the data updated in the database.
     * @param {QuizPaperQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizPaperQuestions.
     * @example
     * // Update many QuizPaperQuestions
     * const quizPaperQuestion = await prisma.quizPaperQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizPaperQuestions and only return the `quizPaperId`
     * const quizPaperQuestionWithQuizPaperIdOnly = await prisma.quizPaperQuestion.updateManyAndReturn({
     *   select: { quizPaperId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizPaperQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizPaperQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizPaperQuestion.
     * @param {QuizPaperQuestionUpsertArgs} args - Arguments to update or create a QuizPaperQuestion.
     * @example
     * // Update or create a QuizPaperQuestion
     * const quizPaperQuestion = await prisma.quizPaperQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizPaperQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizPaperQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizPaperQuestionUpsertArgs>(args: SelectSubset<T, QuizPaperQuestionUpsertArgs<ExtArgs>>): Prisma__QuizPaperQuestionClient<$Result.GetResult<Prisma.$QuizPaperQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizPaperQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperQuestionCountArgs} args - Arguments to filter QuizPaperQuestions to count.
     * @example
     * // Count the number of QuizPaperQuestions
     * const count = await prisma.quizPaperQuestion.count({
     *   where: {
     *     // ... the filter for the QuizPaperQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizPaperQuestionCountArgs>(
      args?: Subset<T, QuizPaperQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizPaperQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizPaperQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizPaperQuestionAggregateArgs>(args: Subset<T, QuizPaperQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizPaperQuestionAggregateType<T>>

    /**
     * Group by QuizPaperQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizPaperQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizPaperQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizPaperQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizPaperQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizPaperQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizPaperQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizPaperQuestion model
   */
  readonly fields: QuizPaperQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizPaperQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizPaperQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quizPaper<T extends QuizPaperDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizPaperDefaultArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuestionPoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionPoolDefaultArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizPaperQuestion model
   */
  interface QuizPaperQuestionFieldRefs {
    readonly quizPaperId: FieldRef<"QuizPaperQuestion", 'Int'>
    readonly questionId: FieldRef<"QuizPaperQuestion", 'Int'>
    readonly position: FieldRef<"QuizPaperQuestion", 'Int'>
    readonly timeMode: FieldRef<"QuizPaperQuestion", 'Boolean'>
    readonly timeLimit: FieldRef<"QuizPaperQuestion", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuizPaperQuestion findUnique
   */
  export type QuizPaperQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizPaperQuestion to fetch.
     */
    where: QuizPaperQuestionWhereUniqueInput
  }

  /**
   * QuizPaperQuestion findUniqueOrThrow
   */
  export type QuizPaperQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizPaperQuestion to fetch.
     */
    where: QuizPaperQuestionWhereUniqueInput
  }

  /**
   * QuizPaperQuestion findFirst
   */
  export type QuizPaperQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizPaperQuestion to fetch.
     */
    where?: QuizPaperQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizPaperQuestions to fetch.
     */
    orderBy?: QuizPaperQuestionOrderByWithRelationInput | QuizPaperQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizPaperQuestions.
     */
    cursor?: QuizPaperQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizPaperQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizPaperQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizPaperQuestions.
     */
    distinct?: QuizPaperQuestionScalarFieldEnum | QuizPaperQuestionScalarFieldEnum[]
  }

  /**
   * QuizPaperQuestion findFirstOrThrow
   */
  export type QuizPaperQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizPaperQuestion to fetch.
     */
    where?: QuizPaperQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizPaperQuestions to fetch.
     */
    orderBy?: QuizPaperQuestionOrderByWithRelationInput | QuizPaperQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizPaperQuestions.
     */
    cursor?: QuizPaperQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizPaperQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizPaperQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizPaperQuestions.
     */
    distinct?: QuizPaperQuestionScalarFieldEnum | QuizPaperQuestionScalarFieldEnum[]
  }

  /**
   * QuizPaperQuestion findMany
   */
  export type QuizPaperQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizPaperQuestions to fetch.
     */
    where?: QuizPaperQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizPaperQuestions to fetch.
     */
    orderBy?: QuizPaperQuestionOrderByWithRelationInput | QuizPaperQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizPaperQuestions.
     */
    cursor?: QuizPaperQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizPaperQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizPaperQuestions.
     */
    skip?: number
    distinct?: QuizPaperQuestionScalarFieldEnum | QuizPaperQuestionScalarFieldEnum[]
  }

  /**
   * QuizPaperQuestion create
   */
  export type QuizPaperQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizPaperQuestion.
     */
    data: XOR<QuizPaperQuestionCreateInput, QuizPaperQuestionUncheckedCreateInput>
  }

  /**
   * QuizPaperQuestion createMany
   */
  export type QuizPaperQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizPaperQuestions.
     */
    data: QuizPaperQuestionCreateManyInput | QuizPaperQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizPaperQuestion createManyAndReturn
   */
  export type QuizPaperQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizPaperQuestions.
     */
    data: QuizPaperQuestionCreateManyInput | QuizPaperQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizPaperQuestion update
   */
  export type QuizPaperQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizPaperQuestion.
     */
    data: XOR<QuizPaperQuestionUpdateInput, QuizPaperQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizPaperQuestion to update.
     */
    where: QuizPaperQuestionWhereUniqueInput
  }

  /**
   * QuizPaperQuestion updateMany
   */
  export type QuizPaperQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizPaperQuestions.
     */
    data: XOR<QuizPaperQuestionUpdateManyMutationInput, QuizPaperQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizPaperQuestions to update
     */
    where?: QuizPaperQuestionWhereInput
    /**
     * Limit how many QuizPaperQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizPaperQuestion updateManyAndReturn
   */
  export type QuizPaperQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizPaperQuestions.
     */
    data: XOR<QuizPaperQuestionUpdateManyMutationInput, QuizPaperQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizPaperQuestions to update
     */
    where?: QuizPaperQuestionWhereInput
    /**
     * Limit how many QuizPaperQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizPaperQuestion upsert
   */
  export type QuizPaperQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizPaperQuestion to update in case it exists.
     */
    where: QuizPaperQuestionWhereUniqueInput
    /**
     * In case the QuizPaperQuestion found by the `where` argument doesn't exist, create a new QuizPaperQuestion with this data.
     */
    create: XOR<QuizPaperQuestionCreateInput, QuizPaperQuestionUncheckedCreateInput>
    /**
     * In case the QuizPaperQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizPaperQuestionUpdateInput, QuizPaperQuestionUncheckedUpdateInput>
  }

  /**
   * QuizPaperQuestion delete
   */
  export type QuizPaperQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizPaperQuestion to delete.
     */
    where: QuizPaperQuestionWhereUniqueInput
  }

  /**
   * QuizPaperQuestion deleteMany
   */
  export type QuizPaperQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizPaperQuestions to delete
     */
    where?: QuizPaperQuestionWhereInput
    /**
     * Limit how many QuizPaperQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizPaperQuestion without action
   */
  export type QuizPaperQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizPaperQuestion
     */
    select?: QuizPaperQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizPaperQuestion
     */
    omit?: QuizPaperQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizPaperQuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuizAssignment
   */

  export type AggregateQuizAssignment = {
    _count: QuizAssignmentCountAggregateOutputType | null
    _avg: QuizAssignmentAvgAggregateOutputType | null
    _sum: QuizAssignmentSumAggregateOutputType | null
    _min: QuizAssignmentMinAggregateOutputType | null
    _max: QuizAssignmentMaxAggregateOutputType | null
  }

  export type QuizAssignmentAvgAggregateOutputType = {
    id: number | null
    quizPaperId: number | null
    programId: number | null
    totalTimeLimit: number | null
    passingScore: number | null
  }

  export type QuizAssignmentSumAggregateOutputType = {
    id: number | null
    quizPaperId: number | null
    programId: number | null
    totalTimeLimit: number | null
    passingScore: number | null
  }

  export type QuizAssignmentMinAggregateOutputType = {
    id: number | null
    quizPaperId: number | null
    programId: number | null
    startAt: Date | null
    endAt: Date | null
    uniqueLinkToken: string | null
    timeMode: $Enums.TimeMode | null
    wrongAnsMode: $Enums.WrongAnswerMode | null
    resultMode: $Enums.ResultMode | null
    totalTimeLimit: number | null
    passingScore: number | null
    enabled: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type QuizAssignmentMaxAggregateOutputType = {
    id: number | null
    quizPaperId: number | null
    programId: number | null
    startAt: Date | null
    endAt: Date | null
    uniqueLinkToken: string | null
    timeMode: $Enums.TimeMode | null
    wrongAnsMode: $Enums.WrongAnswerMode | null
    resultMode: $Enums.ResultMode | null
    totalTimeLimit: number | null
    passingScore: number | null
    enabled: boolean | null
    isDeleted: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
  }

  export type QuizAssignmentCountAggregateOutputType = {
    id: number
    quizPaperId: number
    programId: number
    startAt: number
    endAt: number
    uniqueLinkToken: number
    timeMode: number
    wrongAnsMode: number
    resultMode: number
    totalTimeLimit: number
    passingScore: number
    enabled: number
    isDeleted: number
    deletedAt: number
    createdAt: number
    _all: number
  }


  export type QuizAssignmentAvgAggregateInputType = {
    id?: true
    quizPaperId?: true
    programId?: true
    totalTimeLimit?: true
    passingScore?: true
  }

  export type QuizAssignmentSumAggregateInputType = {
    id?: true
    quizPaperId?: true
    programId?: true
    totalTimeLimit?: true
    passingScore?: true
  }

  export type QuizAssignmentMinAggregateInputType = {
    id?: true
    quizPaperId?: true
    programId?: true
    startAt?: true
    endAt?: true
    uniqueLinkToken?: true
    timeMode?: true
    wrongAnsMode?: true
    resultMode?: true
    totalTimeLimit?: true
    passingScore?: true
    enabled?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
  }

  export type QuizAssignmentMaxAggregateInputType = {
    id?: true
    quizPaperId?: true
    programId?: true
    startAt?: true
    endAt?: true
    uniqueLinkToken?: true
    timeMode?: true
    wrongAnsMode?: true
    resultMode?: true
    totalTimeLimit?: true
    passingScore?: true
    enabled?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
  }

  export type QuizAssignmentCountAggregateInputType = {
    id?: true
    quizPaperId?: true
    programId?: true
    startAt?: true
    endAt?: true
    uniqueLinkToken?: true
    timeMode?: true
    wrongAnsMode?: true
    resultMode?: true
    totalTimeLimit?: true
    passingScore?: true
    enabled?: true
    isDeleted?: true
    deletedAt?: true
    createdAt?: true
    _all?: true
  }

  export type QuizAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAssignment to aggregate.
     */
    where?: QuizAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAssignments to fetch.
     */
    orderBy?: QuizAssignmentOrderByWithRelationInput | QuizAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAssignments
    **/
    _count?: true | QuizAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAssignmentMaxAggregateInputType
  }

  export type GetQuizAssignmentAggregateType<T extends QuizAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAssignment[P]>
      : GetScalarType<T[P], AggregateQuizAssignment[P]>
  }




  export type QuizAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAssignmentWhereInput
    orderBy?: QuizAssignmentOrderByWithAggregationInput | QuizAssignmentOrderByWithAggregationInput[]
    by: QuizAssignmentScalarFieldEnum[] | QuizAssignmentScalarFieldEnum
    having?: QuizAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAssignmentCountAggregateInputType | true
    _avg?: QuizAssignmentAvgAggregateInputType
    _sum?: QuizAssignmentSumAggregateInputType
    _min?: QuizAssignmentMinAggregateInputType
    _max?: QuizAssignmentMaxAggregateInputType
  }

  export type QuizAssignmentGroupByOutputType = {
    id: number
    quizPaperId: number
    programId: number | null
    startAt: Date | null
    endAt: Date | null
    uniqueLinkToken: string
    timeMode: $Enums.TimeMode
    wrongAnsMode: $Enums.WrongAnswerMode
    resultMode: $Enums.ResultMode
    totalTimeLimit: number | null
    passingScore: number | null
    enabled: boolean
    isDeleted: boolean
    deletedAt: Date | null
    createdAt: Date
    _count: QuizAssignmentCountAggregateOutputType | null
    _avg: QuizAssignmentAvgAggregateOutputType | null
    _sum: QuizAssignmentSumAggregateOutputType | null
    _min: QuizAssignmentMinAggregateOutputType | null
    _max: QuizAssignmentMaxAggregateOutputType | null
  }

  type GetQuizAssignmentGroupByPayload<T extends QuizAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type QuizAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizPaperId?: boolean
    programId?: boolean
    startAt?: boolean
    endAt?: boolean
    uniqueLinkToken?: boolean
    timeMode?: boolean
    wrongAnsMode?: boolean
    resultMode?: boolean
    totalTimeLimit?: boolean
    passingScore?: boolean
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    program?: boolean | QuizAssignment$programArgs<ExtArgs>
    quizAttempts?: boolean | QuizAssignment$quizAttemptsArgs<ExtArgs>
    _count?: boolean | QuizAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAssignment"]>

  export type QuizAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizPaperId?: boolean
    programId?: boolean
    startAt?: boolean
    endAt?: boolean
    uniqueLinkToken?: boolean
    timeMode?: boolean
    wrongAnsMode?: boolean
    resultMode?: boolean
    totalTimeLimit?: boolean
    passingScore?: boolean
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    program?: boolean | QuizAssignment$programArgs<ExtArgs>
  }, ExtArgs["result"]["quizAssignment"]>

  export type QuizAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizPaperId?: boolean
    programId?: boolean
    startAt?: boolean
    endAt?: boolean
    uniqueLinkToken?: boolean
    timeMode?: boolean
    wrongAnsMode?: boolean
    resultMode?: boolean
    totalTimeLimit?: boolean
    passingScore?: boolean
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    program?: boolean | QuizAssignment$programArgs<ExtArgs>
  }, ExtArgs["result"]["quizAssignment"]>

  export type QuizAssignmentSelectScalar = {
    id?: boolean
    quizPaperId?: boolean
    programId?: boolean
    startAt?: boolean
    endAt?: boolean
    uniqueLinkToken?: boolean
    timeMode?: boolean
    wrongAnsMode?: boolean
    resultMode?: boolean
    totalTimeLimit?: boolean
    passingScore?: boolean
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    createdAt?: boolean
  }

  export type QuizAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizPaperId" | "programId" | "startAt" | "endAt" | "uniqueLinkToken" | "timeMode" | "wrongAnsMode" | "resultMode" | "totalTimeLimit" | "passingScore" | "enabled" | "isDeleted" | "deletedAt" | "createdAt", ExtArgs["result"]["quizAssignment"]>
  export type QuizAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    program?: boolean | QuizAssignment$programArgs<ExtArgs>
    quizAttempts?: boolean | QuizAssignment$quizAttemptsArgs<ExtArgs>
    _count?: boolean | QuizAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    program?: boolean | QuizAssignment$programArgs<ExtArgs>
  }
  export type QuizAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizPaper?: boolean | QuizPaperDefaultArgs<ExtArgs>
    program?: boolean | QuizAssignment$programArgs<ExtArgs>
  }

  export type $QuizAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAssignment"
    objects: {
      quizPaper: Prisma.$QuizPaperPayload<ExtArgs>
      program: Prisma.$ProgramPayload<ExtArgs> | null
      quizAttempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quizPaperId: number
      programId: number | null
      startAt: Date | null
      endAt: Date | null
      uniqueLinkToken: string
      timeMode: $Enums.TimeMode
      wrongAnsMode: $Enums.WrongAnswerMode
      resultMode: $Enums.ResultMode
      totalTimeLimit: number | null
      passingScore: number | null
      enabled: boolean
      isDeleted: boolean
      deletedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["quizAssignment"]>
    composites: {}
  }

  type QuizAssignmentGetPayload<S extends boolean | null | undefined | QuizAssignmentDefaultArgs> = $Result.GetResult<Prisma.$QuizAssignmentPayload, S>

  type QuizAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAssignmentCountAggregateInputType | true
    }

  export interface QuizAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAssignment'], meta: { name: 'QuizAssignment' } }
    /**
     * Find zero or one QuizAssignment that matches the filter.
     * @param {QuizAssignmentFindUniqueArgs} args - Arguments to find a QuizAssignment
     * @example
     * // Get one QuizAssignment
     * const quizAssignment = await prisma.quizAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAssignmentFindUniqueArgs>(args: SelectSubset<T, QuizAssignmentFindUniqueArgs<ExtArgs>>): Prisma__QuizAssignmentClient<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAssignmentFindUniqueOrThrowArgs} args - Arguments to find a QuizAssignment
     * @example
     * // Get one QuizAssignment
     * const quizAssignment = await prisma.quizAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAssignmentClient<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAssignmentFindFirstArgs} args - Arguments to find a QuizAssignment
     * @example
     * // Get one QuizAssignment
     * const quizAssignment = await prisma.quizAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAssignmentFindFirstArgs>(args?: SelectSubset<T, QuizAssignmentFindFirstArgs<ExtArgs>>): Prisma__QuizAssignmentClient<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAssignmentFindFirstOrThrowArgs} args - Arguments to find a QuizAssignment
     * @example
     * // Get one QuizAssignment
     * const quizAssignment = await prisma.quizAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAssignmentClient<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAssignments
     * const quizAssignments = await prisma.quizAssignment.findMany()
     * 
     * // Get first 10 QuizAssignments
     * const quizAssignments = await prisma.quizAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAssignmentWithIdOnly = await prisma.quizAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAssignmentFindManyArgs>(args?: SelectSubset<T, QuizAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizAssignment.
     * @param {QuizAssignmentCreateArgs} args - Arguments to create a QuizAssignment.
     * @example
     * // Create one QuizAssignment
     * const QuizAssignment = await prisma.quizAssignment.create({
     *   data: {
     *     // ... data to create a QuizAssignment
     *   }
     * })
     * 
     */
    create<T extends QuizAssignmentCreateArgs>(args: SelectSubset<T, QuizAssignmentCreateArgs<ExtArgs>>): Prisma__QuizAssignmentClient<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizAssignments.
     * @param {QuizAssignmentCreateManyArgs} args - Arguments to create many QuizAssignments.
     * @example
     * // Create many QuizAssignments
     * const quizAssignment = await prisma.quizAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAssignmentCreateManyArgs>(args?: SelectSubset<T, QuizAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAssignments and returns the data saved in the database.
     * @param {QuizAssignmentCreateManyAndReturnArgs} args - Arguments to create many QuizAssignments.
     * @example
     * // Create many QuizAssignments
     * const quizAssignment = await prisma.quizAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAssignments and only return the `id`
     * const quizAssignmentWithIdOnly = await prisma.quizAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizAssignment.
     * @param {QuizAssignmentDeleteArgs} args - Arguments to delete one QuizAssignment.
     * @example
     * // Delete one QuizAssignment
     * const QuizAssignment = await prisma.quizAssignment.delete({
     *   where: {
     *     // ... filter to delete one QuizAssignment
     *   }
     * })
     * 
     */
    delete<T extends QuizAssignmentDeleteArgs>(args: SelectSubset<T, QuizAssignmentDeleteArgs<ExtArgs>>): Prisma__QuizAssignmentClient<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizAssignment.
     * @param {QuizAssignmentUpdateArgs} args - Arguments to update one QuizAssignment.
     * @example
     * // Update one QuizAssignment
     * const quizAssignment = await prisma.quizAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAssignmentUpdateArgs>(args: SelectSubset<T, QuizAssignmentUpdateArgs<ExtArgs>>): Prisma__QuizAssignmentClient<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizAssignments.
     * @param {QuizAssignmentDeleteManyArgs} args - Arguments to filter QuizAssignments to delete.
     * @example
     * // Delete a few QuizAssignments
     * const { count } = await prisma.quizAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAssignmentDeleteManyArgs>(args?: SelectSubset<T, QuizAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAssignments
     * const quizAssignment = await prisma.quizAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAssignmentUpdateManyArgs>(args: SelectSubset<T, QuizAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAssignments and returns the data updated in the database.
     * @param {QuizAssignmentUpdateManyAndReturnArgs} args - Arguments to update many QuizAssignments.
     * @example
     * // Update many QuizAssignments
     * const quizAssignment = await prisma.quizAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAssignments and only return the `id`
     * const quizAssignmentWithIdOnly = await prisma.quizAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizAssignment.
     * @param {QuizAssignmentUpsertArgs} args - Arguments to update or create a QuizAssignment.
     * @example
     * // Update or create a QuizAssignment
     * const quizAssignment = await prisma.quizAssignment.upsert({
     *   create: {
     *     // ... data to create a QuizAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAssignment we want to update
     *   }
     * })
     */
    upsert<T extends QuizAssignmentUpsertArgs>(args: SelectSubset<T, QuizAssignmentUpsertArgs<ExtArgs>>): Prisma__QuizAssignmentClient<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAssignmentCountArgs} args - Arguments to filter QuizAssignments to count.
     * @example
     * // Count the number of QuizAssignments
     * const count = await prisma.quizAssignment.count({
     *   where: {
     *     // ... the filter for the QuizAssignments we want to count
     *   }
     * })
    **/
    count<T extends QuizAssignmentCountArgs>(
      args?: Subset<T, QuizAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAssignmentAggregateArgs>(args: Subset<T, QuizAssignmentAggregateArgs>): Prisma.PrismaPromise<GetQuizAssignmentAggregateType<T>>

    /**
     * Group by QuizAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: QuizAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAssignment model
   */
  readonly fields: QuizAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quizPaper<T extends QuizPaperDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizPaperDefaultArgs<ExtArgs>>): Prisma__QuizPaperClient<$Result.GetResult<Prisma.$QuizPaperPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends QuizAssignment$programArgs<ExtArgs> = {}>(args?: Subset<T, QuizAssignment$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quizAttempts<T extends QuizAssignment$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, QuizAssignment$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAssignment model
   */
  interface QuizAssignmentFieldRefs {
    readonly id: FieldRef<"QuizAssignment", 'Int'>
    readonly quizPaperId: FieldRef<"QuizAssignment", 'Int'>
    readonly programId: FieldRef<"QuizAssignment", 'Int'>
    readonly startAt: FieldRef<"QuizAssignment", 'DateTime'>
    readonly endAt: FieldRef<"QuizAssignment", 'DateTime'>
    readonly uniqueLinkToken: FieldRef<"QuizAssignment", 'String'>
    readonly timeMode: FieldRef<"QuizAssignment", 'TimeMode'>
    readonly wrongAnsMode: FieldRef<"QuizAssignment", 'WrongAnswerMode'>
    readonly resultMode: FieldRef<"QuizAssignment", 'ResultMode'>
    readonly totalTimeLimit: FieldRef<"QuizAssignment", 'Int'>
    readonly passingScore: FieldRef<"QuizAssignment", 'Int'>
    readonly enabled: FieldRef<"QuizAssignment", 'Boolean'>
    readonly isDeleted: FieldRef<"QuizAssignment", 'Boolean'>
    readonly deletedAt: FieldRef<"QuizAssignment", 'DateTime'>
    readonly createdAt: FieldRef<"QuizAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizAssignment findUnique
   */
  export type QuizAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which QuizAssignment to fetch.
     */
    where: QuizAssignmentWhereUniqueInput
  }

  /**
   * QuizAssignment findUniqueOrThrow
   */
  export type QuizAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which QuizAssignment to fetch.
     */
    where: QuizAssignmentWhereUniqueInput
  }

  /**
   * QuizAssignment findFirst
   */
  export type QuizAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which QuizAssignment to fetch.
     */
    where?: QuizAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAssignments to fetch.
     */
    orderBy?: QuizAssignmentOrderByWithRelationInput | QuizAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAssignments.
     */
    cursor?: QuizAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAssignments.
     */
    distinct?: QuizAssignmentScalarFieldEnum | QuizAssignmentScalarFieldEnum[]
  }

  /**
   * QuizAssignment findFirstOrThrow
   */
  export type QuizAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which QuizAssignment to fetch.
     */
    where?: QuizAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAssignments to fetch.
     */
    orderBy?: QuizAssignmentOrderByWithRelationInput | QuizAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAssignments.
     */
    cursor?: QuizAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAssignments.
     */
    distinct?: QuizAssignmentScalarFieldEnum | QuizAssignmentScalarFieldEnum[]
  }

  /**
   * QuizAssignment findMany
   */
  export type QuizAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which QuizAssignments to fetch.
     */
    where?: QuizAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAssignments to fetch.
     */
    orderBy?: QuizAssignmentOrderByWithRelationInput | QuizAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAssignments.
     */
    cursor?: QuizAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAssignments.
     */
    skip?: number
    distinct?: QuizAssignmentScalarFieldEnum | QuizAssignmentScalarFieldEnum[]
  }

  /**
   * QuizAssignment create
   */
  export type QuizAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAssignment.
     */
    data: XOR<QuizAssignmentCreateInput, QuizAssignmentUncheckedCreateInput>
  }

  /**
   * QuizAssignment createMany
   */
  export type QuizAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAssignments.
     */
    data: QuizAssignmentCreateManyInput | QuizAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAssignment createManyAndReturn
   */
  export type QuizAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAssignments.
     */
    data: QuizAssignmentCreateManyInput | QuizAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAssignment update
   */
  export type QuizAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAssignment.
     */
    data: XOR<QuizAssignmentUpdateInput, QuizAssignmentUncheckedUpdateInput>
    /**
     * Choose, which QuizAssignment to update.
     */
    where: QuizAssignmentWhereUniqueInput
  }

  /**
   * QuizAssignment updateMany
   */
  export type QuizAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAssignments.
     */
    data: XOR<QuizAssignmentUpdateManyMutationInput, QuizAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which QuizAssignments to update
     */
    where?: QuizAssignmentWhereInput
    /**
     * Limit how many QuizAssignments to update.
     */
    limit?: number
  }

  /**
   * QuizAssignment updateManyAndReturn
   */
  export type QuizAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update QuizAssignments.
     */
    data: XOR<QuizAssignmentUpdateManyMutationInput, QuizAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which QuizAssignments to update
     */
    where?: QuizAssignmentWhereInput
    /**
     * Limit how many QuizAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAssignment upsert
   */
  export type QuizAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAssignment to update in case it exists.
     */
    where: QuizAssignmentWhereUniqueInput
    /**
     * In case the QuizAssignment found by the `where` argument doesn't exist, create a new QuizAssignment with this data.
     */
    create: XOR<QuizAssignmentCreateInput, QuizAssignmentUncheckedCreateInput>
    /**
     * In case the QuizAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAssignmentUpdateInput, QuizAssignmentUncheckedUpdateInput>
  }

  /**
   * QuizAssignment delete
   */
  export type QuizAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
    /**
     * Filter which QuizAssignment to delete.
     */
    where: QuizAssignmentWhereUniqueInput
  }

  /**
   * QuizAssignment deleteMany
   */
  export type QuizAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAssignments to delete
     */
    where?: QuizAssignmentWhereInput
    /**
     * Limit how many QuizAssignments to delete.
     */
    limit?: number
  }

  /**
   * QuizAssignment.program
   */
  export type QuizAssignment$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * QuizAssignment.quizAttempts
   */
  export type QuizAssignment$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAssignment without action
   */
  export type QuizAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAssignment
     */
    select?: QuizAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAssignment
     */
    omit?: QuizAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model QuizAttempt
   */

  export type AggregateQuizAttempt = {
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  export type QuizAttemptAvgAggregateOutputType = {
    id: number | null
    assignmentId: number | null
    learnerId: number | null
    totalTimeSpent: number | null
    score: Decimal | null
  }

  export type QuizAttemptSumAggregateOutputType = {
    id: number | null
    assignmentId: number | null
    learnerId: number | null
    totalTimeSpent: number | null
    score: Decimal | null
  }

  export type QuizAttemptMinAggregateOutputType = {
    id: number | null
    assignmentId: number | null
    learnerId: number | null
    startedAt: Date | null
    submittedAt: Date | null
    totalTimeSpent: number | null
    score: Decimal | null
    passed: boolean | null
    status: string | null
    createdAt: Date | null
  }

  export type QuizAttemptMaxAggregateOutputType = {
    id: number | null
    assignmentId: number | null
    learnerId: number | null
    startedAt: Date | null
    submittedAt: Date | null
    totalTimeSpent: number | null
    score: Decimal | null
    passed: boolean | null
    status: string | null
    createdAt: Date | null
  }

  export type QuizAttemptCountAggregateOutputType = {
    id: number
    assignmentId: number
    learnerId: number
    startedAt: number
    submittedAt: number
    totalTimeSpent: number
    score: number
    passed: number
    status: number
    createdAt: number
    _all: number
  }


  export type QuizAttemptAvgAggregateInputType = {
    id?: true
    assignmentId?: true
    learnerId?: true
    totalTimeSpent?: true
    score?: true
  }

  export type QuizAttemptSumAggregateInputType = {
    id?: true
    assignmentId?: true
    learnerId?: true
    totalTimeSpent?: true
    score?: true
  }

  export type QuizAttemptMinAggregateInputType = {
    id?: true
    assignmentId?: true
    learnerId?: true
    startedAt?: true
    submittedAt?: true
    totalTimeSpent?: true
    score?: true
    passed?: true
    status?: true
    createdAt?: true
  }

  export type QuizAttemptMaxAggregateInputType = {
    id?: true
    assignmentId?: true
    learnerId?: true
    startedAt?: true
    submittedAt?: true
    totalTimeSpent?: true
    score?: true
    passed?: true
    status?: true
    createdAt?: true
  }

  export type QuizAttemptCountAggregateInputType = {
    id?: true
    assignmentId?: true
    learnerId?: true
    startedAt?: true
    submittedAt?: true
    totalTimeSpent?: true
    score?: true
    passed?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type QuizAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempt to aggregate.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAttempts
    **/
    _count?: true | QuizAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type GetQuizAttemptAggregateType<T extends QuizAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAttempt[P]>
      : GetScalarType<T[P], AggregateQuizAttempt[P]>
  }




  export type QuizAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithAggregationInput | QuizAttemptOrderByWithAggregationInput[]
    by: QuizAttemptScalarFieldEnum[] | QuizAttemptScalarFieldEnum
    having?: QuizAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAttemptCountAggregateInputType | true
    _avg?: QuizAttemptAvgAggregateInputType
    _sum?: QuizAttemptSumAggregateInputType
    _min?: QuizAttemptMinAggregateInputType
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type QuizAttemptGroupByOutputType = {
    id: number
    assignmentId: number
    learnerId: number
    startedAt: Date
    submittedAt: Date | null
    totalTimeSpent: number | null
    score: Decimal | null
    passed: boolean | null
    status: string
    createdAt: Date
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  type GetQuizAttemptGroupByPayload<T extends QuizAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
        }
      >
    >


  export type QuizAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    learnerId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    totalTimeSpent?: boolean
    score?: boolean
    passed?: boolean
    status?: boolean
    createdAt?: boolean
    assignment?: boolean | QuizAssignmentDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    questionAttempts?: boolean | QuizAttempt$questionAttemptsArgs<ExtArgs>
    _count?: boolean | QuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    learnerId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    totalTimeSpent?: boolean
    score?: boolean
    passed?: boolean
    status?: boolean
    createdAt?: boolean
    assignment?: boolean | QuizAssignmentDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    learnerId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    totalTimeSpent?: boolean
    score?: boolean
    passed?: boolean
    status?: boolean
    createdAt?: boolean
    assignment?: boolean | QuizAssignmentDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectScalar = {
    id?: boolean
    assignmentId?: boolean
    learnerId?: boolean
    startedAt?: boolean
    submittedAt?: boolean
    totalTimeSpent?: boolean
    score?: boolean
    passed?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type QuizAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assignmentId" | "learnerId" | "startedAt" | "submittedAt" | "totalTimeSpent" | "score" | "passed" | "status" | "createdAt", ExtArgs["result"]["quizAttempt"]>
  export type QuizAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | QuizAssignmentDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    questionAttempts?: boolean | QuizAttempt$questionAttemptsArgs<ExtArgs>
    _count?: boolean | QuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | QuizAssignmentDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | QuizAssignmentDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }

  export type $QuizAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAttempt"
    objects: {
      assignment: Prisma.$QuizAssignmentPayload<ExtArgs>
      learner: Prisma.$LearnerPayload<ExtArgs>
      questionAttempts: Prisma.$QuestionAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      assignmentId: number
      learnerId: number
      startedAt: Date
      submittedAt: Date | null
      totalTimeSpent: number | null
      score: Prisma.Decimal | null
      passed: boolean | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["quizAttempt"]>
    composites: {}
  }

  type QuizAttemptGetPayload<S extends boolean | null | undefined | QuizAttemptDefaultArgs> = $Result.GetResult<Prisma.$QuizAttemptPayload, S>

  type QuizAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAttemptCountAggregateInputType | true
    }

  export interface QuizAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAttempt'], meta: { name: 'QuizAttempt' } }
    /**
     * Find zero or one QuizAttempt that matches the filter.
     * @param {QuizAttemptFindUniqueArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAttemptFindUniqueArgs>(args: SelectSubset<T, QuizAttemptFindUniqueArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAttemptFindUniqueOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAttemptFindFirstArgs>(args?: SelectSubset<T, QuizAttemptFindFirstArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany()
     * 
     * // Get first 10 QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAttemptFindManyArgs>(args?: SelectSubset<T, QuizAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizAttempt.
     * @param {QuizAttemptCreateArgs} args - Arguments to create a QuizAttempt.
     * @example
     * // Create one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.create({
     *   data: {
     *     // ... data to create a QuizAttempt
     *   }
     * })
     * 
     */
    create<T extends QuizAttemptCreateArgs>(args: SelectSubset<T, QuizAttemptCreateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizAttempts.
     * @param {QuizAttemptCreateManyArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAttemptCreateManyArgs>(args?: SelectSubset<T, QuizAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAttempts and returns the data saved in the database.
     * @param {QuizAttemptCreateManyAndReturnArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizAttempt.
     * @param {QuizAttemptDeleteArgs} args - Arguments to delete one QuizAttempt.
     * @example
     * // Delete one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.delete({
     *   where: {
     *     // ... filter to delete one QuizAttempt
     *   }
     * })
     * 
     */
    delete<T extends QuizAttemptDeleteArgs>(args: SelectSubset<T, QuizAttemptDeleteArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizAttempt.
     * @param {QuizAttemptUpdateArgs} args - Arguments to update one QuizAttempt.
     * @example
     * // Update one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAttemptUpdateArgs>(args: SelectSubset<T, QuizAttemptUpdateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizAttempts.
     * @param {QuizAttemptDeleteManyArgs} args - Arguments to filter QuizAttempts to delete.
     * @example
     * // Delete a few QuizAttempts
     * const { count } = await prisma.quizAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAttemptDeleteManyArgs>(args?: SelectSubset<T, QuizAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAttemptUpdateManyArgs>(args: SelectSubset<T, QuizAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts and returns the data updated in the database.
     * @param {QuizAttemptUpdateManyAndReturnArgs} args - Arguments to update many QuizAttempts.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizAttempt.
     * @param {QuizAttemptUpsertArgs} args - Arguments to update or create a QuizAttempt.
     * @example
     * // Update or create a QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.upsert({
     *   create: {
     *     // ... data to create a QuizAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAttempt we want to update
     *   }
     * })
     */
    upsert<T extends QuizAttemptUpsertArgs>(args: SelectSubset<T, QuizAttemptUpsertArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptCountArgs} args - Arguments to filter QuizAttempts to count.
     * @example
     * // Count the number of QuizAttempts
     * const count = await prisma.quizAttempt.count({
     *   where: {
     *     // ... the filter for the QuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuizAttemptCountArgs>(
      args?: Subset<T, QuizAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAttemptAggregateArgs>(args: Subset<T, QuizAttemptAggregateArgs>): Prisma.PrismaPromise<GetQuizAttemptAggregateType<T>>

    /**
     * Group by QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAttemptGroupByArgs['orderBy'] }
        : { orderBy?: QuizAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAttempt model
   */
  readonly fields: QuizAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends QuizAssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizAssignmentDefaultArgs<ExtArgs>>): Prisma__QuizAssignmentClient<$Result.GetResult<Prisma.$QuizAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    learner<T extends LearnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearnerDefaultArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questionAttempts<T extends QuizAttempt$questionAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttempt$questionAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAttempt model
   */
  interface QuizAttemptFieldRefs {
    readonly id: FieldRef<"QuizAttempt", 'Int'>
    readonly assignmentId: FieldRef<"QuizAttempt", 'Int'>
    readonly learnerId: FieldRef<"QuizAttempt", 'Int'>
    readonly startedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly submittedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly totalTimeSpent: FieldRef<"QuizAttempt", 'Int'>
    readonly score: FieldRef<"QuizAttempt", 'Decimal'>
    readonly passed: FieldRef<"QuizAttempt", 'Boolean'>
    readonly status: FieldRef<"QuizAttempt", 'String'>
    readonly createdAt: FieldRef<"QuizAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizAttempt findUnique
   */
  export type QuizAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findUniqueOrThrow
   */
  export type QuizAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findFirst
   */
  export type QuizAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findFirstOrThrow
   */
  export type QuizAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findMany
   */
  export type QuizAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt create
   */
  export type QuizAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAttempt.
     */
    data: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
  }

  /**
   * QuizAttempt createMany
   */
  export type QuizAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAttempt createManyAndReturn
   */
  export type QuizAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt update
   */
  export type QuizAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAttempt.
     */
    data: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
    /**
     * Choose, which QuizAttempt to update.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt updateMany
   */
  export type QuizAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
  }

  /**
   * QuizAttempt updateManyAndReturn
   */
  export type QuizAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt upsert
   */
  export type QuizAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAttempt to update in case it exists.
     */
    where: QuizAttemptWhereUniqueInput
    /**
     * In case the QuizAttempt found by the `where` argument doesn't exist, create a new QuizAttempt with this data.
     */
    create: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
    /**
     * In case the QuizAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
  }

  /**
   * QuizAttempt delete
   */
  export type QuizAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter which QuizAttempt to delete.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt deleteMany
   */
  export type QuizAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempts to delete
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to delete.
     */
    limit?: number
  }

  /**
   * QuizAttempt.questionAttempts
   */
  export type QuizAttempt$questionAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    where?: QuestionAttemptWhereInput
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    cursor?: QuestionAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt without action
   */
  export type QuizAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
  }


  /**
   * Model QuestionAttempt
   */

  export type AggregateQuestionAttempt = {
    _count: QuestionAttemptCountAggregateOutputType | null
    _avg: QuestionAttemptAvgAggregateOutputType | null
    _sum: QuestionAttemptSumAggregateOutputType | null
    _min: QuestionAttemptMinAggregateOutputType | null
    _max: QuestionAttemptMaxAggregateOutputType | null
  }

  export type QuestionAttemptAvgAggregateOutputType = {
    attemptId: number | null
    questionId: number | null
    timeTakenSec: number | null
  }

  export type QuestionAttemptSumAggregateOutputType = {
    attemptId: number | null
    questionId: number | null
    timeTakenSec: number | null
  }

  export type QuestionAttemptMinAggregateOutputType = {
    attemptId: number | null
    questionId: number | null
    answerText: string | null
    isCorrect: boolean | null
    timeTakenSec: number | null
  }

  export type QuestionAttemptMaxAggregateOutputType = {
    attemptId: number | null
    questionId: number | null
    answerText: string | null
    isCorrect: boolean | null
    timeTakenSec: number | null
  }

  export type QuestionAttemptCountAggregateOutputType = {
    attemptId: number
    questionId: number
    answerText: number
    isCorrect: number
    timeTakenSec: number
    _all: number
  }


  export type QuestionAttemptAvgAggregateInputType = {
    attemptId?: true
    questionId?: true
    timeTakenSec?: true
  }

  export type QuestionAttemptSumAggregateInputType = {
    attemptId?: true
    questionId?: true
    timeTakenSec?: true
  }

  export type QuestionAttemptMinAggregateInputType = {
    attemptId?: true
    questionId?: true
    answerText?: true
    isCorrect?: true
    timeTakenSec?: true
  }

  export type QuestionAttemptMaxAggregateInputType = {
    attemptId?: true
    questionId?: true
    answerText?: true
    isCorrect?: true
    timeTakenSec?: true
  }

  export type QuestionAttemptCountAggregateInputType = {
    attemptId?: true
    questionId?: true
    answerText?: true
    isCorrect?: true
    timeTakenSec?: true
    _all?: true
  }

  export type QuestionAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAttempt to aggregate.
     */
    where?: QuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAttempts to fetch.
     */
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionAttempts
    **/
    _count?: true | QuestionAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionAttemptMaxAggregateInputType
  }

  export type GetQuestionAttemptAggregateType<T extends QuestionAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionAttempt[P]>
      : GetScalarType<T[P], AggregateQuestionAttempt[P]>
  }




  export type QuestionAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAttemptWhereInput
    orderBy?: QuestionAttemptOrderByWithAggregationInput | QuestionAttemptOrderByWithAggregationInput[]
    by: QuestionAttemptScalarFieldEnum[] | QuestionAttemptScalarFieldEnum
    having?: QuestionAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionAttemptCountAggregateInputType | true
    _avg?: QuestionAttemptAvgAggregateInputType
    _sum?: QuestionAttemptSumAggregateInputType
    _min?: QuestionAttemptMinAggregateInputType
    _max?: QuestionAttemptMaxAggregateInputType
  }

  export type QuestionAttemptGroupByOutputType = {
    attemptId: number
    questionId: number
    answerText: string | null
    isCorrect: boolean
    timeTakenSec: number | null
    _count: QuestionAttemptCountAggregateOutputType | null
    _avg: QuestionAttemptAvgAggregateOutputType | null
    _sum: QuestionAttemptSumAggregateOutputType | null
    _min: QuestionAttemptMinAggregateOutputType | null
    _max: QuestionAttemptMaxAggregateOutputType | null
  }

  type GetQuestionAttemptGroupByPayload<T extends QuestionAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionAttemptGroupByOutputType[P]>
        }
      >
    >


  export type QuestionAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attemptId?: boolean
    questionId?: boolean
    answerText?: boolean
    isCorrect?: boolean
    timeTakenSec?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionAttempt"]>

  export type QuestionAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attemptId?: boolean
    questionId?: boolean
    answerText?: boolean
    isCorrect?: boolean
    timeTakenSec?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionAttempt"]>

  export type QuestionAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    attemptId?: boolean
    questionId?: boolean
    answerText?: boolean
    isCorrect?: boolean
    timeTakenSec?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionAttempt"]>

  export type QuestionAttemptSelectScalar = {
    attemptId?: boolean
    questionId?: boolean
    answerText?: boolean
    isCorrect?: boolean
    timeTakenSec?: boolean
  }

  export type QuestionAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"attemptId" | "questionId" | "answerText" | "isCorrect" | "timeTakenSec", ExtArgs["result"]["questionAttempt"]>
  export type QuestionAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }
  export type QuestionAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }
  export type QuestionAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionPoolDefaultArgs<ExtArgs>
  }

  export type $QuestionAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionAttempt"
    objects: {
      attempt: Prisma.$QuizAttemptPayload<ExtArgs>
      question: Prisma.$QuestionPoolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      attemptId: number
      questionId: number
      answerText: string | null
      isCorrect: boolean
      timeTakenSec: number | null
    }, ExtArgs["result"]["questionAttempt"]>
    composites: {}
  }

  type QuestionAttemptGetPayload<S extends boolean | null | undefined | QuestionAttemptDefaultArgs> = $Result.GetResult<Prisma.$QuestionAttemptPayload, S>

  type QuestionAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionAttemptCountAggregateInputType | true
    }

  export interface QuestionAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionAttempt'], meta: { name: 'QuestionAttempt' } }
    /**
     * Find zero or one QuestionAttempt that matches the filter.
     * @param {QuestionAttemptFindUniqueArgs} args - Arguments to find a QuestionAttempt
     * @example
     * // Get one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionAttemptFindUniqueArgs>(args: SelectSubset<T, QuestionAttemptFindUniqueArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionAttemptFindUniqueOrThrowArgs} args - Arguments to find a QuestionAttempt
     * @example
     * // Get one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptFindFirstArgs} args - Arguments to find a QuestionAttempt
     * @example
     * // Get one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionAttemptFindFirstArgs>(args?: SelectSubset<T, QuestionAttemptFindFirstArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptFindFirstOrThrowArgs} args - Arguments to find a QuestionAttempt
     * @example
     * // Get one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionAttempts
     * const questionAttempts = await prisma.questionAttempt.findMany()
     * 
     * // Get first 10 QuestionAttempts
     * const questionAttempts = await prisma.questionAttempt.findMany({ take: 10 })
     * 
     * // Only select the `attemptId`
     * const questionAttemptWithAttemptIdOnly = await prisma.questionAttempt.findMany({ select: { attemptId: true } })
     * 
     */
    findMany<T extends QuestionAttemptFindManyArgs>(args?: SelectSubset<T, QuestionAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionAttempt.
     * @param {QuestionAttemptCreateArgs} args - Arguments to create a QuestionAttempt.
     * @example
     * // Create one QuestionAttempt
     * const QuestionAttempt = await prisma.questionAttempt.create({
     *   data: {
     *     // ... data to create a QuestionAttempt
     *   }
     * })
     * 
     */
    create<T extends QuestionAttemptCreateArgs>(args: SelectSubset<T, QuestionAttemptCreateArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionAttempts.
     * @param {QuestionAttemptCreateManyArgs} args - Arguments to create many QuestionAttempts.
     * @example
     * // Create many QuestionAttempts
     * const questionAttempt = await prisma.questionAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionAttemptCreateManyArgs>(args?: SelectSubset<T, QuestionAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionAttempts and returns the data saved in the database.
     * @param {QuestionAttemptCreateManyAndReturnArgs} args - Arguments to create many QuestionAttempts.
     * @example
     * // Create many QuestionAttempts
     * const questionAttempt = await prisma.questionAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionAttempts and only return the `attemptId`
     * const questionAttemptWithAttemptIdOnly = await prisma.questionAttempt.createManyAndReturn({
     *   select: { attemptId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionAttempt.
     * @param {QuestionAttemptDeleteArgs} args - Arguments to delete one QuestionAttempt.
     * @example
     * // Delete one QuestionAttempt
     * const QuestionAttempt = await prisma.questionAttempt.delete({
     *   where: {
     *     // ... filter to delete one QuestionAttempt
     *   }
     * })
     * 
     */
    delete<T extends QuestionAttemptDeleteArgs>(args: SelectSubset<T, QuestionAttemptDeleteArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionAttempt.
     * @param {QuestionAttemptUpdateArgs} args - Arguments to update one QuestionAttempt.
     * @example
     * // Update one QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionAttemptUpdateArgs>(args: SelectSubset<T, QuestionAttemptUpdateArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionAttempts.
     * @param {QuestionAttemptDeleteManyArgs} args - Arguments to filter QuestionAttempts to delete.
     * @example
     * // Delete a few QuestionAttempts
     * const { count } = await prisma.questionAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionAttemptDeleteManyArgs>(args?: SelectSubset<T, QuestionAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionAttempts
     * const questionAttempt = await prisma.questionAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionAttemptUpdateManyArgs>(args: SelectSubset<T, QuestionAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAttempts and returns the data updated in the database.
     * @param {QuestionAttemptUpdateManyAndReturnArgs} args - Arguments to update many QuestionAttempts.
     * @example
     * // Update many QuestionAttempts
     * const questionAttempt = await prisma.questionAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionAttempts and only return the `attemptId`
     * const questionAttemptWithAttemptIdOnly = await prisma.questionAttempt.updateManyAndReturn({
     *   select: { attemptId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionAttempt.
     * @param {QuestionAttemptUpsertArgs} args - Arguments to update or create a QuestionAttempt.
     * @example
     * // Update or create a QuestionAttempt
     * const questionAttempt = await prisma.questionAttempt.upsert({
     *   create: {
     *     // ... data to create a QuestionAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionAttempt we want to update
     *   }
     * })
     */
    upsert<T extends QuestionAttemptUpsertArgs>(args: SelectSubset<T, QuestionAttemptUpsertArgs<ExtArgs>>): Prisma__QuestionAttemptClient<$Result.GetResult<Prisma.$QuestionAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptCountArgs} args - Arguments to filter QuestionAttempts to count.
     * @example
     * // Count the number of QuestionAttempts
     * const count = await prisma.questionAttempt.count({
     *   where: {
     *     // ... the filter for the QuestionAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuestionAttemptCountArgs>(
      args?: Subset<T, QuestionAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAttemptAggregateArgs>(args: Subset<T, QuestionAttemptAggregateArgs>): Prisma.PrismaPromise<GetQuestionAttemptAggregateType<T>>

    /**
     * Group by QuestionAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionAttemptGroupByArgs['orderBy'] }
        : { orderBy?: QuestionAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionAttempt model
   */
  readonly fields: QuestionAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt<T extends QuizAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttemptDefaultArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuestionPoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionPoolDefaultArgs<ExtArgs>>): Prisma__QuestionPoolClient<$Result.GetResult<Prisma.$QuestionPoolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionAttempt model
   */
  interface QuestionAttemptFieldRefs {
    readonly attemptId: FieldRef<"QuestionAttempt", 'Int'>
    readonly questionId: FieldRef<"QuestionAttempt", 'Int'>
    readonly answerText: FieldRef<"QuestionAttempt", 'String'>
    readonly isCorrect: FieldRef<"QuestionAttempt", 'Boolean'>
    readonly timeTakenSec: FieldRef<"QuestionAttempt", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * QuestionAttempt findUnique
   */
  export type QuestionAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempt to fetch.
     */
    where: QuestionAttemptWhereUniqueInput
  }

  /**
   * QuestionAttempt findUniqueOrThrow
   */
  export type QuestionAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempt to fetch.
     */
    where: QuestionAttemptWhereUniqueInput
  }

  /**
   * QuestionAttempt findFirst
   */
  export type QuestionAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempt to fetch.
     */
    where?: QuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAttempts to fetch.
     */
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAttempts.
     */
    cursor?: QuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAttempts.
     */
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * QuestionAttempt findFirstOrThrow
   */
  export type QuestionAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempt to fetch.
     */
    where?: QuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAttempts to fetch.
     */
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAttempts.
     */
    cursor?: QuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAttempts.
     */
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * QuestionAttempt findMany
   */
  export type QuestionAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuestionAttempts to fetch.
     */
    where?: QuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAttempts to fetch.
     */
    orderBy?: QuestionAttemptOrderByWithRelationInput | QuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionAttempts.
     */
    cursor?: QuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAttempts.
     */
    skip?: number
    distinct?: QuestionAttemptScalarFieldEnum | QuestionAttemptScalarFieldEnum[]
  }

  /**
   * QuestionAttempt create
   */
  export type QuestionAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionAttempt.
     */
    data: XOR<QuestionAttemptCreateInput, QuestionAttemptUncheckedCreateInput>
  }

  /**
   * QuestionAttempt createMany
   */
  export type QuestionAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionAttempts.
     */
    data: QuestionAttemptCreateManyInput | QuestionAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionAttempt createManyAndReturn
   */
  export type QuestionAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionAttempts.
     */
    data: QuestionAttemptCreateManyInput | QuestionAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionAttempt update
   */
  export type QuestionAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionAttempt.
     */
    data: XOR<QuestionAttemptUpdateInput, QuestionAttemptUncheckedUpdateInput>
    /**
     * Choose, which QuestionAttempt to update.
     */
    where: QuestionAttemptWhereUniqueInput
  }

  /**
   * QuestionAttempt updateMany
   */
  export type QuestionAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionAttempts.
     */
    data: XOR<QuestionAttemptUpdateManyMutationInput, QuestionAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAttempts to update
     */
    where?: QuestionAttemptWhereInput
    /**
     * Limit how many QuestionAttempts to update.
     */
    limit?: number
  }

  /**
   * QuestionAttempt updateManyAndReturn
   */
  export type QuestionAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * The data used to update QuestionAttempts.
     */
    data: XOR<QuestionAttemptUpdateManyMutationInput, QuestionAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAttempts to update
     */
    where?: QuestionAttemptWhereInput
    /**
     * Limit how many QuestionAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionAttempt upsert
   */
  export type QuestionAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionAttempt to update in case it exists.
     */
    where: QuestionAttemptWhereUniqueInput
    /**
     * In case the QuestionAttempt found by the `where` argument doesn't exist, create a new QuestionAttempt with this data.
     */
    create: XOR<QuestionAttemptCreateInput, QuestionAttemptUncheckedCreateInput>
    /**
     * In case the QuestionAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionAttemptUpdateInput, QuestionAttemptUncheckedUpdateInput>
  }

  /**
   * QuestionAttempt delete
   */
  export type QuestionAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter which QuestionAttempt to delete.
     */
    where: QuestionAttemptWhereUniqueInput
  }

  /**
   * QuestionAttempt deleteMany
   */
  export type QuestionAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAttempts to delete
     */
    where?: QuestionAttemptWhereInput
    /**
     * Limit how many QuestionAttempts to delete.
     */
    limit?: number
  }

  /**
   * QuestionAttempt without action
   */
  export type QuestionAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAttempt
     */
    select?: QuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAttempt
     */
    omit?: QuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionAttemptInclude<ExtArgs> | null
  }


  /**
   * Model ResourceView
   */

  export type AggregateResourceView = {
    _count: ResourceViewCountAggregateOutputType | null
    _avg: ResourceViewAvgAggregateOutputType | null
    _sum: ResourceViewSumAggregateOutputType | null
    _min: ResourceViewMinAggregateOutputType | null
    _max: ResourceViewMaxAggregateOutputType | null
  }

  export type ResourceViewAvgAggregateOutputType = {
    learnerId: number | null
    resourceId: number | null
  }

  export type ResourceViewSumAggregateOutputType = {
    learnerId: number | null
    resourceId: number | null
  }

  export type ResourceViewMinAggregateOutputType = {
    learnerId: number | null
    resourceId: number | null
    viewedAt: Date | null
  }

  export type ResourceViewMaxAggregateOutputType = {
    learnerId: number | null
    resourceId: number | null
    viewedAt: Date | null
  }

  export type ResourceViewCountAggregateOutputType = {
    learnerId: number
    resourceId: number
    viewedAt: number
    _all: number
  }


  export type ResourceViewAvgAggregateInputType = {
    learnerId?: true
    resourceId?: true
  }

  export type ResourceViewSumAggregateInputType = {
    learnerId?: true
    resourceId?: true
  }

  export type ResourceViewMinAggregateInputType = {
    learnerId?: true
    resourceId?: true
    viewedAt?: true
  }

  export type ResourceViewMaxAggregateInputType = {
    learnerId?: true
    resourceId?: true
    viewedAt?: true
  }

  export type ResourceViewCountAggregateInputType = {
    learnerId?: true
    resourceId?: true
    viewedAt?: true
    _all?: true
  }

  export type ResourceViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceView to aggregate.
     */
    where?: ResourceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceViews to fetch.
     */
    orderBy?: ResourceViewOrderByWithRelationInput | ResourceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ResourceViews
    **/
    _count?: true | ResourceViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceViewMaxAggregateInputType
  }

  export type GetResourceViewAggregateType<T extends ResourceViewAggregateArgs> = {
        [P in keyof T & keyof AggregateResourceView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResourceView[P]>
      : GetScalarType<T[P], AggregateResourceView[P]>
  }




  export type ResourceViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceViewWhereInput
    orderBy?: ResourceViewOrderByWithAggregationInput | ResourceViewOrderByWithAggregationInput[]
    by: ResourceViewScalarFieldEnum[] | ResourceViewScalarFieldEnum
    having?: ResourceViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceViewCountAggregateInputType | true
    _avg?: ResourceViewAvgAggregateInputType
    _sum?: ResourceViewSumAggregateInputType
    _min?: ResourceViewMinAggregateInputType
    _max?: ResourceViewMaxAggregateInputType
  }

  export type ResourceViewGroupByOutputType = {
    learnerId: number
    resourceId: number
    viewedAt: Date
    _count: ResourceViewCountAggregateOutputType | null
    _avg: ResourceViewAvgAggregateOutputType | null
    _sum: ResourceViewSumAggregateOutputType | null
    _min: ResourceViewMinAggregateOutputType | null
    _max: ResourceViewMaxAggregateOutputType | null
  }

  type GetResourceViewGroupByPayload<T extends ResourceViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceViewGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceViewGroupByOutputType[P]>
        }
      >
    >


  export type ResourceViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learnerId?: boolean
    resourceId?: boolean
    viewedAt?: boolean
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceView"]>

  export type ResourceViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learnerId?: boolean
    resourceId?: boolean
    viewedAt?: boolean
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceView"]>

  export type ResourceViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learnerId?: boolean
    resourceId?: boolean
    viewedAt?: boolean
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resourceView"]>

  export type ResourceViewSelectScalar = {
    learnerId?: boolean
    resourceId?: boolean
    viewedAt?: boolean
  }

  export type ResourceViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"learnerId" | "resourceId" | "viewedAt", ExtArgs["result"]["resourceView"]>
  export type ResourceViewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type ResourceViewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }
  export type ResourceViewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $ResourceViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ResourceView"
    objects: {
      learner: Prisma.$LearnerPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      learnerId: number
      resourceId: number
      viewedAt: Date
    }, ExtArgs["result"]["resourceView"]>
    composites: {}
  }

  type ResourceViewGetPayload<S extends boolean | null | undefined | ResourceViewDefaultArgs> = $Result.GetResult<Prisma.$ResourceViewPayload, S>

  type ResourceViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResourceViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResourceViewCountAggregateInputType | true
    }

  export interface ResourceViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ResourceView'], meta: { name: 'ResourceView' } }
    /**
     * Find zero or one ResourceView that matches the filter.
     * @param {ResourceViewFindUniqueArgs} args - Arguments to find a ResourceView
     * @example
     * // Get one ResourceView
     * const resourceView = await prisma.resourceView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceViewFindUniqueArgs>(args: SelectSubset<T, ResourceViewFindUniqueArgs<ExtArgs>>): Prisma__ResourceViewClient<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ResourceView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResourceViewFindUniqueOrThrowArgs} args - Arguments to find a ResourceView
     * @example
     * // Get one ResourceView
     * const resourceView = await prisma.resourceView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceViewClient<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceViewFindFirstArgs} args - Arguments to find a ResourceView
     * @example
     * // Get one ResourceView
     * const resourceView = await prisma.resourceView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceViewFindFirstArgs>(args?: SelectSubset<T, ResourceViewFindFirstArgs<ExtArgs>>): Prisma__ResourceViewClient<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ResourceView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceViewFindFirstOrThrowArgs} args - Arguments to find a ResourceView
     * @example
     * // Get one ResourceView
     * const resourceView = await prisma.resourceView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceViewClient<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ResourceViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ResourceViews
     * const resourceViews = await prisma.resourceView.findMany()
     * 
     * // Get first 10 ResourceViews
     * const resourceViews = await prisma.resourceView.findMany({ take: 10 })
     * 
     * // Only select the `learnerId`
     * const resourceViewWithLearnerIdOnly = await prisma.resourceView.findMany({ select: { learnerId: true } })
     * 
     */
    findMany<T extends ResourceViewFindManyArgs>(args?: SelectSubset<T, ResourceViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ResourceView.
     * @param {ResourceViewCreateArgs} args - Arguments to create a ResourceView.
     * @example
     * // Create one ResourceView
     * const ResourceView = await prisma.resourceView.create({
     *   data: {
     *     // ... data to create a ResourceView
     *   }
     * })
     * 
     */
    create<T extends ResourceViewCreateArgs>(args: SelectSubset<T, ResourceViewCreateArgs<ExtArgs>>): Prisma__ResourceViewClient<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ResourceViews.
     * @param {ResourceViewCreateManyArgs} args - Arguments to create many ResourceViews.
     * @example
     * // Create many ResourceViews
     * const resourceView = await prisma.resourceView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceViewCreateManyArgs>(args?: SelectSubset<T, ResourceViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ResourceViews and returns the data saved in the database.
     * @param {ResourceViewCreateManyAndReturnArgs} args - Arguments to create many ResourceViews.
     * @example
     * // Create many ResourceViews
     * const resourceView = await prisma.resourceView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ResourceViews and only return the `learnerId`
     * const resourceViewWithLearnerIdOnly = await prisma.resourceView.createManyAndReturn({
     *   select: { learnerId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResourceViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ResourceViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ResourceView.
     * @param {ResourceViewDeleteArgs} args - Arguments to delete one ResourceView.
     * @example
     * // Delete one ResourceView
     * const ResourceView = await prisma.resourceView.delete({
     *   where: {
     *     // ... filter to delete one ResourceView
     *   }
     * })
     * 
     */
    delete<T extends ResourceViewDeleteArgs>(args: SelectSubset<T, ResourceViewDeleteArgs<ExtArgs>>): Prisma__ResourceViewClient<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ResourceView.
     * @param {ResourceViewUpdateArgs} args - Arguments to update one ResourceView.
     * @example
     * // Update one ResourceView
     * const resourceView = await prisma.resourceView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceViewUpdateArgs>(args: SelectSubset<T, ResourceViewUpdateArgs<ExtArgs>>): Prisma__ResourceViewClient<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ResourceViews.
     * @param {ResourceViewDeleteManyArgs} args - Arguments to filter ResourceViews to delete.
     * @example
     * // Delete a few ResourceViews
     * const { count } = await prisma.resourceView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceViewDeleteManyArgs>(args?: SelectSubset<T, ResourceViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ResourceViews
     * const resourceView = await prisma.resourceView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceViewUpdateManyArgs>(args: SelectSubset<T, ResourceViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ResourceViews and returns the data updated in the database.
     * @param {ResourceViewUpdateManyAndReturnArgs} args - Arguments to update many ResourceViews.
     * @example
     * // Update many ResourceViews
     * const resourceView = await prisma.resourceView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ResourceViews and only return the `learnerId`
     * const resourceViewWithLearnerIdOnly = await prisma.resourceView.updateManyAndReturn({
     *   select: { learnerId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResourceViewUpdateManyAndReturnArgs>(args: SelectSubset<T, ResourceViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ResourceView.
     * @param {ResourceViewUpsertArgs} args - Arguments to update or create a ResourceView.
     * @example
     * // Update or create a ResourceView
     * const resourceView = await prisma.resourceView.upsert({
     *   create: {
     *     // ... data to create a ResourceView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ResourceView we want to update
     *   }
     * })
     */
    upsert<T extends ResourceViewUpsertArgs>(args: SelectSubset<T, ResourceViewUpsertArgs<ExtArgs>>): Prisma__ResourceViewClient<$Result.GetResult<Prisma.$ResourceViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ResourceViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceViewCountArgs} args - Arguments to filter ResourceViews to count.
     * @example
     * // Count the number of ResourceViews
     * const count = await prisma.resourceView.count({
     *   where: {
     *     // ... the filter for the ResourceViews we want to count
     *   }
     * })
    **/
    count<T extends ResourceViewCountArgs>(
      args?: Subset<T, ResourceViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ResourceView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceViewAggregateArgs>(args: Subset<T, ResourceViewAggregateArgs>): Prisma.PrismaPromise<GetResourceViewAggregateType<T>>

    /**
     * Group by ResourceView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceViewGroupByArgs['orderBy'] }
        : { orderBy?: ResourceViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ResourceView model
   */
  readonly fields: ResourceViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ResourceView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learner<T extends LearnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearnerDefaultArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ResourceView model
   */
  interface ResourceViewFieldRefs {
    readonly learnerId: FieldRef<"ResourceView", 'Int'>
    readonly resourceId: FieldRef<"ResourceView", 'Int'>
    readonly viewedAt: FieldRef<"ResourceView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ResourceView findUnique
   */
  export type ResourceViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    /**
     * Filter, which ResourceView to fetch.
     */
    where: ResourceViewWhereUniqueInput
  }

  /**
   * ResourceView findUniqueOrThrow
   */
  export type ResourceViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    /**
     * Filter, which ResourceView to fetch.
     */
    where: ResourceViewWhereUniqueInput
  }

  /**
   * ResourceView findFirst
   */
  export type ResourceViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    /**
     * Filter, which ResourceView to fetch.
     */
    where?: ResourceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceViews to fetch.
     */
    orderBy?: ResourceViewOrderByWithRelationInput | ResourceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceViews.
     */
    cursor?: ResourceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceViews.
     */
    distinct?: ResourceViewScalarFieldEnum | ResourceViewScalarFieldEnum[]
  }

  /**
   * ResourceView findFirstOrThrow
   */
  export type ResourceViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    /**
     * Filter, which ResourceView to fetch.
     */
    where?: ResourceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceViews to fetch.
     */
    orderBy?: ResourceViewOrderByWithRelationInput | ResourceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ResourceViews.
     */
    cursor?: ResourceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ResourceViews.
     */
    distinct?: ResourceViewScalarFieldEnum | ResourceViewScalarFieldEnum[]
  }

  /**
   * ResourceView findMany
   */
  export type ResourceViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    /**
     * Filter, which ResourceViews to fetch.
     */
    where?: ResourceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ResourceViews to fetch.
     */
    orderBy?: ResourceViewOrderByWithRelationInput | ResourceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ResourceViews.
     */
    cursor?: ResourceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ResourceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ResourceViews.
     */
    skip?: number
    distinct?: ResourceViewScalarFieldEnum | ResourceViewScalarFieldEnum[]
  }

  /**
   * ResourceView create
   */
  export type ResourceViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    /**
     * The data needed to create a ResourceView.
     */
    data: XOR<ResourceViewCreateInput, ResourceViewUncheckedCreateInput>
  }

  /**
   * ResourceView createMany
   */
  export type ResourceViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ResourceViews.
     */
    data: ResourceViewCreateManyInput | ResourceViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ResourceView createManyAndReturn
   */
  export type ResourceViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * The data used to create many ResourceViews.
     */
    data: ResourceViewCreateManyInput | ResourceViewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceView update
   */
  export type ResourceViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    /**
     * The data needed to update a ResourceView.
     */
    data: XOR<ResourceViewUpdateInput, ResourceViewUncheckedUpdateInput>
    /**
     * Choose, which ResourceView to update.
     */
    where: ResourceViewWhereUniqueInput
  }

  /**
   * ResourceView updateMany
   */
  export type ResourceViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ResourceViews.
     */
    data: XOR<ResourceViewUpdateManyMutationInput, ResourceViewUncheckedUpdateManyInput>
    /**
     * Filter which ResourceViews to update
     */
    where?: ResourceViewWhereInput
    /**
     * Limit how many ResourceViews to update.
     */
    limit?: number
  }

  /**
   * ResourceView updateManyAndReturn
   */
  export type ResourceViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * The data used to update ResourceViews.
     */
    data: XOR<ResourceViewUpdateManyMutationInput, ResourceViewUncheckedUpdateManyInput>
    /**
     * Filter which ResourceViews to update
     */
    where?: ResourceViewWhereInput
    /**
     * Limit how many ResourceViews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ResourceView upsert
   */
  export type ResourceViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    /**
     * The filter to search for the ResourceView to update in case it exists.
     */
    where: ResourceViewWhereUniqueInput
    /**
     * In case the ResourceView found by the `where` argument doesn't exist, create a new ResourceView with this data.
     */
    create: XOR<ResourceViewCreateInput, ResourceViewUncheckedCreateInput>
    /**
     * In case the ResourceView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceViewUpdateInput, ResourceViewUncheckedUpdateInput>
  }

  /**
   * ResourceView delete
   */
  export type ResourceViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
    /**
     * Filter which ResourceView to delete.
     */
    where: ResourceViewWhereUniqueInput
  }

  /**
   * ResourceView deleteMany
   */
  export type ResourceViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ResourceViews to delete
     */
    where?: ResourceViewWhereInput
    /**
     * Limit how many ResourceViews to delete.
     */
    limit?: number
  }

  /**
   * ResourceView without action
   */
  export type ResourceViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceView
     */
    select?: ResourceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ResourceView
     */
    omit?: ResourceViewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceViewInclude<ExtArgs> | null
  }


  /**
   * Model MeasureProgress
   */

  export type AggregateMeasureProgress = {
    _count: MeasureProgressCountAggregateOutputType | null
    _avg: MeasureProgressAvgAggregateOutputType | null
    _sum: MeasureProgressSumAggregateOutputType | null
    _min: MeasureProgressMinAggregateOutputType | null
    _max: MeasureProgressMaxAggregateOutputType | null
  }

  export type MeasureProgressAvgAggregateOutputType = {
    learnerId: number | null
    topicId: number | null
    programId: number | null
    moduleId: number | null
    resourceId: number | null
  }

  export type MeasureProgressSumAggregateOutputType = {
    learnerId: number | null
    topicId: number | null
    programId: number | null
    moduleId: number | null
    resourceId: number | null
  }

  export type MeasureProgressMinAggregateOutputType = {
    learnerId: number | null
    topicId: number | null
    completedAt: Date | null
    progressType: string | null
    status: string | null
    programId: number | null
    moduleId: number | null
    resourceId: number | null
  }

  export type MeasureProgressMaxAggregateOutputType = {
    learnerId: number | null
    topicId: number | null
    completedAt: Date | null
    progressType: string | null
    status: string | null
    programId: number | null
    moduleId: number | null
    resourceId: number | null
  }

  export type MeasureProgressCountAggregateOutputType = {
    learnerId: number
    topicId: number
    completedAt: number
    progressType: number
    status: number
    programId: number
    moduleId: number
    resourceId: number
    _all: number
  }


  export type MeasureProgressAvgAggregateInputType = {
    learnerId?: true
    topicId?: true
    programId?: true
    moduleId?: true
    resourceId?: true
  }

  export type MeasureProgressSumAggregateInputType = {
    learnerId?: true
    topicId?: true
    programId?: true
    moduleId?: true
    resourceId?: true
  }

  export type MeasureProgressMinAggregateInputType = {
    learnerId?: true
    topicId?: true
    completedAt?: true
    progressType?: true
    status?: true
    programId?: true
    moduleId?: true
    resourceId?: true
  }

  export type MeasureProgressMaxAggregateInputType = {
    learnerId?: true
    topicId?: true
    completedAt?: true
    progressType?: true
    status?: true
    programId?: true
    moduleId?: true
    resourceId?: true
  }

  export type MeasureProgressCountAggregateInputType = {
    learnerId?: true
    topicId?: true
    completedAt?: true
    progressType?: true
    status?: true
    programId?: true
    moduleId?: true
    resourceId?: true
    _all?: true
  }

  export type MeasureProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeasureProgress to aggregate.
     */
    where?: MeasureProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasureProgresses to fetch.
     */
    orderBy?: MeasureProgressOrderByWithRelationInput | MeasureProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeasureProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasureProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasureProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeasureProgresses
    **/
    _count?: true | MeasureProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeasureProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeasureProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeasureProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeasureProgressMaxAggregateInputType
  }

  export type GetMeasureProgressAggregateType<T extends MeasureProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateMeasureProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeasureProgress[P]>
      : GetScalarType<T[P], AggregateMeasureProgress[P]>
  }




  export type MeasureProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeasureProgressWhereInput
    orderBy?: MeasureProgressOrderByWithAggregationInput | MeasureProgressOrderByWithAggregationInput[]
    by: MeasureProgressScalarFieldEnum[] | MeasureProgressScalarFieldEnum
    having?: MeasureProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeasureProgressCountAggregateInputType | true
    _avg?: MeasureProgressAvgAggregateInputType
    _sum?: MeasureProgressSumAggregateInputType
    _min?: MeasureProgressMinAggregateInputType
    _max?: MeasureProgressMaxAggregateInputType
  }

  export type MeasureProgressGroupByOutputType = {
    learnerId: number
    topicId: number
    completedAt: Date
    progressType: string
    status: string
    programId: number | null
    moduleId: number | null
    resourceId: number | null
    _count: MeasureProgressCountAggregateOutputType | null
    _avg: MeasureProgressAvgAggregateOutputType | null
    _sum: MeasureProgressSumAggregateOutputType | null
    _min: MeasureProgressMinAggregateOutputType | null
    _max: MeasureProgressMaxAggregateOutputType | null
  }

  type GetMeasureProgressGroupByPayload<T extends MeasureProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeasureProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeasureProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeasureProgressGroupByOutputType[P]>
            : GetScalarType<T[P], MeasureProgressGroupByOutputType[P]>
        }
      >
    >


  export type MeasureProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learnerId?: boolean
    topicId?: boolean
    completedAt?: boolean
    progressType?: boolean
    status?: boolean
    programId?: boolean
    moduleId?: boolean
    resourceId?: boolean
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    program?: boolean | MeasureProgress$programArgs<ExtArgs>
    module?: boolean | MeasureProgress$moduleArgs<ExtArgs>
    resource?: boolean | MeasureProgress$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["measureProgress"]>

  export type MeasureProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learnerId?: boolean
    topicId?: boolean
    completedAt?: boolean
    progressType?: boolean
    status?: boolean
    programId?: boolean
    moduleId?: boolean
    resourceId?: boolean
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    program?: boolean | MeasureProgress$programArgs<ExtArgs>
    module?: boolean | MeasureProgress$moduleArgs<ExtArgs>
    resource?: boolean | MeasureProgress$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["measureProgress"]>

  export type MeasureProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    learnerId?: boolean
    topicId?: boolean
    completedAt?: boolean
    progressType?: boolean
    status?: boolean
    programId?: boolean
    moduleId?: boolean
    resourceId?: boolean
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    program?: boolean | MeasureProgress$programArgs<ExtArgs>
    module?: boolean | MeasureProgress$moduleArgs<ExtArgs>
    resource?: boolean | MeasureProgress$resourceArgs<ExtArgs>
  }, ExtArgs["result"]["measureProgress"]>

  export type MeasureProgressSelectScalar = {
    learnerId?: boolean
    topicId?: boolean
    completedAt?: boolean
    progressType?: boolean
    status?: boolean
    programId?: boolean
    moduleId?: boolean
    resourceId?: boolean
  }

  export type MeasureProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"learnerId" | "topicId" | "completedAt" | "progressType" | "status" | "programId" | "moduleId" | "resourceId", ExtArgs["result"]["measureProgress"]>
  export type MeasureProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    program?: boolean | MeasureProgress$programArgs<ExtArgs>
    module?: boolean | MeasureProgress$moduleArgs<ExtArgs>
    resource?: boolean | MeasureProgress$resourceArgs<ExtArgs>
  }
  export type MeasureProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    program?: boolean | MeasureProgress$programArgs<ExtArgs>
    module?: boolean | MeasureProgress$moduleArgs<ExtArgs>
    resource?: boolean | MeasureProgress$resourceArgs<ExtArgs>
  }
  export type MeasureProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
    program?: boolean | MeasureProgress$programArgs<ExtArgs>
    module?: boolean | MeasureProgress$moduleArgs<ExtArgs>
    resource?: boolean | MeasureProgress$resourceArgs<ExtArgs>
  }

  export type $MeasureProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeasureProgress"
    objects: {
      learner: Prisma.$LearnerPayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
      program: Prisma.$ProgramPayload<ExtArgs> | null
      module: Prisma.$ModulePayload<ExtArgs> | null
      resource: Prisma.$ResourcePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      learnerId: number
      topicId: number
      completedAt: Date
      progressType: string
      status: string
      programId: number | null
      moduleId: number | null
      resourceId: number | null
    }, ExtArgs["result"]["measureProgress"]>
    composites: {}
  }

  type MeasureProgressGetPayload<S extends boolean | null | undefined | MeasureProgressDefaultArgs> = $Result.GetResult<Prisma.$MeasureProgressPayload, S>

  type MeasureProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeasureProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeasureProgressCountAggregateInputType | true
    }

  export interface MeasureProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeasureProgress'], meta: { name: 'MeasureProgress' } }
    /**
     * Find zero or one MeasureProgress that matches the filter.
     * @param {MeasureProgressFindUniqueArgs} args - Arguments to find a MeasureProgress
     * @example
     * // Get one MeasureProgress
     * const measureProgress = await prisma.measureProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeasureProgressFindUniqueArgs>(args: SelectSubset<T, MeasureProgressFindUniqueArgs<ExtArgs>>): Prisma__MeasureProgressClient<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MeasureProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeasureProgressFindUniqueOrThrowArgs} args - Arguments to find a MeasureProgress
     * @example
     * // Get one MeasureProgress
     * const measureProgress = await prisma.measureProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeasureProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, MeasureProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeasureProgressClient<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeasureProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasureProgressFindFirstArgs} args - Arguments to find a MeasureProgress
     * @example
     * // Get one MeasureProgress
     * const measureProgress = await prisma.measureProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeasureProgressFindFirstArgs>(args?: SelectSubset<T, MeasureProgressFindFirstArgs<ExtArgs>>): Prisma__MeasureProgressClient<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeasureProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasureProgressFindFirstOrThrowArgs} args - Arguments to find a MeasureProgress
     * @example
     * // Get one MeasureProgress
     * const measureProgress = await prisma.measureProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeasureProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, MeasureProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeasureProgressClient<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MeasureProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasureProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeasureProgresses
     * const measureProgresses = await prisma.measureProgress.findMany()
     * 
     * // Get first 10 MeasureProgresses
     * const measureProgresses = await prisma.measureProgress.findMany({ take: 10 })
     * 
     * // Only select the `learnerId`
     * const measureProgressWithLearnerIdOnly = await prisma.measureProgress.findMany({ select: { learnerId: true } })
     * 
     */
    findMany<T extends MeasureProgressFindManyArgs>(args?: SelectSubset<T, MeasureProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MeasureProgress.
     * @param {MeasureProgressCreateArgs} args - Arguments to create a MeasureProgress.
     * @example
     * // Create one MeasureProgress
     * const MeasureProgress = await prisma.measureProgress.create({
     *   data: {
     *     // ... data to create a MeasureProgress
     *   }
     * })
     * 
     */
    create<T extends MeasureProgressCreateArgs>(args: SelectSubset<T, MeasureProgressCreateArgs<ExtArgs>>): Prisma__MeasureProgressClient<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MeasureProgresses.
     * @param {MeasureProgressCreateManyArgs} args - Arguments to create many MeasureProgresses.
     * @example
     * // Create many MeasureProgresses
     * const measureProgress = await prisma.measureProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeasureProgressCreateManyArgs>(args?: SelectSubset<T, MeasureProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeasureProgresses and returns the data saved in the database.
     * @param {MeasureProgressCreateManyAndReturnArgs} args - Arguments to create many MeasureProgresses.
     * @example
     * // Create many MeasureProgresses
     * const measureProgress = await prisma.measureProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeasureProgresses and only return the `learnerId`
     * const measureProgressWithLearnerIdOnly = await prisma.measureProgress.createManyAndReturn({
     *   select: { learnerId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeasureProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, MeasureProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MeasureProgress.
     * @param {MeasureProgressDeleteArgs} args - Arguments to delete one MeasureProgress.
     * @example
     * // Delete one MeasureProgress
     * const MeasureProgress = await prisma.measureProgress.delete({
     *   where: {
     *     // ... filter to delete one MeasureProgress
     *   }
     * })
     * 
     */
    delete<T extends MeasureProgressDeleteArgs>(args: SelectSubset<T, MeasureProgressDeleteArgs<ExtArgs>>): Prisma__MeasureProgressClient<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MeasureProgress.
     * @param {MeasureProgressUpdateArgs} args - Arguments to update one MeasureProgress.
     * @example
     * // Update one MeasureProgress
     * const measureProgress = await prisma.measureProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeasureProgressUpdateArgs>(args: SelectSubset<T, MeasureProgressUpdateArgs<ExtArgs>>): Prisma__MeasureProgressClient<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MeasureProgresses.
     * @param {MeasureProgressDeleteManyArgs} args - Arguments to filter MeasureProgresses to delete.
     * @example
     * // Delete a few MeasureProgresses
     * const { count } = await prisma.measureProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeasureProgressDeleteManyArgs>(args?: SelectSubset<T, MeasureProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeasureProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasureProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeasureProgresses
     * const measureProgress = await prisma.measureProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeasureProgressUpdateManyArgs>(args: SelectSubset<T, MeasureProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeasureProgresses and returns the data updated in the database.
     * @param {MeasureProgressUpdateManyAndReturnArgs} args - Arguments to update many MeasureProgresses.
     * @example
     * // Update many MeasureProgresses
     * const measureProgress = await prisma.measureProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MeasureProgresses and only return the `learnerId`
     * const measureProgressWithLearnerIdOnly = await prisma.measureProgress.updateManyAndReturn({
     *   select: { learnerId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeasureProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, MeasureProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MeasureProgress.
     * @param {MeasureProgressUpsertArgs} args - Arguments to update or create a MeasureProgress.
     * @example
     * // Update or create a MeasureProgress
     * const measureProgress = await prisma.measureProgress.upsert({
     *   create: {
     *     // ... data to create a MeasureProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeasureProgress we want to update
     *   }
     * })
     */
    upsert<T extends MeasureProgressUpsertArgs>(args: SelectSubset<T, MeasureProgressUpsertArgs<ExtArgs>>): Prisma__MeasureProgressClient<$Result.GetResult<Prisma.$MeasureProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MeasureProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasureProgressCountArgs} args - Arguments to filter MeasureProgresses to count.
     * @example
     * // Count the number of MeasureProgresses
     * const count = await prisma.measureProgress.count({
     *   where: {
     *     // ... the filter for the MeasureProgresses we want to count
     *   }
     * })
    **/
    count<T extends MeasureProgressCountArgs>(
      args?: Subset<T, MeasureProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeasureProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeasureProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasureProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeasureProgressAggregateArgs>(args: Subset<T, MeasureProgressAggregateArgs>): Prisma.PrismaPromise<GetMeasureProgressAggregateType<T>>

    /**
     * Group by MeasureProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasureProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeasureProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeasureProgressGroupByArgs['orderBy'] }
        : { orderBy?: MeasureProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeasureProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeasureProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeasureProgress model
   */
  readonly fields: MeasureProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeasureProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeasureProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learner<T extends LearnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearnerDefaultArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    program<T extends MeasureProgress$programArgs<ExtArgs> = {}>(args?: Subset<T, MeasureProgress$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    module<T extends MeasureProgress$moduleArgs<ExtArgs> = {}>(args?: Subset<T, MeasureProgress$moduleArgs<ExtArgs>>): Prisma__ModuleClient<$Result.GetResult<Prisma.$ModulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    resource<T extends MeasureProgress$resourceArgs<ExtArgs> = {}>(args?: Subset<T, MeasureProgress$resourceArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeasureProgress model
   */
  interface MeasureProgressFieldRefs {
    readonly learnerId: FieldRef<"MeasureProgress", 'Int'>
    readonly topicId: FieldRef<"MeasureProgress", 'Int'>
    readonly completedAt: FieldRef<"MeasureProgress", 'DateTime'>
    readonly progressType: FieldRef<"MeasureProgress", 'String'>
    readonly status: FieldRef<"MeasureProgress", 'String'>
    readonly programId: FieldRef<"MeasureProgress", 'Int'>
    readonly moduleId: FieldRef<"MeasureProgress", 'Int'>
    readonly resourceId: FieldRef<"MeasureProgress", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MeasureProgress findUnique
   */
  export type MeasureProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    /**
     * Filter, which MeasureProgress to fetch.
     */
    where: MeasureProgressWhereUniqueInput
  }

  /**
   * MeasureProgress findUniqueOrThrow
   */
  export type MeasureProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    /**
     * Filter, which MeasureProgress to fetch.
     */
    where: MeasureProgressWhereUniqueInput
  }

  /**
   * MeasureProgress findFirst
   */
  export type MeasureProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    /**
     * Filter, which MeasureProgress to fetch.
     */
    where?: MeasureProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasureProgresses to fetch.
     */
    orderBy?: MeasureProgressOrderByWithRelationInput | MeasureProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeasureProgresses.
     */
    cursor?: MeasureProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasureProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasureProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeasureProgresses.
     */
    distinct?: MeasureProgressScalarFieldEnum | MeasureProgressScalarFieldEnum[]
  }

  /**
   * MeasureProgress findFirstOrThrow
   */
  export type MeasureProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    /**
     * Filter, which MeasureProgress to fetch.
     */
    where?: MeasureProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasureProgresses to fetch.
     */
    orderBy?: MeasureProgressOrderByWithRelationInput | MeasureProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeasureProgresses.
     */
    cursor?: MeasureProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasureProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasureProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeasureProgresses.
     */
    distinct?: MeasureProgressScalarFieldEnum | MeasureProgressScalarFieldEnum[]
  }

  /**
   * MeasureProgress findMany
   */
  export type MeasureProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    /**
     * Filter, which MeasureProgresses to fetch.
     */
    where?: MeasureProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeasureProgresses to fetch.
     */
    orderBy?: MeasureProgressOrderByWithRelationInput | MeasureProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeasureProgresses.
     */
    cursor?: MeasureProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeasureProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeasureProgresses.
     */
    skip?: number
    distinct?: MeasureProgressScalarFieldEnum | MeasureProgressScalarFieldEnum[]
  }

  /**
   * MeasureProgress create
   */
  export type MeasureProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a MeasureProgress.
     */
    data: XOR<MeasureProgressCreateInput, MeasureProgressUncheckedCreateInput>
  }

  /**
   * MeasureProgress createMany
   */
  export type MeasureProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeasureProgresses.
     */
    data: MeasureProgressCreateManyInput | MeasureProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeasureProgress createManyAndReturn
   */
  export type MeasureProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * The data used to create many MeasureProgresses.
     */
    data: MeasureProgressCreateManyInput | MeasureProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeasureProgress update
   */
  export type MeasureProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a MeasureProgress.
     */
    data: XOR<MeasureProgressUpdateInput, MeasureProgressUncheckedUpdateInput>
    /**
     * Choose, which MeasureProgress to update.
     */
    where: MeasureProgressWhereUniqueInput
  }

  /**
   * MeasureProgress updateMany
   */
  export type MeasureProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeasureProgresses.
     */
    data: XOR<MeasureProgressUpdateManyMutationInput, MeasureProgressUncheckedUpdateManyInput>
    /**
     * Filter which MeasureProgresses to update
     */
    where?: MeasureProgressWhereInput
    /**
     * Limit how many MeasureProgresses to update.
     */
    limit?: number
  }

  /**
   * MeasureProgress updateManyAndReturn
   */
  export type MeasureProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * The data used to update MeasureProgresses.
     */
    data: XOR<MeasureProgressUpdateManyMutationInput, MeasureProgressUncheckedUpdateManyInput>
    /**
     * Filter which MeasureProgresses to update
     */
    where?: MeasureProgressWhereInput
    /**
     * Limit how many MeasureProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeasureProgress upsert
   */
  export type MeasureProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the MeasureProgress to update in case it exists.
     */
    where: MeasureProgressWhereUniqueInput
    /**
     * In case the MeasureProgress found by the `where` argument doesn't exist, create a new MeasureProgress with this data.
     */
    create: XOR<MeasureProgressCreateInput, MeasureProgressUncheckedCreateInput>
    /**
     * In case the MeasureProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeasureProgressUpdateInput, MeasureProgressUncheckedUpdateInput>
  }

  /**
   * MeasureProgress delete
   */
  export type MeasureProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
    /**
     * Filter which MeasureProgress to delete.
     */
    where: MeasureProgressWhereUniqueInput
  }

  /**
   * MeasureProgress deleteMany
   */
  export type MeasureProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeasureProgresses to delete
     */
    where?: MeasureProgressWhereInput
    /**
     * Limit how many MeasureProgresses to delete.
     */
    limit?: number
  }

  /**
   * MeasureProgress.program
   */
  export type MeasureProgress$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Program
     */
    omit?: ProgramOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * MeasureProgress.module
   */
  export type MeasureProgress$moduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Module
     */
    select?: ModuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Module
     */
    omit?: ModuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ModuleInclude<ExtArgs> | null
    where?: ModuleWhereInput
  }

  /**
   * MeasureProgress.resource
   */
  export type MeasureProgress$resourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resource
     */
    omit?: ResourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    where?: ResourceWhereInput
  }

  /**
   * MeasureProgress without action
   */
  export type MeasureProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeasureProgress
     */
    select?: MeasureProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeasureProgress
     */
    omit?: MeasureProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeasureProgressInclude<ExtArgs> | null
  }


  /**
   * Model Leaderboard
   */

  export type AggregateLeaderboard = {
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  export type LeaderboardAvgAggregateOutputType = {
    programId: number | null
    learnerId: number | null
    totalScore: Decimal | null
  }

  export type LeaderboardSumAggregateOutputType = {
    programId: number | null
    learnerId: number | null
    totalScore: Decimal | null
  }

  export type LeaderboardMinAggregateOutputType = {
    programId: number | null
    learnerId: number | null
    totalScore: Decimal | null
    lastAttemptAt: Date | null
  }

  export type LeaderboardMaxAggregateOutputType = {
    programId: number | null
    learnerId: number | null
    totalScore: Decimal | null
    lastAttemptAt: Date | null
  }

  export type LeaderboardCountAggregateOutputType = {
    programId: number
    learnerId: number
    totalScore: number
    lastAttemptAt: number
    _all: number
  }


  export type LeaderboardAvgAggregateInputType = {
    programId?: true
    learnerId?: true
    totalScore?: true
  }

  export type LeaderboardSumAggregateInputType = {
    programId?: true
    learnerId?: true
    totalScore?: true
  }

  export type LeaderboardMinAggregateInputType = {
    programId?: true
    learnerId?: true
    totalScore?: true
    lastAttemptAt?: true
  }

  export type LeaderboardMaxAggregateInputType = {
    programId?: true
    learnerId?: true
    totalScore?: true
    lastAttemptAt?: true
  }

  export type LeaderboardCountAggregateInputType = {
    programId?: true
    learnerId?: true
    totalScore?: true
    lastAttemptAt?: true
    _all?: true
  }

  export type LeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboard to aggregate.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaderboards
    **/
    _count?: true | LeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardMaxAggregateInputType
  }

  export type GetLeaderboardAggregateType<T extends LeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboard[P]>
      : GetScalarType<T[P], AggregateLeaderboard[P]>
  }




  export type LeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithAggregationInput | LeaderboardOrderByWithAggregationInput[]
    by: LeaderboardScalarFieldEnum[] | LeaderboardScalarFieldEnum
    having?: LeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardCountAggregateInputType | true
    _avg?: LeaderboardAvgAggregateInputType
    _sum?: LeaderboardSumAggregateInputType
    _min?: LeaderboardMinAggregateInputType
    _max?: LeaderboardMaxAggregateInputType
  }

  export type LeaderboardGroupByOutputType = {
    programId: number
    learnerId: number
    totalScore: Decimal
    lastAttemptAt: Date | null
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  type GetLeaderboardGroupByPayload<T extends LeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    programId?: boolean
    learnerId?: boolean
    totalScore?: boolean
    lastAttemptAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    programId?: boolean
    learnerId?: boolean
    totalScore?: boolean
    lastAttemptAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    programId?: boolean
    learnerId?: boolean
    totalScore?: boolean
    lastAttemptAt?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>

  export type LeaderboardSelectScalar = {
    programId?: boolean
    learnerId?: boolean
    totalScore?: boolean
    lastAttemptAt?: boolean
  }

  export type LeaderboardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"programId" | "learnerId" | "totalScore" | "lastAttemptAt", ExtArgs["result"]["leaderboard"]>
  export type LeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }
  export type LeaderboardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }
  export type LeaderboardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    learner?: boolean | LearnerDefaultArgs<ExtArgs>
  }

  export type $LeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leaderboard"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      learner: Prisma.$LearnerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      programId: number
      learnerId: number
      totalScore: Prisma.Decimal
      lastAttemptAt: Date | null
    }, ExtArgs["result"]["leaderboard"]>
    composites: {}
  }

  type LeaderboardGetPayload<S extends boolean | null | undefined | LeaderboardDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardPayload, S>

  type LeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaderboardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaderboardCountAggregateInputType | true
    }

  export interface LeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leaderboard'], meta: { name: 'Leaderboard' } }
    /**
     * Find zero or one Leaderboard that matches the filter.
     * @param {LeaderboardFindUniqueArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardFindUniqueArgs>(args: SelectSubset<T, LeaderboardFindUniqueArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leaderboard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaderboardFindUniqueOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardFindFirstArgs>(args?: SelectSubset<T, LeaderboardFindFirstArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany()
     * 
     * // Get first 10 Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany({ take: 10 })
     * 
     * // Only select the `programId`
     * const leaderboardWithProgramIdOnly = await prisma.leaderboard.findMany({ select: { programId: true } })
     * 
     */
    findMany<T extends LeaderboardFindManyArgs>(args?: SelectSubset<T, LeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leaderboard.
     * @param {LeaderboardCreateArgs} args - Arguments to create a Leaderboard.
     * @example
     * // Create one Leaderboard
     * const Leaderboard = await prisma.leaderboard.create({
     *   data: {
     *     // ... data to create a Leaderboard
     *   }
     * })
     * 
     */
    create<T extends LeaderboardCreateArgs>(args: SelectSubset<T, LeaderboardCreateArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaderboards.
     * @param {LeaderboardCreateManyArgs} args - Arguments to create many Leaderboards.
     * @example
     * // Create many Leaderboards
     * const leaderboard = await prisma.leaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderboardCreateManyArgs>(args?: SelectSubset<T, LeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaderboards and returns the data saved in the database.
     * @param {LeaderboardCreateManyAndReturnArgs} args - Arguments to create many Leaderboards.
     * @example
     * // Create many Leaderboards
     * const leaderboard = await prisma.leaderboard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaderboards and only return the `programId`
     * const leaderboardWithProgramIdOnly = await prisma.leaderboard.createManyAndReturn({
     *   select: { programId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaderboardCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaderboardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leaderboard.
     * @param {LeaderboardDeleteArgs} args - Arguments to delete one Leaderboard.
     * @example
     * // Delete one Leaderboard
     * const Leaderboard = await prisma.leaderboard.delete({
     *   where: {
     *     // ... filter to delete one Leaderboard
     *   }
     * })
     * 
     */
    delete<T extends LeaderboardDeleteArgs>(args: SelectSubset<T, LeaderboardDeleteArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leaderboard.
     * @param {LeaderboardUpdateArgs} args - Arguments to update one Leaderboard.
     * @example
     * // Update one Leaderboard
     * const leaderboard = await prisma.leaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderboardUpdateArgs>(args: SelectSubset<T, LeaderboardUpdateArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaderboards.
     * @param {LeaderboardDeleteManyArgs} args - Arguments to filter Leaderboards to delete.
     * @example
     * // Delete a few Leaderboards
     * const { count } = await prisma.leaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderboardDeleteManyArgs>(args?: SelectSubset<T, LeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderboardUpdateManyArgs>(args: SelectSubset<T, LeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards and returns the data updated in the database.
     * @param {LeaderboardUpdateManyAndReturnArgs} args - Arguments to update many Leaderboards.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leaderboards and only return the `programId`
     * const leaderboardWithProgramIdOnly = await prisma.leaderboard.updateManyAndReturn({
     *   select: { programId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaderboardUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaderboardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leaderboard.
     * @param {LeaderboardUpsertArgs} args - Arguments to update or create a Leaderboard.
     * @example
     * // Update or create a Leaderboard
     * const leaderboard = await prisma.leaderboard.upsert({
     *   create: {
     *     // ... data to create a Leaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leaderboard we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardUpsertArgs>(args: SelectSubset<T, LeaderboardUpsertArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardCountArgs} args - Arguments to filter Leaderboards to count.
     * @example
     * // Count the number of Leaderboards
     * const count = await prisma.leaderboard.count({
     *   where: {
     *     // ... the filter for the Leaderboards we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardCountArgs>(
      args?: Subset<T, LeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardAggregateArgs>(args: Subset<T, LeaderboardAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardAggregateType<T>>

    /**
     * Group by Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leaderboard model
   */
  readonly fields: LeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    learner<T extends LearnerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearnerDefaultArgs<ExtArgs>>): Prisma__LearnerClient<$Result.GetResult<Prisma.$LearnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leaderboard model
   */
  interface LeaderboardFieldRefs {
    readonly programId: FieldRef<"Leaderboard", 'Int'>
    readonly learnerId: FieldRef<"Leaderboard", 'Int'>
    readonly totalScore: FieldRef<"Leaderboard", 'Decimal'>
    readonly lastAttemptAt: FieldRef<"Leaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leaderboard findUnique
   */
  export type LeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard findUniqueOrThrow
   */
  export type LeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard findFirst
   */
  export type LeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard findFirstOrThrow
   */
  export type LeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard findMany
   */
  export type LeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboards to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard create
   */
  export type LeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Leaderboard.
     */
    data: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
  }

  /**
   * Leaderboard createMany
   */
  export type LeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaderboards.
     */
    data: LeaderboardCreateManyInput | LeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leaderboard createManyAndReturn
   */
  export type LeaderboardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * The data used to create many Leaderboards.
     */
    data: LeaderboardCreateManyInput | LeaderboardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leaderboard update
   */
  export type LeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Leaderboard.
     */
    data: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
    /**
     * Choose, which Leaderboard to update.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard updateMany
   */
  export type LeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaderboards.
     */
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which Leaderboards to update
     */
    where?: LeaderboardWhereInput
    /**
     * Limit how many Leaderboards to update.
     */
    limit?: number
  }

  /**
   * Leaderboard updateManyAndReturn
   */
  export type LeaderboardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * The data used to update Leaderboards.
     */
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which Leaderboards to update
     */
    where?: LeaderboardWhereInput
    /**
     * Limit how many Leaderboards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leaderboard upsert
   */
  export type LeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Leaderboard to update in case it exists.
     */
    where: LeaderboardWhereUniqueInput
    /**
     * In case the Leaderboard found by the `where` argument doesn't exist, create a new Leaderboard with this data.
     */
    create: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
    /**
     * In case the Leaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
  }

  /**
   * Leaderboard delete
   */
  export type LeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter which Leaderboard to delete.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard deleteMany
   */
  export type LeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboards to delete
     */
    where?: LeaderboardWhereInput
    /**
     * Limit how many Leaderboards to delete.
     */
    limit?: number
  }

  /**
   * Leaderboard without action
   */
  export type LeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leaderboard
     */
    omit?: LeaderboardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdminScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password',
    adminType: 'adminType',
    organization: 'organization',
    bio: 'bio',
    profile_image: 'profile_image',
    contactPhone: 'contactPhone',
    website: 'website',
    isVerified: 'isVerified',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const LearnerScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    gender: 'gender',
    dob: 'dob',
    email: 'email',
    phone: 'phone',
    communicationEmail: 'communicationEmail',
    password: 'password',
    profile_image: 'profile_image',
    organisation: 'organisation',
    designation: 'designation',
    department: 'department',
    location: 'location',
    hierarchy_level: 'hierarchy_level',
    totalPoints: 'totalPoints',
    isActive: 'isActive',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    isVerified: 'isVerified',
    lastLogin: 'lastLogin',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    uniqueHash: 'uniqueHash',
    status: 'status',
    extraConfig: 'extraConfig',
    metaData: 'metaData',
    role: 'role'
  };

  export type LearnerScalarFieldEnum = (typeof LearnerScalarFieldEnum)[keyof typeof LearnerScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    title: 'title',
    description: 'description',
    category: 'category',
    instructor: 'instructor',
    instructorAvatar: 'instructorAvatar',
    image: 'image',
    rating: 'rating',
    level: 'level',
    price: 'price',
    type: 'type',
    totalTimeLimit: 'totalTimeLimit',
    status: 'status',
    uniqueHash: 'uniqueHash',
    startDate: 'startDate',
    endDate: 'endDate',
    surveyStartDate: 'surveyStartDate',
    surveyEndDate: 'surveyEndDate',
    maxParticipants: 'maxParticipants',
    passingScore: 'passingScore',
    studySettings: 'studySettings',
    clientId: 'clientId',
    packageId: 'packageId',
    isActive: 'isActive',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const ModuleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    prerequisiteModuleId: 'prerequisiteModuleId',
    status: 'status',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModuleScalarFieldEnum = (typeof ModuleScalarFieldEnum)[keyof typeof ModuleScalarFieldEnum]


  export const EnrollmentScalarFieldEnum: {
    id: 'id',
    learnerId: 'learnerId',
    programId: 'programId',
    enrolledAt: 'enrolledAt'
  };

  export type EnrollmentScalarFieldEnum = (typeof EnrollmentScalarFieldEnum)[keyof typeof EnrollmentScalarFieldEnum]


  export const ProgramModuleScalarFieldEnum: {
    programId: 'programId',
    moduleId: 'moduleId',
    position: 'position'
  };

  export type ProgramModuleScalarFieldEnum = (typeof ProgramModuleScalarFieldEnum)[keyof typeof ProgramModuleScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    prerequisiteTopicId: 'prerequisiteTopicId',
    status: 'status',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const ModuleTopicScalarFieldEnum: {
    moduleId: 'moduleId',
    topicId: 'topicId',
    position: 'position'
  };

  export type ModuleTopicScalarFieldEnum = (typeof ModuleTopicScalarFieldEnum)[keyof typeof ModuleTopicScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    resourceType: 'resourceType',
    url: 'url',
    title: 'title',
    description: 'description',
    status: 'status',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const TopicResourceScalarFieldEnum: {
    topicId: 'topicId',
    resourceId: 'resourceId',
    position: 'position'
  };

  export type TopicResourceScalarFieldEnum = (typeof TopicResourceScalarFieldEnum)[keyof typeof TopicResourceScalarFieldEnum]


  export const QuestionPoolScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    questionText: 'questionText',
    questionType: 'questionType',
    metadata: 'metadata',
    explanation: 'explanation',
    timeLimitSec: 'timeLimitSec',
    points: 'points',
    option1: 'option1',
    option2: 'option2',
    option3: 'option3',
    option4: 'option4',
    option5: 'option5',
    option6: 'option6',
    answer: 'answer',
    createdAt: 'createdAt'
  };

  export type QuestionPoolScalarFieldEnum = (typeof QuestionPoolScalarFieldEnum)[keyof typeof QuestionPoolScalarFieldEnum]


  export const QuizPaperScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    title: 'title',
    createdAt: 'createdAt'
  };

  export type QuizPaperScalarFieldEnum = (typeof QuizPaperScalarFieldEnum)[keyof typeof QuizPaperScalarFieldEnum]


  export const QuizPaperQuestionScalarFieldEnum: {
    quizPaperId: 'quizPaperId',
    questionId: 'questionId',
    position: 'position',
    timeMode: 'timeMode',
    timeLimit: 'timeLimit'
  };

  export type QuizPaperQuestionScalarFieldEnum = (typeof QuizPaperQuestionScalarFieldEnum)[keyof typeof QuizPaperQuestionScalarFieldEnum]


  export const QuizAssignmentScalarFieldEnum: {
    id: 'id',
    quizPaperId: 'quizPaperId',
    programId: 'programId',
    startAt: 'startAt',
    endAt: 'endAt',
    uniqueLinkToken: 'uniqueLinkToken',
    timeMode: 'timeMode',
    wrongAnsMode: 'wrongAnsMode',
    resultMode: 'resultMode',
    totalTimeLimit: 'totalTimeLimit',
    passingScore: 'passingScore',
    enabled: 'enabled',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt'
  };

  export type QuizAssignmentScalarFieldEnum = (typeof QuizAssignmentScalarFieldEnum)[keyof typeof QuizAssignmentScalarFieldEnum]


  export const QuizAttemptScalarFieldEnum: {
    id: 'id',
    assignmentId: 'assignmentId',
    learnerId: 'learnerId',
    startedAt: 'startedAt',
    submittedAt: 'submittedAt',
    totalTimeSpent: 'totalTimeSpent',
    score: 'score',
    passed: 'passed',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type QuizAttemptScalarFieldEnum = (typeof QuizAttemptScalarFieldEnum)[keyof typeof QuizAttemptScalarFieldEnum]


  export const QuestionAttemptScalarFieldEnum: {
    attemptId: 'attemptId',
    questionId: 'questionId',
    answerText: 'answerText',
    isCorrect: 'isCorrect',
    timeTakenSec: 'timeTakenSec'
  };

  export type QuestionAttemptScalarFieldEnum = (typeof QuestionAttemptScalarFieldEnum)[keyof typeof QuestionAttemptScalarFieldEnum]


  export const ResourceViewScalarFieldEnum: {
    learnerId: 'learnerId',
    resourceId: 'resourceId',
    viewedAt: 'viewedAt'
  };

  export type ResourceViewScalarFieldEnum = (typeof ResourceViewScalarFieldEnum)[keyof typeof ResourceViewScalarFieldEnum]


  export const MeasureProgressScalarFieldEnum: {
    learnerId: 'learnerId',
    topicId: 'topicId',
    completedAt: 'completedAt',
    progressType: 'progressType',
    status: 'status',
    programId: 'programId',
    moduleId: 'moduleId',
    resourceId: 'resourceId'
  };

  export type MeasureProgressScalarFieldEnum = (typeof MeasureProgressScalarFieldEnum)[keyof typeof MeasureProgressScalarFieldEnum]


  export const LeaderboardScalarFieldEnum: {
    programId: 'programId',
    learnerId: 'learnerId',
    totalScore: 'totalScore',
    lastAttemptAt: 'lastAttemptAt'
  };

  export type LeaderboardScalarFieldEnum = (typeof LeaderboardScalarFieldEnum)[keyof typeof LeaderboardScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'AdminType'
   */
  export type EnumAdminTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminType'>
    


  /**
   * Reference to a field of type 'AdminType[]'
   */
  export type ListEnumAdminTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdminType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ProgramType'
   */
  export type EnumProgramTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgramType'>
    


  /**
   * Reference to a field of type 'ProgramType[]'
   */
  export type ListEnumProgramTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgramType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'ResourceType[]'
   */
  export type ListEnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'TimeMode'
   */
  export type EnumTimeModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeMode'>
    


  /**
   * Reference to a field of type 'TimeMode[]'
   */
  export type ListEnumTimeModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TimeMode[]'>
    


  /**
   * Reference to a field of type 'WrongAnswerMode'
   */
  export type EnumWrongAnswerModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WrongAnswerMode'>
    


  /**
   * Reference to a field of type 'WrongAnswerMode[]'
   */
  export type ListEnumWrongAnswerModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WrongAnswerMode[]'>
    


  /**
   * Reference to a field of type 'ResultMode'
   */
  export type EnumResultModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultMode'>
    


  /**
   * Reference to a field of type 'ResultMode[]'
   */
  export type ListEnumResultModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResultMode[]'>
    
  /**
   * Deep Input Types
   */


  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: IntFilter<"Admin"> | number
    first_name?: StringFilter<"Admin"> | string
    last_name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    adminType?: EnumAdminTypeFilter<"Admin"> | $Enums.AdminType
    organization?: StringNullableFilter<"Admin"> | string | null
    bio?: StringNullableFilter<"Admin"> | string | null
    profile_image?: StringNullableFilter<"Admin"> | string | null
    contactPhone?: StringNullableFilter<"Admin"> | string | null
    website?: StringNullableFilter<"Admin"> | string | null
    isVerified?: BoolFilter<"Admin"> | boolean
    isActive?: BoolFilter<"Admin"> | boolean
    lastLogin?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdBy?: IntNullableFilter<"Admin"> | number | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    creator?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdAdmins?: AdminListRelationFilter
    questions?: QuestionPoolListRelationFilter
    quizPapers?: QuizPaperListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    adminType?: SortOrder
    organization?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: AdminOrderByWithRelationInput
    createdAdmins?: AdminOrderByRelationAggregateInput
    questions?: QuestionPoolOrderByRelationAggregateInput
    quizPapers?: QuizPaperOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    first_name?: StringFilter<"Admin"> | string
    last_name?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    adminType?: EnumAdminTypeFilter<"Admin"> | $Enums.AdminType
    organization?: StringNullableFilter<"Admin"> | string | null
    bio?: StringNullableFilter<"Admin"> | string | null
    profile_image?: StringNullableFilter<"Admin"> | string | null
    contactPhone?: StringNullableFilter<"Admin"> | string | null
    website?: StringNullableFilter<"Admin"> | string | null
    isVerified?: BoolFilter<"Admin"> | boolean
    isActive?: BoolFilter<"Admin"> | boolean
    lastLogin?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdBy?: IntNullableFilter<"Admin"> | number | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    creator?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdAdmins?: AdminListRelationFilter
    questions?: QuestionPoolListRelationFilter
    quizPapers?: QuizPaperListRelationFilter
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    adminType?: SortOrder
    organization?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    contactPhone?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Admin"> | number
    first_name?: StringWithAggregatesFilter<"Admin"> | string
    last_name?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    password?: StringWithAggregatesFilter<"Admin"> | string
    adminType?: EnumAdminTypeWithAggregatesFilter<"Admin"> | $Enums.AdminType
    organization?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    profile_image?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    contactPhone?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    website?: StringNullableWithAggregatesFilter<"Admin"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Admin"> | boolean
    isActive?: BoolWithAggregatesFilter<"Admin"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"Admin"> | Date | string | null
    createdBy?: IntNullableWithAggregatesFilter<"Admin"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type LearnerWhereInput = {
    AND?: LearnerWhereInput | LearnerWhereInput[]
    OR?: LearnerWhereInput[]
    NOT?: LearnerWhereInput | LearnerWhereInput[]
    id?: IntFilter<"Learner"> | number
    first_name?: StringFilter<"Learner"> | string
    last_name?: StringFilter<"Learner"> | string
    gender?: StringNullableFilter<"Learner"> | string | null
    dob?: DateTimeNullableFilter<"Learner"> | Date | string | null
    email?: StringFilter<"Learner"> | string
    phone?: BytesNullableFilter<"Learner"> | Uint8Array | null
    communicationEmail?: BytesNullableFilter<"Learner"> | Uint8Array | null
    password?: StringNullableFilter<"Learner"> | string | null
    profile_image?: StringNullableFilter<"Learner"> | string | null
    organisation?: StringNullableFilter<"Learner"> | string | null
    designation?: StringNullableFilter<"Learner"> | string | null
    department?: StringNullableFilter<"Learner"> | string | null
    location?: StringNullableFilter<"Learner"> | string | null
    hierarchy_level?: StringNullableFilter<"Learner"> | string | null
    totalPoints?: IntFilter<"Learner"> | number
    isActive?: BoolFilter<"Learner"> | boolean
    isDeleted?: BoolFilter<"Learner"> | boolean
    deletedAt?: DateTimeNullableFilter<"Learner"> | Date | string | null
    isVerified?: BoolFilter<"Learner"> | boolean
    lastLogin?: DateTimeNullableFilter<"Learner"> | Date | string | null
    createdBy?: IntNullableFilter<"Learner"> | number | null
    createdAt?: DateTimeFilter<"Learner"> | Date | string
    updatedAt?: DateTimeFilter<"Learner"> | Date | string
    uniqueHash?: StringNullableFilter<"Learner"> | string | null
    status?: IntNullableFilter<"Learner"> | number | null
    extraConfig?: StringNullableFilter<"Learner"> | string | null
    metaData?: StringNullableFilter<"Learner"> | string | null
    role?: StringFilter<"Learner"> | string
    creator?: XOR<LearnerNullableScalarRelationFilter, LearnerWhereInput> | null
    createdLearners?: LearnerListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    resourceViews?: ResourceViewListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    leaderboards?: LeaderboardListRelationFilter
  }

  export type LearnerOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    communicationEmail?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    organisation?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    hierarchy_level?: SortOrderInput | SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueHash?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    extraConfig?: SortOrderInput | SortOrder
    metaData?: SortOrderInput | SortOrder
    role?: SortOrder
    creator?: LearnerOrderByWithRelationInput
    createdLearners?: LearnerOrderByRelationAggregateInput
    enrollments?: EnrollmentOrderByRelationAggregateInput
    quizAttempts?: QuizAttemptOrderByRelationAggregateInput
    resourceViews?: ResourceViewOrderByRelationAggregateInput
    measureProgress?: MeasureProgressOrderByRelationAggregateInput
    leaderboards?: LeaderboardOrderByRelationAggregateInput
  }

  export type LearnerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: LearnerWhereInput | LearnerWhereInput[]
    OR?: LearnerWhereInput[]
    NOT?: LearnerWhereInput | LearnerWhereInput[]
    first_name?: StringFilter<"Learner"> | string
    last_name?: StringFilter<"Learner"> | string
    gender?: StringNullableFilter<"Learner"> | string | null
    dob?: DateTimeNullableFilter<"Learner"> | Date | string | null
    phone?: BytesNullableFilter<"Learner"> | Uint8Array | null
    communicationEmail?: BytesNullableFilter<"Learner"> | Uint8Array | null
    password?: StringNullableFilter<"Learner"> | string | null
    profile_image?: StringNullableFilter<"Learner"> | string | null
    organisation?: StringNullableFilter<"Learner"> | string | null
    designation?: StringNullableFilter<"Learner"> | string | null
    department?: StringNullableFilter<"Learner"> | string | null
    location?: StringNullableFilter<"Learner"> | string | null
    hierarchy_level?: StringNullableFilter<"Learner"> | string | null
    totalPoints?: IntFilter<"Learner"> | number
    isActive?: BoolFilter<"Learner"> | boolean
    isDeleted?: BoolFilter<"Learner"> | boolean
    deletedAt?: DateTimeNullableFilter<"Learner"> | Date | string | null
    isVerified?: BoolFilter<"Learner"> | boolean
    lastLogin?: DateTimeNullableFilter<"Learner"> | Date | string | null
    createdBy?: IntNullableFilter<"Learner"> | number | null
    createdAt?: DateTimeFilter<"Learner"> | Date | string
    updatedAt?: DateTimeFilter<"Learner"> | Date | string
    uniqueHash?: StringNullableFilter<"Learner"> | string | null
    status?: IntNullableFilter<"Learner"> | number | null
    extraConfig?: StringNullableFilter<"Learner"> | string | null
    metaData?: StringNullableFilter<"Learner"> | string | null
    role?: StringFilter<"Learner"> | string
    creator?: XOR<LearnerNullableScalarRelationFilter, LearnerWhereInput> | null
    createdLearners?: LearnerListRelationFilter
    enrollments?: EnrollmentListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    resourceViews?: ResourceViewListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    leaderboards?: LeaderboardListRelationFilter
  }, "id" | "email">

  export type LearnerOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    communicationEmail?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    profile_image?: SortOrderInput | SortOrder
    organisation?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    hierarchy_level?: SortOrderInput | SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueHash?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    extraConfig?: SortOrderInput | SortOrder
    metaData?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: LearnerCountOrderByAggregateInput
    _avg?: LearnerAvgOrderByAggregateInput
    _max?: LearnerMaxOrderByAggregateInput
    _min?: LearnerMinOrderByAggregateInput
    _sum?: LearnerSumOrderByAggregateInput
  }

  export type LearnerScalarWhereWithAggregatesInput = {
    AND?: LearnerScalarWhereWithAggregatesInput | LearnerScalarWhereWithAggregatesInput[]
    OR?: LearnerScalarWhereWithAggregatesInput[]
    NOT?: LearnerScalarWhereWithAggregatesInput | LearnerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Learner"> | number
    first_name?: StringWithAggregatesFilter<"Learner"> | string
    last_name?: StringWithAggregatesFilter<"Learner"> | string
    gender?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"Learner"> | Date | string | null
    email?: StringWithAggregatesFilter<"Learner"> | string
    phone?: BytesNullableWithAggregatesFilter<"Learner"> | Uint8Array | null
    communicationEmail?: BytesNullableWithAggregatesFilter<"Learner"> | Uint8Array | null
    password?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    profile_image?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    organisation?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    designation?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    department?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    location?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    hierarchy_level?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    totalPoints?: IntWithAggregatesFilter<"Learner"> | number
    isActive?: BoolWithAggregatesFilter<"Learner"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Learner"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Learner"> | Date | string | null
    isVerified?: BoolWithAggregatesFilter<"Learner"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"Learner"> | Date | string | null
    createdBy?: IntNullableWithAggregatesFilter<"Learner"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Learner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Learner"> | Date | string
    uniqueHash?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    status?: IntNullableWithAggregatesFilter<"Learner"> | number | null
    extraConfig?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    metaData?: StringNullableWithAggregatesFilter<"Learner"> | string | null
    role?: StringWithAggregatesFilter<"Learner"> | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: IntFilter<"Program"> | number
    authorId?: IntFilter<"Program"> | number
    title?: StringFilter<"Program"> | string
    description?: StringFilter<"Program"> | string
    category?: StringNullableFilter<"Program"> | string | null
    instructor?: StringNullableFilter<"Program"> | string | null
    instructorAvatar?: StringNullableFilter<"Program"> | string | null
    image?: StringNullableFilter<"Program"> | string | null
    rating?: FloatNullableFilter<"Program"> | number | null
    level?: StringNullableFilter<"Program"> | string | null
    price?: DecimalNullableFilter<"Program"> | Decimal | DecimalJsLike | number | string | null
    type?: EnumProgramTypeNullableFilter<"Program"> | $Enums.ProgramType | null
    totalTimeLimit?: IntNullableFilter<"Program"> | number | null
    status?: IntNullableFilter<"Program"> | number | null
    uniqueHash?: StringNullableFilter<"Program"> | string | null
    startDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    surveyStartDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    surveyEndDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    maxParticipants?: StringNullableFilter<"Program"> | string | null
    passingScore?: IntNullableFilter<"Program"> | number | null
    studySettings?: JsonNullableFilter<"Program">
    clientId?: IntNullableFilter<"Program"> | number | null
    packageId?: BigIntNullableFilter<"Program"> | bigint | number | null
    isActive?: BoolFilter<"Program"> | boolean
    isDeleted?: BoolFilter<"Program"> | boolean
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Program"> | Date | string | null
    enrollments?: EnrollmentListRelationFilter
    quizAssignments?: QuizAssignmentListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    leaderboards?: LeaderboardListRelationFilter
    programModules?: ProgramModuleListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrderInput | SortOrder
    instructor?: SortOrderInput | SortOrder
    instructorAvatar?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    totalTimeLimit?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    uniqueHash?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    surveyStartDate?: SortOrderInput | SortOrder
    surveyEndDate?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    passingScore?: SortOrderInput | SortOrder
    studySettings?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    enrollments?: EnrollmentOrderByRelationAggregateInput
    quizAssignments?: QuizAssignmentOrderByRelationAggregateInput
    measureProgress?: MeasureProgressOrderByRelationAggregateInput
    leaderboards?: LeaderboardOrderByRelationAggregateInput
    programModules?: ProgramModuleOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    authorId?: IntFilter<"Program"> | number
    title?: StringFilter<"Program"> | string
    description?: StringFilter<"Program"> | string
    category?: StringNullableFilter<"Program"> | string | null
    instructor?: StringNullableFilter<"Program"> | string | null
    instructorAvatar?: StringNullableFilter<"Program"> | string | null
    image?: StringNullableFilter<"Program"> | string | null
    rating?: FloatNullableFilter<"Program"> | number | null
    level?: StringNullableFilter<"Program"> | string | null
    price?: DecimalNullableFilter<"Program"> | Decimal | DecimalJsLike | number | string | null
    type?: EnumProgramTypeNullableFilter<"Program"> | $Enums.ProgramType | null
    totalTimeLimit?: IntNullableFilter<"Program"> | number | null
    status?: IntNullableFilter<"Program"> | number | null
    uniqueHash?: StringNullableFilter<"Program"> | string | null
    startDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    surveyStartDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    surveyEndDate?: DateTimeNullableFilter<"Program"> | Date | string | null
    maxParticipants?: StringNullableFilter<"Program"> | string | null
    passingScore?: IntNullableFilter<"Program"> | number | null
    studySettings?: JsonNullableFilter<"Program">
    clientId?: IntNullableFilter<"Program"> | number | null
    packageId?: BigIntNullableFilter<"Program"> | bigint | number | null
    isActive?: BoolFilter<"Program"> | boolean
    isDeleted?: BoolFilter<"Program"> | boolean
    createdAt?: DateTimeFilter<"Program"> | Date | string
    updatedAt?: DateTimeFilter<"Program"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Program"> | Date | string | null
    enrollments?: EnrollmentListRelationFilter
    quizAssignments?: QuizAssignmentListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    leaderboards?: LeaderboardListRelationFilter
    programModules?: ProgramModuleListRelationFilter
  }, "id">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrderInput | SortOrder
    instructor?: SortOrderInput | SortOrder
    instructorAvatar?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    totalTimeLimit?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    uniqueHash?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    surveyStartDate?: SortOrderInput | SortOrder
    surveyEndDate?: SortOrderInput | SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    passingScore?: SortOrderInput | SortOrder
    studySettings?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    packageId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Program"> | number
    authorId?: IntWithAggregatesFilter<"Program"> | number
    title?: StringWithAggregatesFilter<"Program"> | string
    description?: StringWithAggregatesFilter<"Program"> | string
    category?: StringNullableWithAggregatesFilter<"Program"> | string | null
    instructor?: StringNullableWithAggregatesFilter<"Program"> | string | null
    instructorAvatar?: StringNullableWithAggregatesFilter<"Program"> | string | null
    image?: StringNullableWithAggregatesFilter<"Program"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"Program"> | number | null
    level?: StringNullableWithAggregatesFilter<"Program"> | string | null
    price?: DecimalNullableWithAggregatesFilter<"Program"> | Decimal | DecimalJsLike | number | string | null
    type?: EnumProgramTypeNullableWithAggregatesFilter<"Program"> | $Enums.ProgramType | null
    totalTimeLimit?: IntNullableWithAggregatesFilter<"Program"> | number | null
    status?: IntNullableWithAggregatesFilter<"Program"> | number | null
    uniqueHash?: StringNullableWithAggregatesFilter<"Program"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    surveyStartDate?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    surveyEndDate?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    maxParticipants?: StringNullableWithAggregatesFilter<"Program"> | string | null
    passingScore?: IntNullableWithAggregatesFilter<"Program"> | number | null
    studySettings?: JsonNullableWithAggregatesFilter<"Program">
    clientId?: IntNullableWithAggregatesFilter<"Program"> | number | null
    packageId?: BigIntNullableWithAggregatesFilter<"Program"> | bigint | number | null
    isActive?: BoolWithAggregatesFilter<"Program"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Program"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
  }

  export type ModuleWhereInput = {
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    id?: IntFilter<"Module"> | number
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    prerequisiteModuleId?: IntNullableFilter<"Module"> | number | null
    status?: IntNullableFilter<"Module"> | number | null
    isDeleted?: BoolFilter<"Module"> | boolean
    deletedAt?: DateTimeNullableFilter<"Module"> | Date | string | null
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    prerequisiteModule?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    dependentModules?: ModuleListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    programModules?: ProgramModuleListRelationFilter
    moduleTopics?: ModuleTopicListRelationFilter
  }

  export type ModuleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    prerequisiteModuleId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prerequisiteModule?: ModuleOrderByWithRelationInput
    dependentModules?: ModuleOrderByRelationAggregateInput
    measureProgress?: MeasureProgressOrderByRelationAggregateInput
    programModules?: ProgramModuleOrderByRelationAggregateInput
    moduleTopics?: ModuleTopicOrderByRelationAggregateInput
  }

  export type ModuleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ModuleWhereInput | ModuleWhereInput[]
    OR?: ModuleWhereInput[]
    NOT?: ModuleWhereInput | ModuleWhereInput[]
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    prerequisiteModuleId?: IntNullableFilter<"Module"> | number | null
    status?: IntNullableFilter<"Module"> | number | null
    isDeleted?: BoolFilter<"Module"> | boolean
    deletedAt?: DateTimeNullableFilter<"Module"> | Date | string | null
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
    prerequisiteModule?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    dependentModules?: ModuleListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    programModules?: ProgramModuleListRelationFilter
    moduleTopics?: ModuleTopicListRelationFilter
  }, "id">

  export type ModuleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    prerequisiteModuleId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ModuleCountOrderByAggregateInput
    _avg?: ModuleAvgOrderByAggregateInput
    _max?: ModuleMaxOrderByAggregateInput
    _min?: ModuleMinOrderByAggregateInput
    _sum?: ModuleSumOrderByAggregateInput
  }

  export type ModuleScalarWhereWithAggregatesInput = {
    AND?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    OR?: ModuleScalarWhereWithAggregatesInput[]
    NOT?: ModuleScalarWhereWithAggregatesInput | ModuleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Module"> | number
    title?: StringWithAggregatesFilter<"Module"> | string
    description?: StringNullableWithAggregatesFilter<"Module"> | string | null
    prerequisiteModuleId?: IntNullableWithAggregatesFilter<"Module"> | number | null
    status?: IntNullableWithAggregatesFilter<"Module"> | number | null
    isDeleted?: BoolWithAggregatesFilter<"Module"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Module"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Module"> | Date | string
  }

  export type EnrollmentWhereInput = {
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    id?: IntFilter<"Enrollment"> | number
    learnerId?: IntFilter<"Enrollment"> | number
    programId?: IntFilter<"Enrollment"> | number
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
  }

  export type EnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    learnerId?: SortOrder
    programId?: SortOrder
    enrolledAt?: SortOrder
    learner?: LearnerOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
  }

  export type EnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    learnerId_programId?: EnrollmentLearnerIdProgramIdCompoundUniqueInput
    AND?: EnrollmentWhereInput | EnrollmentWhereInput[]
    OR?: EnrollmentWhereInput[]
    NOT?: EnrollmentWhereInput | EnrollmentWhereInput[]
    learnerId?: IntFilter<"Enrollment"> | number
    programId?: IntFilter<"Enrollment"> | number
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
  }, "id" | "learnerId_programId">

  export type EnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    learnerId?: SortOrder
    programId?: SortOrder
    enrolledAt?: SortOrder
    _count?: EnrollmentCountOrderByAggregateInput
    _avg?: EnrollmentAvgOrderByAggregateInput
    _max?: EnrollmentMaxOrderByAggregateInput
    _min?: EnrollmentMinOrderByAggregateInput
    _sum?: EnrollmentSumOrderByAggregateInput
  }

  export type EnrollmentScalarWhereWithAggregatesInput = {
    AND?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    OR?: EnrollmentScalarWhereWithAggregatesInput[]
    NOT?: EnrollmentScalarWhereWithAggregatesInput | EnrollmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Enrollment"> | number
    learnerId?: IntWithAggregatesFilter<"Enrollment"> | number
    programId?: IntWithAggregatesFilter<"Enrollment"> | number
    enrolledAt?: DateTimeWithAggregatesFilter<"Enrollment"> | Date | string
  }

  export type ProgramModuleWhereInput = {
    AND?: ProgramModuleWhereInput | ProgramModuleWhereInput[]
    OR?: ProgramModuleWhereInput[]
    NOT?: ProgramModuleWhereInput | ProgramModuleWhereInput[]
    programId?: IntFilter<"ProgramModule"> | number
    moduleId?: IntFilter<"ProgramModule"> | number
    position?: IntFilter<"ProgramModule"> | number
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
  }

  export type ProgramModuleOrderByWithRelationInput = {
    programId?: SortOrder
    moduleId?: SortOrder
    position?: SortOrder
    program?: ProgramOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
  }

  export type ProgramModuleWhereUniqueInput = Prisma.AtLeast<{
    programId_position?: ProgramModuleProgramIdPositionCompoundUniqueInput
    programId_moduleId?: ProgramModuleProgramIdModuleIdCompoundUniqueInput
    AND?: ProgramModuleWhereInput | ProgramModuleWhereInput[]
    OR?: ProgramModuleWhereInput[]
    NOT?: ProgramModuleWhereInput | ProgramModuleWhereInput[]
    programId?: IntFilter<"ProgramModule"> | number
    moduleId?: IntFilter<"ProgramModule"> | number
    position?: IntFilter<"ProgramModule"> | number
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
  }, "programId_moduleId" | "programId_position">

  export type ProgramModuleOrderByWithAggregationInput = {
    programId?: SortOrder
    moduleId?: SortOrder
    position?: SortOrder
    _count?: ProgramModuleCountOrderByAggregateInput
    _avg?: ProgramModuleAvgOrderByAggregateInput
    _max?: ProgramModuleMaxOrderByAggregateInput
    _min?: ProgramModuleMinOrderByAggregateInput
    _sum?: ProgramModuleSumOrderByAggregateInput
  }

  export type ProgramModuleScalarWhereWithAggregatesInput = {
    AND?: ProgramModuleScalarWhereWithAggregatesInput | ProgramModuleScalarWhereWithAggregatesInput[]
    OR?: ProgramModuleScalarWhereWithAggregatesInput[]
    NOT?: ProgramModuleScalarWhereWithAggregatesInput | ProgramModuleScalarWhereWithAggregatesInput[]
    programId?: IntWithAggregatesFilter<"ProgramModule"> | number
    moduleId?: IntWithAggregatesFilter<"ProgramModule"> | number
    position?: IntWithAggregatesFilter<"ProgramModule"> | number
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: IntFilter<"Topic"> | number
    title?: StringFilter<"Topic"> | string
    content?: StringNullableFilter<"Topic"> | string | null
    prerequisiteTopicId?: IntNullableFilter<"Topic"> | number | null
    status?: IntNullableFilter<"Topic"> | number | null
    isDeleted?: BoolFilter<"Topic"> | boolean
    deletedAt?: DateTimeNullableFilter<"Topic"> | Date | string | null
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    prerequisiteTopic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    dependentTopics?: TopicListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    moduleTopics?: ModuleTopicListRelationFilter
    topicResources?: TopicResourceListRelationFilter
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    prerequisiteTopicId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    prerequisiteTopic?: TopicOrderByWithRelationInput
    dependentTopics?: TopicOrderByRelationAggregateInput
    measureProgress?: MeasureProgressOrderByRelationAggregateInput
    moduleTopics?: ModuleTopicOrderByRelationAggregateInput
    topicResources?: TopicResourceOrderByRelationAggregateInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    title?: StringFilter<"Topic"> | string
    content?: StringNullableFilter<"Topic"> | string | null
    prerequisiteTopicId?: IntNullableFilter<"Topic"> | number | null
    status?: IntNullableFilter<"Topic"> | number | null
    isDeleted?: BoolFilter<"Topic"> | boolean
    deletedAt?: DateTimeNullableFilter<"Topic"> | Date | string | null
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
    prerequisiteTopic?: XOR<TopicNullableScalarRelationFilter, TopicWhereInput> | null
    dependentTopics?: TopicListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    moduleTopics?: ModuleTopicListRelationFilter
    topicResources?: TopicResourceListRelationFilter
  }, "id">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    prerequisiteTopicId?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _avg?: TopicAvgOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
    _sum?: TopicSumOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Topic"> | number
    title?: StringWithAggregatesFilter<"Topic"> | string
    content?: StringNullableWithAggregatesFilter<"Topic"> | string | null
    prerequisiteTopicId?: IntNullableWithAggregatesFilter<"Topic"> | number | null
    status?: IntNullableWithAggregatesFilter<"Topic"> | number | null
    isDeleted?: BoolWithAggregatesFilter<"Topic"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Topic"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Topic"> | Date | string
  }

  export type ModuleTopicWhereInput = {
    AND?: ModuleTopicWhereInput | ModuleTopicWhereInput[]
    OR?: ModuleTopicWhereInput[]
    NOT?: ModuleTopicWhereInput | ModuleTopicWhereInput[]
    moduleId?: IntFilter<"ModuleTopic"> | number
    topicId?: IntFilter<"ModuleTopic"> | number
    position?: IntFilter<"ModuleTopic"> | number
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }

  export type ModuleTopicOrderByWithRelationInput = {
    moduleId?: SortOrder
    topicId?: SortOrder
    position?: SortOrder
    module?: ModuleOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
  }

  export type ModuleTopicWhereUniqueInput = Prisma.AtLeast<{
    moduleId_position?: ModuleTopicModuleIdPositionCompoundUniqueInput
    moduleId_topicId?: ModuleTopicModuleIdTopicIdCompoundUniqueInput
    AND?: ModuleTopicWhereInput | ModuleTopicWhereInput[]
    OR?: ModuleTopicWhereInput[]
    NOT?: ModuleTopicWhereInput | ModuleTopicWhereInput[]
    moduleId?: IntFilter<"ModuleTopic"> | number
    topicId?: IntFilter<"ModuleTopic"> | number
    position?: IntFilter<"ModuleTopic"> | number
    module?: XOR<ModuleScalarRelationFilter, ModuleWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }, "moduleId_topicId" | "moduleId_position">

  export type ModuleTopicOrderByWithAggregationInput = {
    moduleId?: SortOrder
    topicId?: SortOrder
    position?: SortOrder
    _count?: ModuleTopicCountOrderByAggregateInput
    _avg?: ModuleTopicAvgOrderByAggregateInput
    _max?: ModuleTopicMaxOrderByAggregateInput
    _min?: ModuleTopicMinOrderByAggregateInput
    _sum?: ModuleTopicSumOrderByAggregateInput
  }

  export type ModuleTopicScalarWhereWithAggregatesInput = {
    AND?: ModuleTopicScalarWhereWithAggregatesInput | ModuleTopicScalarWhereWithAggregatesInput[]
    OR?: ModuleTopicScalarWhereWithAggregatesInput[]
    NOT?: ModuleTopicScalarWhereWithAggregatesInput | ModuleTopicScalarWhereWithAggregatesInput[]
    moduleId?: IntWithAggregatesFilter<"ModuleTopic"> | number
    topicId?: IntWithAggregatesFilter<"ModuleTopic"> | number
    position?: IntWithAggregatesFilter<"ModuleTopic"> | number
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: IntFilter<"Resource"> | number
    resourceType?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    url?: StringFilter<"Resource"> | string
    title?: StringNullableFilter<"Resource"> | string | null
    description?: StringNullableFilter<"Resource"> | string | null
    status?: IntNullableFilter<"Resource"> | number | null
    isDeleted?: BoolFilter<"Resource"> | boolean
    deletedAt?: DateTimeNullableFilter<"Resource"> | Date | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    resourceViews?: ResourceViewListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    topicResources?: TopicResourceListRelationFilter
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    resourceType?: SortOrder
    url?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    resourceViews?: ResourceViewOrderByRelationAggregateInput
    measureProgress?: MeasureProgressOrderByRelationAggregateInput
    topicResources?: TopicResourceOrderByRelationAggregateInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    resourceType?: EnumResourceTypeFilter<"Resource"> | $Enums.ResourceType
    url?: StringFilter<"Resource"> | string
    title?: StringNullableFilter<"Resource"> | string | null
    description?: StringNullableFilter<"Resource"> | string | null
    status?: IntNullableFilter<"Resource"> | number | null
    isDeleted?: BoolFilter<"Resource"> | boolean
    deletedAt?: DateTimeNullableFilter<"Resource"> | Date | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    resourceViews?: ResourceViewListRelationFilter
    measureProgress?: MeasureProgressListRelationFilter
    topicResources?: TopicResourceListRelationFilter
  }, "id">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    resourceType?: SortOrder
    url?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resource"> | number
    resourceType?: EnumResourceTypeWithAggregatesFilter<"Resource"> | $Enums.ResourceType
    url?: StringWithAggregatesFilter<"Resource"> | string
    title?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    status?: IntNullableWithAggregatesFilter<"Resource"> | number | null
    isDeleted?: BoolWithAggregatesFilter<"Resource"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Resource"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type TopicResourceWhereInput = {
    AND?: TopicResourceWhereInput | TopicResourceWhereInput[]
    OR?: TopicResourceWhereInput[]
    NOT?: TopicResourceWhereInput | TopicResourceWhereInput[]
    topicId?: IntFilter<"TopicResource"> | number
    resourceId?: IntFilter<"TopicResource"> | number
    position?: IntFilter<"TopicResource"> | number
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }

  export type TopicResourceOrderByWithRelationInput = {
    topicId?: SortOrder
    resourceId?: SortOrder
    position?: SortOrder
    topic?: TopicOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type TopicResourceWhereUniqueInput = Prisma.AtLeast<{
    topicId_position?: TopicResourceTopicIdPositionCompoundUniqueInput
    topicId_resourceId?: TopicResourceTopicIdResourceIdCompoundUniqueInput
    AND?: TopicResourceWhereInput | TopicResourceWhereInput[]
    OR?: TopicResourceWhereInput[]
    NOT?: TopicResourceWhereInput | TopicResourceWhereInput[]
    topicId?: IntFilter<"TopicResource"> | number
    resourceId?: IntFilter<"TopicResource"> | number
    position?: IntFilter<"TopicResource"> | number
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }, "topicId_resourceId" | "topicId_position">

  export type TopicResourceOrderByWithAggregationInput = {
    topicId?: SortOrder
    resourceId?: SortOrder
    position?: SortOrder
    _count?: TopicResourceCountOrderByAggregateInput
    _avg?: TopicResourceAvgOrderByAggregateInput
    _max?: TopicResourceMaxOrderByAggregateInput
    _min?: TopicResourceMinOrderByAggregateInput
    _sum?: TopicResourceSumOrderByAggregateInput
  }

  export type TopicResourceScalarWhereWithAggregatesInput = {
    AND?: TopicResourceScalarWhereWithAggregatesInput | TopicResourceScalarWhereWithAggregatesInput[]
    OR?: TopicResourceScalarWhereWithAggregatesInput[]
    NOT?: TopicResourceScalarWhereWithAggregatesInput | TopicResourceScalarWhereWithAggregatesInput[]
    topicId?: IntWithAggregatesFilter<"TopicResource"> | number
    resourceId?: IntWithAggregatesFilter<"TopicResource"> | number
    position?: IntWithAggregatesFilter<"TopicResource"> | number
  }

  export type QuestionPoolWhereInput = {
    AND?: QuestionPoolWhereInput | QuestionPoolWhereInput[]
    OR?: QuestionPoolWhereInput[]
    NOT?: QuestionPoolWhereInput | QuestionPoolWhereInput[]
    id?: IntFilter<"QuestionPool"> | number
    authorId?: IntFilter<"QuestionPool"> | number
    questionText?: StringFilter<"QuestionPool"> | string
    questionType?: EnumQuestionTypeFilter<"QuestionPool"> | $Enums.QuestionType
    metadata?: JsonNullableFilter<"QuestionPool">
    explanation?: StringNullableFilter<"QuestionPool"> | string | null
    timeLimitSec?: IntNullableFilter<"QuestionPool"> | number | null
    points?: IntFilter<"QuestionPool"> | number
    option1?: StringNullableFilter<"QuestionPool"> | string | null
    option2?: StringNullableFilter<"QuestionPool"> | string | null
    option3?: StringNullableFilter<"QuestionPool"> | string | null
    option4?: StringNullableFilter<"QuestionPool"> | string | null
    option5?: StringNullableFilter<"QuestionPool"> | string | null
    option6?: StringNullableFilter<"QuestionPool"> | string | null
    answer?: StringNullableFilter<"QuestionPool"> | string | null
    createdAt?: DateTimeFilter<"QuestionPool"> | Date | string
    author?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    quizPaperQuestions?: QuizPaperQuestionListRelationFilter
    questionAttempts?: QuestionAttemptListRelationFilter
  }

  export type QuestionPoolOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    explanation?: SortOrderInput | SortOrder
    timeLimitSec?: SortOrderInput | SortOrder
    points?: SortOrder
    option1?: SortOrderInput | SortOrder
    option2?: SortOrderInput | SortOrder
    option3?: SortOrderInput | SortOrder
    option4?: SortOrderInput | SortOrder
    option5?: SortOrderInput | SortOrder
    option6?: SortOrderInput | SortOrder
    answer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    author?: AdminOrderByWithRelationInput
    quizPaperQuestions?: QuizPaperQuestionOrderByRelationAggregateInput
    questionAttempts?: QuestionAttemptOrderByRelationAggregateInput
  }

  export type QuestionPoolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuestionPoolWhereInput | QuestionPoolWhereInput[]
    OR?: QuestionPoolWhereInput[]
    NOT?: QuestionPoolWhereInput | QuestionPoolWhereInput[]
    authorId?: IntFilter<"QuestionPool"> | number
    questionText?: StringFilter<"QuestionPool"> | string
    questionType?: EnumQuestionTypeFilter<"QuestionPool"> | $Enums.QuestionType
    metadata?: JsonNullableFilter<"QuestionPool">
    explanation?: StringNullableFilter<"QuestionPool"> | string | null
    timeLimitSec?: IntNullableFilter<"QuestionPool"> | number | null
    points?: IntFilter<"QuestionPool"> | number
    option1?: StringNullableFilter<"QuestionPool"> | string | null
    option2?: StringNullableFilter<"QuestionPool"> | string | null
    option3?: StringNullableFilter<"QuestionPool"> | string | null
    option4?: StringNullableFilter<"QuestionPool"> | string | null
    option5?: StringNullableFilter<"QuestionPool"> | string | null
    option6?: StringNullableFilter<"QuestionPool"> | string | null
    answer?: StringNullableFilter<"QuestionPool"> | string | null
    createdAt?: DateTimeFilter<"QuestionPool"> | Date | string
    author?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    quizPaperQuestions?: QuizPaperQuestionListRelationFilter
    questionAttempts?: QuestionAttemptListRelationFilter
  }, "id">

  export type QuestionPoolOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    metadata?: SortOrderInput | SortOrder
    explanation?: SortOrderInput | SortOrder
    timeLimitSec?: SortOrderInput | SortOrder
    points?: SortOrder
    option1?: SortOrderInput | SortOrder
    option2?: SortOrderInput | SortOrder
    option3?: SortOrderInput | SortOrder
    option4?: SortOrderInput | SortOrder
    option5?: SortOrderInput | SortOrder
    option6?: SortOrderInput | SortOrder
    answer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuestionPoolCountOrderByAggregateInput
    _avg?: QuestionPoolAvgOrderByAggregateInput
    _max?: QuestionPoolMaxOrderByAggregateInput
    _min?: QuestionPoolMinOrderByAggregateInput
    _sum?: QuestionPoolSumOrderByAggregateInput
  }

  export type QuestionPoolScalarWhereWithAggregatesInput = {
    AND?: QuestionPoolScalarWhereWithAggregatesInput | QuestionPoolScalarWhereWithAggregatesInput[]
    OR?: QuestionPoolScalarWhereWithAggregatesInput[]
    NOT?: QuestionPoolScalarWhereWithAggregatesInput | QuestionPoolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuestionPool"> | number
    authorId?: IntWithAggregatesFilter<"QuestionPool"> | number
    questionText?: StringWithAggregatesFilter<"QuestionPool"> | string
    questionType?: EnumQuestionTypeWithAggregatesFilter<"QuestionPool"> | $Enums.QuestionType
    metadata?: JsonNullableWithAggregatesFilter<"QuestionPool">
    explanation?: StringNullableWithAggregatesFilter<"QuestionPool"> | string | null
    timeLimitSec?: IntNullableWithAggregatesFilter<"QuestionPool"> | number | null
    points?: IntWithAggregatesFilter<"QuestionPool"> | number
    option1?: StringNullableWithAggregatesFilter<"QuestionPool"> | string | null
    option2?: StringNullableWithAggregatesFilter<"QuestionPool"> | string | null
    option3?: StringNullableWithAggregatesFilter<"QuestionPool"> | string | null
    option4?: StringNullableWithAggregatesFilter<"QuestionPool"> | string | null
    option5?: StringNullableWithAggregatesFilter<"QuestionPool"> | string | null
    option6?: StringNullableWithAggregatesFilter<"QuestionPool"> | string | null
    answer?: StringNullableWithAggregatesFilter<"QuestionPool"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuestionPool"> | Date | string
  }

  export type QuizPaperWhereInput = {
    AND?: QuizPaperWhereInput | QuizPaperWhereInput[]
    OR?: QuizPaperWhereInput[]
    NOT?: QuizPaperWhereInput | QuizPaperWhereInput[]
    id?: IntFilter<"QuizPaper"> | number
    authorId?: IntFilter<"QuizPaper"> | number
    title?: StringFilter<"QuizPaper"> | string
    createdAt?: DateTimeFilter<"QuizPaper"> | Date | string
    author?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    questions?: QuizPaperQuestionListRelationFilter
    assignments?: QuizAssignmentListRelationFilter
  }

  export type QuizPaperOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    author?: AdminOrderByWithRelationInput
    questions?: QuizPaperQuestionOrderByRelationAggregateInput
    assignments?: QuizAssignmentOrderByRelationAggregateInput
  }

  export type QuizPaperWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizPaperWhereInput | QuizPaperWhereInput[]
    OR?: QuizPaperWhereInput[]
    NOT?: QuizPaperWhereInput | QuizPaperWhereInput[]
    authorId?: IntFilter<"QuizPaper"> | number
    title?: StringFilter<"QuizPaper"> | string
    createdAt?: DateTimeFilter<"QuizPaper"> | Date | string
    author?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    questions?: QuizPaperQuestionListRelationFilter
    assignments?: QuizAssignmentListRelationFilter
  }, "id">

  export type QuizPaperOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    _count?: QuizPaperCountOrderByAggregateInput
    _avg?: QuizPaperAvgOrderByAggregateInput
    _max?: QuizPaperMaxOrderByAggregateInput
    _min?: QuizPaperMinOrderByAggregateInput
    _sum?: QuizPaperSumOrderByAggregateInput
  }

  export type QuizPaperScalarWhereWithAggregatesInput = {
    AND?: QuizPaperScalarWhereWithAggregatesInput | QuizPaperScalarWhereWithAggregatesInput[]
    OR?: QuizPaperScalarWhereWithAggregatesInput[]
    NOT?: QuizPaperScalarWhereWithAggregatesInput | QuizPaperScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizPaper"> | number
    authorId?: IntWithAggregatesFilter<"QuizPaper"> | number
    title?: StringWithAggregatesFilter<"QuizPaper"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuizPaper"> | Date | string
  }

  export type QuizPaperQuestionWhereInput = {
    AND?: QuizPaperQuestionWhereInput | QuizPaperQuestionWhereInput[]
    OR?: QuizPaperQuestionWhereInput[]
    NOT?: QuizPaperQuestionWhereInput | QuizPaperQuestionWhereInput[]
    quizPaperId?: IntFilter<"QuizPaperQuestion"> | number
    questionId?: IntFilter<"QuizPaperQuestion"> | number
    position?: IntNullableFilter<"QuizPaperQuestion"> | number | null
    timeMode?: BoolFilter<"QuizPaperQuestion"> | boolean
    timeLimit?: IntNullableFilter<"QuizPaperQuestion"> | number | null
    quizPaper?: XOR<QuizPaperScalarRelationFilter, QuizPaperWhereInput>
    question?: XOR<QuestionPoolScalarRelationFilter, QuestionPoolWhereInput>
  }

  export type QuizPaperQuestionOrderByWithRelationInput = {
    quizPaperId?: SortOrder
    questionId?: SortOrder
    position?: SortOrderInput | SortOrder
    timeMode?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    quizPaper?: QuizPaperOrderByWithRelationInput
    question?: QuestionPoolOrderByWithRelationInput
  }

  export type QuizPaperQuestionWhereUniqueInput = Prisma.AtLeast<{
    quizPaperId_questionId?: QuizPaperQuestionQuizPaperIdQuestionIdCompoundUniqueInput
    AND?: QuizPaperQuestionWhereInput | QuizPaperQuestionWhereInput[]
    OR?: QuizPaperQuestionWhereInput[]
    NOT?: QuizPaperQuestionWhereInput | QuizPaperQuestionWhereInput[]
    quizPaperId?: IntFilter<"QuizPaperQuestion"> | number
    questionId?: IntFilter<"QuizPaperQuestion"> | number
    position?: IntNullableFilter<"QuizPaperQuestion"> | number | null
    timeMode?: BoolFilter<"QuizPaperQuestion"> | boolean
    timeLimit?: IntNullableFilter<"QuizPaperQuestion"> | number | null
    quizPaper?: XOR<QuizPaperScalarRelationFilter, QuizPaperWhereInput>
    question?: XOR<QuestionPoolScalarRelationFilter, QuestionPoolWhereInput>
  }, "quizPaperId_questionId" | "quizPaperId_questionId">

  export type QuizPaperQuestionOrderByWithAggregationInput = {
    quizPaperId?: SortOrder
    questionId?: SortOrder
    position?: SortOrderInput | SortOrder
    timeMode?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    _count?: QuizPaperQuestionCountOrderByAggregateInput
    _avg?: QuizPaperQuestionAvgOrderByAggregateInput
    _max?: QuizPaperQuestionMaxOrderByAggregateInput
    _min?: QuizPaperQuestionMinOrderByAggregateInput
    _sum?: QuizPaperQuestionSumOrderByAggregateInput
  }

  export type QuizPaperQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizPaperQuestionScalarWhereWithAggregatesInput | QuizPaperQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizPaperQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizPaperQuestionScalarWhereWithAggregatesInput | QuizPaperQuestionScalarWhereWithAggregatesInput[]
    quizPaperId?: IntWithAggregatesFilter<"QuizPaperQuestion"> | number
    questionId?: IntWithAggregatesFilter<"QuizPaperQuestion"> | number
    position?: IntNullableWithAggregatesFilter<"QuizPaperQuestion"> | number | null
    timeMode?: BoolWithAggregatesFilter<"QuizPaperQuestion"> | boolean
    timeLimit?: IntNullableWithAggregatesFilter<"QuizPaperQuestion"> | number | null
  }

  export type QuizAssignmentWhereInput = {
    AND?: QuizAssignmentWhereInput | QuizAssignmentWhereInput[]
    OR?: QuizAssignmentWhereInput[]
    NOT?: QuizAssignmentWhereInput | QuizAssignmentWhereInput[]
    id?: IntFilter<"QuizAssignment"> | number
    quizPaperId?: IntFilter<"QuizAssignment"> | number
    programId?: IntNullableFilter<"QuizAssignment"> | number | null
    startAt?: DateTimeNullableFilter<"QuizAssignment"> | Date | string | null
    endAt?: DateTimeNullableFilter<"QuizAssignment"> | Date | string | null
    uniqueLinkToken?: UuidFilter<"QuizAssignment"> | string
    timeMode?: EnumTimeModeFilter<"QuizAssignment"> | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFilter<"QuizAssignment"> | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFilter<"QuizAssignment"> | $Enums.ResultMode
    totalTimeLimit?: IntNullableFilter<"QuizAssignment"> | number | null
    passingScore?: IntNullableFilter<"QuizAssignment"> | number | null
    enabled?: BoolFilter<"QuizAssignment"> | boolean
    isDeleted?: BoolFilter<"QuizAssignment"> | boolean
    deletedAt?: DateTimeNullableFilter<"QuizAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"QuizAssignment"> | Date | string
    quizPaper?: XOR<QuizPaperScalarRelationFilter, QuizPaperWhereInput>
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    quizAttempts?: QuizAttemptListRelationFilter
  }

  export type QuizAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    quizPaperId?: SortOrder
    programId?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    uniqueLinkToken?: SortOrder
    timeMode?: SortOrder
    wrongAnsMode?: SortOrder
    resultMode?: SortOrder
    totalTimeLimit?: SortOrderInput | SortOrder
    passingScore?: SortOrderInput | SortOrder
    enabled?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    quizPaper?: QuizPaperOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
    quizAttempts?: QuizAttemptOrderByRelationAggregateInput
  }

  export type QuizAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uniqueLinkToken?: string
    AND?: QuizAssignmentWhereInput | QuizAssignmentWhereInput[]
    OR?: QuizAssignmentWhereInput[]
    NOT?: QuizAssignmentWhereInput | QuizAssignmentWhereInput[]
    quizPaperId?: IntFilter<"QuizAssignment"> | number
    programId?: IntNullableFilter<"QuizAssignment"> | number | null
    startAt?: DateTimeNullableFilter<"QuizAssignment"> | Date | string | null
    endAt?: DateTimeNullableFilter<"QuizAssignment"> | Date | string | null
    timeMode?: EnumTimeModeFilter<"QuizAssignment"> | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFilter<"QuizAssignment"> | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFilter<"QuizAssignment"> | $Enums.ResultMode
    totalTimeLimit?: IntNullableFilter<"QuizAssignment"> | number | null
    passingScore?: IntNullableFilter<"QuizAssignment"> | number | null
    enabled?: BoolFilter<"QuizAssignment"> | boolean
    isDeleted?: BoolFilter<"QuizAssignment"> | boolean
    deletedAt?: DateTimeNullableFilter<"QuizAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"QuizAssignment"> | Date | string
    quizPaper?: XOR<QuizPaperScalarRelationFilter, QuizPaperWhereInput>
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    quizAttempts?: QuizAttemptListRelationFilter
  }, "id" | "uniqueLinkToken">

  export type QuizAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    quizPaperId?: SortOrder
    programId?: SortOrderInput | SortOrder
    startAt?: SortOrderInput | SortOrder
    endAt?: SortOrderInput | SortOrder
    uniqueLinkToken?: SortOrder
    timeMode?: SortOrder
    wrongAnsMode?: SortOrder
    resultMode?: SortOrder
    totalTimeLimit?: SortOrderInput | SortOrder
    passingScore?: SortOrderInput | SortOrder
    enabled?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuizAssignmentCountOrderByAggregateInput
    _avg?: QuizAssignmentAvgOrderByAggregateInput
    _max?: QuizAssignmentMaxOrderByAggregateInput
    _min?: QuizAssignmentMinOrderByAggregateInput
    _sum?: QuizAssignmentSumOrderByAggregateInput
  }

  export type QuizAssignmentScalarWhereWithAggregatesInput = {
    AND?: QuizAssignmentScalarWhereWithAggregatesInput | QuizAssignmentScalarWhereWithAggregatesInput[]
    OR?: QuizAssignmentScalarWhereWithAggregatesInput[]
    NOT?: QuizAssignmentScalarWhereWithAggregatesInput | QuizAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizAssignment"> | number
    quizPaperId?: IntWithAggregatesFilter<"QuizAssignment"> | number
    programId?: IntNullableWithAggregatesFilter<"QuizAssignment"> | number | null
    startAt?: DateTimeNullableWithAggregatesFilter<"QuizAssignment"> | Date | string | null
    endAt?: DateTimeNullableWithAggregatesFilter<"QuizAssignment"> | Date | string | null
    uniqueLinkToken?: UuidWithAggregatesFilter<"QuizAssignment"> | string
    timeMode?: EnumTimeModeWithAggregatesFilter<"QuizAssignment"> | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeWithAggregatesFilter<"QuizAssignment"> | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeWithAggregatesFilter<"QuizAssignment"> | $Enums.ResultMode
    totalTimeLimit?: IntNullableWithAggregatesFilter<"QuizAssignment"> | number | null
    passingScore?: IntNullableWithAggregatesFilter<"QuizAssignment"> | number | null
    enabled?: BoolWithAggregatesFilter<"QuizAssignment"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"QuizAssignment"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"QuizAssignment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuizAssignment"> | Date | string
  }

  export type QuizAttemptWhereInput = {
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    id?: IntFilter<"QuizAttempt"> | number
    assignmentId?: IntFilter<"QuizAttempt"> | number
    learnerId?: IntFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    totalTimeSpent?: IntNullableFilter<"QuizAttempt"> | number | null
    score?: DecimalNullableFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    passed?: BoolNullableFilter<"QuizAttempt"> | boolean | null
    status?: StringFilter<"QuizAttempt"> | string
    createdAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    assignment?: XOR<QuizAssignmentScalarRelationFilter, QuizAssignmentWhereInput>
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
    questionAttempts?: QuestionAttemptListRelationFilter
  }

  export type QuizAttemptOrderByWithRelationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    learnerId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    totalTimeSpent?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    assignment?: QuizAssignmentOrderByWithRelationInput
    learner?: LearnerOrderByWithRelationInput
    questionAttempts?: QuestionAttemptOrderByRelationAggregateInput
  }

  export type QuizAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    assignmentId?: IntFilter<"QuizAttempt"> | number
    learnerId?: IntFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    totalTimeSpent?: IntNullableFilter<"QuizAttempt"> | number | null
    score?: DecimalNullableFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    passed?: BoolNullableFilter<"QuizAttempt"> | boolean | null
    status?: StringFilter<"QuizAttempt"> | string
    createdAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    assignment?: XOR<QuizAssignmentScalarRelationFilter, QuizAssignmentWhereInput>
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
    questionAttempts?: QuestionAttemptListRelationFilter
  }, "id">

  export type QuizAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    learnerId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    totalTimeSpent?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    passed?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: QuizAttemptCountOrderByAggregateInput
    _avg?: QuizAttemptAvgOrderByAggregateInput
    _max?: QuizAttemptMaxOrderByAggregateInput
    _min?: QuizAttemptMinOrderByAggregateInput
    _sum?: QuizAttemptSumOrderByAggregateInput
  }

  export type QuizAttemptScalarWhereWithAggregatesInput = {
    AND?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    OR?: QuizAttemptScalarWhereWithAggregatesInput[]
    NOT?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"QuizAttempt"> | number
    assignmentId?: IntWithAggregatesFilter<"QuizAttempt"> | number
    learnerId?: IntWithAggregatesFilter<"QuizAttempt"> | number
    startedAt?: DateTimeWithAggregatesFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"QuizAttempt"> | Date | string | null
    totalTimeSpent?: IntNullableWithAggregatesFilter<"QuizAttempt"> | number | null
    score?: DecimalNullableWithAggregatesFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    passed?: BoolNullableWithAggregatesFilter<"QuizAttempt"> | boolean | null
    status?: StringWithAggregatesFilter<"QuizAttempt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuizAttempt"> | Date | string
  }

  export type QuestionAttemptWhereInput = {
    AND?: QuestionAttemptWhereInput | QuestionAttemptWhereInput[]
    OR?: QuestionAttemptWhereInput[]
    NOT?: QuestionAttemptWhereInput | QuestionAttemptWhereInput[]
    attemptId?: IntFilter<"QuestionAttempt"> | number
    questionId?: IntFilter<"QuestionAttempt"> | number
    answerText?: StringNullableFilter<"QuestionAttempt"> | string | null
    isCorrect?: BoolFilter<"QuestionAttempt"> | boolean
    timeTakenSec?: IntNullableFilter<"QuestionAttempt"> | number | null
    attempt?: XOR<QuizAttemptScalarRelationFilter, QuizAttemptWhereInput>
    question?: XOR<QuestionPoolScalarRelationFilter, QuestionPoolWhereInput>
  }

  export type QuestionAttemptOrderByWithRelationInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    answerText?: SortOrderInput | SortOrder
    isCorrect?: SortOrder
    timeTakenSec?: SortOrderInput | SortOrder
    attempt?: QuizAttemptOrderByWithRelationInput
    question?: QuestionPoolOrderByWithRelationInput
  }

  export type QuestionAttemptWhereUniqueInput = Prisma.AtLeast<{
    attemptId_questionId?: QuestionAttemptAttemptIdQuestionIdCompoundUniqueInput
    AND?: QuestionAttemptWhereInput | QuestionAttemptWhereInput[]
    OR?: QuestionAttemptWhereInput[]
    NOT?: QuestionAttemptWhereInput | QuestionAttemptWhereInput[]
    attemptId?: IntFilter<"QuestionAttempt"> | number
    questionId?: IntFilter<"QuestionAttempt"> | number
    answerText?: StringNullableFilter<"QuestionAttempt"> | string | null
    isCorrect?: BoolFilter<"QuestionAttempt"> | boolean
    timeTakenSec?: IntNullableFilter<"QuestionAttempt"> | number | null
    attempt?: XOR<QuizAttemptScalarRelationFilter, QuizAttemptWhereInput>
    question?: XOR<QuestionPoolScalarRelationFilter, QuestionPoolWhereInput>
  }, "attemptId_questionId">

  export type QuestionAttemptOrderByWithAggregationInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    answerText?: SortOrderInput | SortOrder
    isCorrect?: SortOrder
    timeTakenSec?: SortOrderInput | SortOrder
    _count?: QuestionAttemptCountOrderByAggregateInput
    _avg?: QuestionAttemptAvgOrderByAggregateInput
    _max?: QuestionAttemptMaxOrderByAggregateInput
    _min?: QuestionAttemptMinOrderByAggregateInput
    _sum?: QuestionAttemptSumOrderByAggregateInput
  }

  export type QuestionAttemptScalarWhereWithAggregatesInput = {
    AND?: QuestionAttemptScalarWhereWithAggregatesInput | QuestionAttemptScalarWhereWithAggregatesInput[]
    OR?: QuestionAttemptScalarWhereWithAggregatesInput[]
    NOT?: QuestionAttemptScalarWhereWithAggregatesInput | QuestionAttemptScalarWhereWithAggregatesInput[]
    attemptId?: IntWithAggregatesFilter<"QuestionAttempt"> | number
    questionId?: IntWithAggregatesFilter<"QuestionAttempt"> | number
    answerText?: StringNullableWithAggregatesFilter<"QuestionAttempt"> | string | null
    isCorrect?: BoolWithAggregatesFilter<"QuestionAttempt"> | boolean
    timeTakenSec?: IntNullableWithAggregatesFilter<"QuestionAttempt"> | number | null
  }

  export type ResourceViewWhereInput = {
    AND?: ResourceViewWhereInput | ResourceViewWhereInput[]
    OR?: ResourceViewWhereInput[]
    NOT?: ResourceViewWhereInput | ResourceViewWhereInput[]
    learnerId?: IntFilter<"ResourceView"> | number
    resourceId?: IntFilter<"ResourceView"> | number
    viewedAt?: DateTimeFilter<"ResourceView"> | Date | string
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }

  export type ResourceViewOrderByWithRelationInput = {
    learnerId?: SortOrder
    resourceId?: SortOrder
    viewedAt?: SortOrder
    learner?: LearnerOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type ResourceViewWhereUniqueInput = Prisma.AtLeast<{
    learnerId_resourceId?: ResourceViewLearnerIdResourceIdCompoundUniqueInput
    AND?: ResourceViewWhereInput | ResourceViewWhereInput[]
    OR?: ResourceViewWhereInput[]
    NOT?: ResourceViewWhereInput | ResourceViewWhereInput[]
    learnerId?: IntFilter<"ResourceView"> | number
    resourceId?: IntFilter<"ResourceView"> | number
    viewedAt?: DateTimeFilter<"ResourceView"> | Date | string
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
    resource?: XOR<ResourceScalarRelationFilter, ResourceWhereInput>
  }, "learnerId_resourceId">

  export type ResourceViewOrderByWithAggregationInput = {
    learnerId?: SortOrder
    resourceId?: SortOrder
    viewedAt?: SortOrder
    _count?: ResourceViewCountOrderByAggregateInput
    _avg?: ResourceViewAvgOrderByAggregateInput
    _max?: ResourceViewMaxOrderByAggregateInput
    _min?: ResourceViewMinOrderByAggregateInput
    _sum?: ResourceViewSumOrderByAggregateInput
  }

  export type ResourceViewScalarWhereWithAggregatesInput = {
    AND?: ResourceViewScalarWhereWithAggregatesInput | ResourceViewScalarWhereWithAggregatesInput[]
    OR?: ResourceViewScalarWhereWithAggregatesInput[]
    NOT?: ResourceViewScalarWhereWithAggregatesInput | ResourceViewScalarWhereWithAggregatesInput[]
    learnerId?: IntWithAggregatesFilter<"ResourceView"> | number
    resourceId?: IntWithAggregatesFilter<"ResourceView"> | number
    viewedAt?: DateTimeWithAggregatesFilter<"ResourceView"> | Date | string
  }

  export type MeasureProgressWhereInput = {
    AND?: MeasureProgressWhereInput | MeasureProgressWhereInput[]
    OR?: MeasureProgressWhereInput[]
    NOT?: MeasureProgressWhereInput | MeasureProgressWhereInput[]
    learnerId?: IntFilter<"MeasureProgress"> | number
    topicId?: IntFilter<"MeasureProgress"> | number
    completedAt?: DateTimeFilter<"MeasureProgress"> | Date | string
    progressType?: StringFilter<"MeasureProgress"> | string
    status?: StringFilter<"MeasureProgress"> | string
    programId?: IntNullableFilter<"MeasureProgress"> | number | null
    moduleId?: IntNullableFilter<"MeasureProgress"> | number | null
    resourceId?: IntNullableFilter<"MeasureProgress"> | number | null
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    resource?: XOR<ResourceNullableScalarRelationFilter, ResourceWhereInput> | null
  }

  export type MeasureProgressOrderByWithRelationInput = {
    learnerId?: SortOrder
    topicId?: SortOrder
    completedAt?: SortOrder
    progressType?: SortOrder
    status?: SortOrder
    programId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    learner?: LearnerOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
    program?: ProgramOrderByWithRelationInput
    module?: ModuleOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type MeasureProgressWhereUniqueInput = Prisma.AtLeast<{
    learnerId_topicId?: MeasureProgressLearnerIdTopicIdCompoundUniqueInput
    AND?: MeasureProgressWhereInput | MeasureProgressWhereInput[]
    OR?: MeasureProgressWhereInput[]
    NOT?: MeasureProgressWhereInput | MeasureProgressWhereInput[]
    learnerId?: IntFilter<"MeasureProgress"> | number
    topicId?: IntFilter<"MeasureProgress"> | number
    completedAt?: DateTimeFilter<"MeasureProgress"> | Date | string
    progressType?: StringFilter<"MeasureProgress"> | string
    status?: StringFilter<"MeasureProgress"> | string
    programId?: IntNullableFilter<"MeasureProgress"> | number | null
    moduleId?: IntNullableFilter<"MeasureProgress"> | number | null
    resourceId?: IntNullableFilter<"MeasureProgress"> | number | null
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
    program?: XOR<ProgramNullableScalarRelationFilter, ProgramWhereInput> | null
    module?: XOR<ModuleNullableScalarRelationFilter, ModuleWhereInput> | null
    resource?: XOR<ResourceNullableScalarRelationFilter, ResourceWhereInput> | null
  }, "learnerId_topicId">

  export type MeasureProgressOrderByWithAggregationInput = {
    learnerId?: SortOrder
    topicId?: SortOrder
    completedAt?: SortOrder
    progressType?: SortOrder
    status?: SortOrder
    programId?: SortOrderInput | SortOrder
    moduleId?: SortOrderInput | SortOrder
    resourceId?: SortOrderInput | SortOrder
    _count?: MeasureProgressCountOrderByAggregateInput
    _avg?: MeasureProgressAvgOrderByAggregateInput
    _max?: MeasureProgressMaxOrderByAggregateInput
    _min?: MeasureProgressMinOrderByAggregateInput
    _sum?: MeasureProgressSumOrderByAggregateInput
  }

  export type MeasureProgressScalarWhereWithAggregatesInput = {
    AND?: MeasureProgressScalarWhereWithAggregatesInput | MeasureProgressScalarWhereWithAggregatesInput[]
    OR?: MeasureProgressScalarWhereWithAggregatesInput[]
    NOT?: MeasureProgressScalarWhereWithAggregatesInput | MeasureProgressScalarWhereWithAggregatesInput[]
    learnerId?: IntWithAggregatesFilter<"MeasureProgress"> | number
    topicId?: IntWithAggregatesFilter<"MeasureProgress"> | number
    completedAt?: DateTimeWithAggregatesFilter<"MeasureProgress"> | Date | string
    progressType?: StringWithAggregatesFilter<"MeasureProgress"> | string
    status?: StringWithAggregatesFilter<"MeasureProgress"> | string
    programId?: IntNullableWithAggregatesFilter<"MeasureProgress"> | number | null
    moduleId?: IntNullableWithAggregatesFilter<"MeasureProgress"> | number | null
    resourceId?: IntNullableWithAggregatesFilter<"MeasureProgress"> | number | null
  }

  export type LeaderboardWhereInput = {
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    programId?: IntFilter<"Leaderboard"> | number
    learnerId?: IntFilter<"Leaderboard"> | number
    totalScore?: DecimalFilter<"Leaderboard"> | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: DateTimeNullableFilter<"Leaderboard"> | Date | string | null
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
  }

  export type LeaderboardOrderByWithRelationInput = {
    programId?: SortOrder
    learnerId?: SortOrder
    totalScore?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    program?: ProgramOrderByWithRelationInput
    learner?: LearnerOrderByWithRelationInput
  }

  export type LeaderboardWhereUniqueInput = Prisma.AtLeast<{
    programId_learnerId?: LeaderboardProgramIdLearnerIdCompoundUniqueInput
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    programId?: IntFilter<"Leaderboard"> | number
    learnerId?: IntFilter<"Leaderboard"> | number
    totalScore?: DecimalFilter<"Leaderboard"> | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: DateTimeNullableFilter<"Leaderboard"> | Date | string | null
    program?: XOR<ProgramScalarRelationFilter, ProgramWhereInput>
    learner?: XOR<LearnerScalarRelationFilter, LearnerWhereInput>
  }, "programId_learnerId">

  export type LeaderboardOrderByWithAggregationInput = {
    programId?: SortOrder
    learnerId?: SortOrder
    totalScore?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    _count?: LeaderboardCountOrderByAggregateInput
    _avg?: LeaderboardAvgOrderByAggregateInput
    _max?: LeaderboardMaxOrderByAggregateInput
    _min?: LeaderboardMinOrderByAggregateInput
    _sum?: LeaderboardSumOrderByAggregateInput
  }

  export type LeaderboardScalarWhereWithAggregatesInput = {
    AND?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    OR?: LeaderboardScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    programId?: IntWithAggregatesFilter<"Leaderboard"> | number
    learnerId?: IntWithAggregatesFilter<"Leaderboard"> | number
    totalScore?: DecimalWithAggregatesFilter<"Leaderboard"> | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"Leaderboard"> | Date | string | null
  }

  export type AdminCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: AdminCreateNestedOneWithoutCreatedAdminsInput
    createdAdmins?: AdminCreateNestedManyWithoutCreatorInput
    questions?: QuestionPoolCreateNestedManyWithoutAuthorInput
    quizPapers?: QuizPaperCreateNestedManyWithoutAuthorInput
  }

  export type AdminUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminUncheckedCreateNestedManyWithoutCreatorInput
    questions?: QuestionPoolUncheckedCreateNestedManyWithoutAuthorInput
    quizPapers?: QuizPaperUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AdminUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AdminUpdateOneWithoutCreatedAdminsNestedInput
    createdAdmins?: AdminUpdateManyWithoutCreatorNestedInput
    questions?: QuestionPoolUpdateManyWithoutAuthorNestedInput
    quizPapers?: QuizPaperUpdateManyWithoutAuthorNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUncheckedUpdateManyWithoutCreatorNestedInput
    questions?: QuestionPoolUncheckedUpdateManyWithoutAuthorNestedInput
    quizPapers?: QuizPaperUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AdminCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnerCreateInput = {
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    creator?: LearnerCreateNestedOneWithoutCreatedLearnersInput
    createdLearners?: LearnerCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardCreateNestedManyWithoutLearnerInput
  }

  export type LearnerUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    createdLearners?: LearnerUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutLearnerInput
  }

  export type LearnerUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    creator?: LearnerUpdateOneWithoutCreatedLearnersNestedInput
    createdLearners?: LearnerUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdLearners?: LearnerUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
  }

  export type LearnerUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type LearnerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type ProgramCreateInput = {
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentCreateNestedManyWithoutProgramInput
    quizAssignments?: QuizAssignmentCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: number
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProgramInput
    quizAssignments?: QuizAssignmentUncheckedCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUpdateManyWithoutProgramNestedInput
    quizAssignments?: QuizAssignmentUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProgramNestedInput
    quizAssignments?: QuizAssignmentUncheckedUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: number
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProgramUpdateManyMutationInput = {
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModuleCreateInput = {
    title: string
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteModule?: ModuleCreateNestedOneWithoutDependentModulesInput
    dependentModules?: ModuleCreateNestedManyWithoutPrerequisiteModuleInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutModuleInput
    programModules?: ProgramModuleCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    prerequisiteModuleId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentModules?: ModuleUncheckedCreateNestedManyWithoutPrerequisiteModuleInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutModuleInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteModule?: ModuleUpdateOneWithoutDependentModulesNestedInput
    dependentModules?: ModuleUpdateManyWithoutPrerequisiteModuleNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutModuleNestedInput
    programModules?: ProgramModuleUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteModuleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentModules?: ModuleUncheckedUpdateManyWithoutPrerequisiteModuleNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutModuleNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    prerequisiteModuleId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ModuleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteModuleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateInput = {
    enrolledAt?: Date | string
    learner: LearnerCreateNestedOneWithoutEnrollmentsInput
    program: ProgramCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateInput = {
    id?: number
    learnerId: number
    programId: number
    enrolledAt?: Date | string
  }

  export type EnrollmentUpdateInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learner?: LearnerUpdateOneRequiredWithoutEnrollmentsNestedInput
    program?: ProgramUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentCreateManyInput = {
    id?: number
    learnerId: number
    programId: number
    enrolledAt?: Date | string
  }

  export type EnrollmentUpdateManyMutationInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramModuleCreateInput = {
    position: number
    program: ProgramCreateNestedOneWithoutProgramModulesInput
    module: ModuleCreateNestedOneWithoutProgramModulesInput
  }

  export type ProgramModuleUncheckedCreateInput = {
    programId: number
    moduleId: number
    position: number
  }

  export type ProgramModuleUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    program?: ProgramUpdateOneRequiredWithoutProgramModulesNestedInput
    module?: ModuleUpdateOneRequiredWithoutProgramModulesNestedInput
  }

  export type ProgramModuleUncheckedUpdateInput = {
    programId?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramModuleCreateManyInput = {
    programId: number
    moduleId: number
    position: number
  }

  export type ProgramModuleUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramModuleUncheckedUpdateManyInput = {
    programId?: IntFieldUpdateOperationsInput | number
    moduleId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type TopicCreateInput = {
    title: string
    content?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteTopic?: TopicCreateNestedOneWithoutDependentTopicsInput
    dependentTopics?: TopicCreateNestedManyWithoutPrerequisiteTopicInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutTopicInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateInput = {
    id?: number
    title: string
    content?: string | null
    prerequisiteTopicId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentTopics?: TopicUncheckedCreateNestedManyWithoutPrerequisiteTopicInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutTopicInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteTopic?: TopicUpdateOneWithoutDependentTopicsNestedInput
    dependentTopics?: TopicUpdateManyWithoutPrerequisiteTopicNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutTopicNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentTopics?: TopicUncheckedUpdateManyWithoutPrerequisiteTopicNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutTopicNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicCreateManyInput = {
    id?: number
    title: string
    content?: string | null
    prerequisiteTopicId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TopicUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModuleTopicCreateInput = {
    position: number
    module: ModuleCreateNestedOneWithoutModuleTopicsInput
    topic: TopicCreateNestedOneWithoutModuleTopicsInput
  }

  export type ModuleTopicUncheckedCreateInput = {
    moduleId: number
    topicId: number
    position: number
  }

  export type ModuleTopicUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutModuleTopicsNestedInput
    topic?: TopicUpdateOneRequiredWithoutModuleTopicsNestedInput
  }

  export type ModuleTopicUncheckedUpdateInput = {
    moduleId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleTopicCreateManyInput = {
    moduleId: number
    topicId: number
    position: number
  }

  export type ModuleTopicUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleTopicUncheckedUpdateManyInput = {
    moduleId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ResourceCreateInput = {
    resourceType: $Enums.ResourceType
    url: string
    title?: string | null
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    resourceViews?: ResourceViewCreateNestedManyWithoutResourceInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutResourceInput
    topicResources?: TopicResourceCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: number
    resourceType: $Enums.ResourceType
    url: string
    title?: string | null
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutResourceInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutResourceInput
    topicResources?: TopicResourceUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resourceViews?: ResourceViewUpdateManyWithoutResourceNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutResourceNestedInput
    topicResources?: TopicResourceUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutResourceNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutResourceNestedInput
    topicResources?: TopicResourceUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: number
    resourceType: $Enums.ResourceType
    url: string
    title?: string | null
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicResourceCreateInput = {
    position: number
    topic: TopicCreateNestedOneWithoutTopicResourcesInput
    resource: ResourceCreateNestedOneWithoutTopicResourcesInput
  }

  export type TopicResourceUncheckedCreateInput = {
    topicId: number
    resourceId: number
    position: number
  }

  export type TopicResourceUpdateInput = {
    position?: IntFieldUpdateOperationsInput | number
    topic?: TopicUpdateOneRequiredWithoutTopicResourcesNestedInput
    resource?: ResourceUpdateOneRequiredWithoutTopicResourcesNestedInput
  }

  export type TopicResourceUncheckedUpdateInput = {
    topicId?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type TopicResourceCreateManyInput = {
    topicId: number
    resourceId: number
    position: number
  }

  export type TopicResourceUpdateManyMutationInput = {
    position?: IntFieldUpdateOperationsInput | number
  }

  export type TopicResourceUncheckedUpdateManyInput = {
    topicId?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type QuestionPoolCreateInput = {
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
    author: AdminCreateNestedOneWithoutQuestionsInput
    quizPaperQuestions?: QuizPaperQuestionCreateNestedManyWithoutQuestionInput
    questionAttempts?: QuestionAttemptCreateNestedManyWithoutQuestionInput
  }

  export type QuestionPoolUncheckedCreateInput = {
    id?: number
    authorId: number
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
    quizPaperQuestions?: QuizPaperQuestionUncheckedCreateNestedManyWithoutQuestionInput
    questionAttempts?: QuestionAttemptUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionPoolUpdateInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AdminUpdateOneRequiredWithoutQuestionsNestedInput
    quizPaperQuestions?: QuizPaperQuestionUpdateManyWithoutQuestionNestedInput
    questionAttempts?: QuestionAttemptUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionPoolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizPaperQuestions?: QuizPaperQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    questionAttempts?: QuestionAttemptUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionPoolCreateManyInput = {
    id?: number
    authorId: number
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
  }

  export type QuestionPoolUpdateManyMutationInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionPoolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizPaperCreateInput = {
    title: string
    createdAt?: Date | string
    author: AdminCreateNestedOneWithoutQuizPapersInput
    questions?: QuizPaperQuestionCreateNestedManyWithoutQuizPaperInput
    assignments?: QuizAssignmentCreateNestedManyWithoutQuizPaperInput
  }

  export type QuizPaperUncheckedCreateInput = {
    id?: number
    authorId: number
    title: string
    createdAt?: Date | string
    questions?: QuizPaperQuestionUncheckedCreateNestedManyWithoutQuizPaperInput
    assignments?: QuizAssignmentUncheckedCreateNestedManyWithoutQuizPaperInput
  }

  export type QuizPaperUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AdminUpdateOneRequiredWithoutQuizPapersNestedInput
    questions?: QuizPaperQuestionUpdateManyWithoutQuizPaperNestedInput
    assignments?: QuizAssignmentUpdateManyWithoutQuizPaperNestedInput
  }

  export type QuizPaperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizPaperQuestionUncheckedUpdateManyWithoutQuizPaperNestedInput
    assignments?: QuizAssignmentUncheckedUpdateManyWithoutQuizPaperNestedInput
  }

  export type QuizPaperCreateManyInput = {
    id?: number
    authorId: number
    title: string
    createdAt?: Date | string
  }

  export type QuizPaperUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizPaperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizPaperQuestionCreateInput = {
    position?: number | null
    timeMode?: boolean
    timeLimit?: number | null
    quizPaper: QuizPaperCreateNestedOneWithoutQuestionsInput
    question: QuestionPoolCreateNestedOneWithoutQuizPaperQuestionsInput
  }

  export type QuizPaperQuestionUncheckedCreateInput = {
    quizPaperId: number
    questionId: number
    position?: number | null
    timeMode?: boolean
    timeLimit?: number | null
  }

  export type QuizPaperQuestionUpdateInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    quizPaper?: QuizPaperUpdateOneRequiredWithoutQuestionsNestedInput
    question?: QuestionPoolUpdateOneRequiredWithoutQuizPaperQuestionsNestedInput
  }

  export type QuizPaperQuestionUncheckedUpdateInput = {
    quizPaperId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizPaperQuestionCreateManyInput = {
    quizPaperId: number
    questionId: number
    position?: number | null
    timeMode?: boolean
    timeLimit?: number | null
  }

  export type QuizPaperQuestionUpdateManyMutationInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizPaperQuestionUncheckedUpdateManyInput = {
    quizPaperId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizAssignmentCreateInput = {
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    quizPaper: QuizPaperCreateNestedOneWithoutAssignmentsInput
    program?: ProgramCreateNestedOneWithoutQuizAssignmentsInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutAssignmentInput
  }

  export type QuizAssignmentUncheckedCreateInput = {
    id?: number
    quizPaperId: number
    programId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type QuizAssignmentUpdateInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizPaper?: QuizPaperUpdateOneRequiredWithoutAssignmentsNestedInput
    program?: ProgramUpdateOneWithoutQuizAssignmentsNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutAssignmentNestedInput
  }

  export type QuizAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizPaperId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type QuizAssignmentCreateManyInput = {
    id?: number
    quizPaperId: number
    programId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type QuizAssignmentUpdateManyMutationInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizPaperId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptCreateInput = {
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
    assignment: QuizAssignmentCreateNestedOneWithoutQuizAttemptsInput
    learner: LearnerCreateNestedOneWithoutQuizAttemptsInput
    questionAttempts?: QuestionAttemptCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateInput = {
    id?: number
    assignmentId: number
    learnerId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
    questionAttempts?: QuestionAttemptUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUpdateInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: QuizAssignmentUpdateOneRequiredWithoutQuizAttemptsNestedInput
    learner?: LearnerUpdateOneRequiredWithoutQuizAttemptsNestedInput
    questionAttempts?: QuestionAttemptUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentId?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionAttempts?: QuestionAttemptUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptCreateManyInput = {
    id?: number
    assignmentId: number
    learnerId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
  }

  export type QuizAttemptUpdateManyMutationInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentId?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAttemptCreateInput = {
    answerText?: string | null
    isCorrect: boolean
    timeTakenSec?: number | null
    attempt: QuizAttemptCreateNestedOneWithoutQuestionAttemptsInput
    question: QuestionPoolCreateNestedOneWithoutQuestionAttemptsInput
  }

  export type QuestionAttemptUncheckedCreateInput = {
    attemptId: number
    questionId: number
    answerText?: string | null
    isCorrect: boolean
    timeTakenSec?: number | null
  }

  export type QuestionAttemptUpdateInput = {
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: QuizAttemptUpdateOneRequiredWithoutQuestionAttemptsNestedInput
    question?: QuestionPoolUpdateOneRequiredWithoutQuestionAttemptsNestedInput
  }

  export type QuestionAttemptUncheckedUpdateInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAttemptCreateManyInput = {
    attemptId: number
    questionId: number
    answerText?: string | null
    isCorrect: boolean
    timeTakenSec?: number | null
  }

  export type QuestionAttemptUpdateManyMutationInput = {
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAttemptUncheckedUpdateManyInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    questionId?: IntFieldUpdateOperationsInput | number
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ResourceViewCreateInput = {
    viewedAt?: Date | string
    learner: LearnerCreateNestedOneWithoutResourceViewsInput
    resource: ResourceCreateNestedOneWithoutResourceViewsInput
  }

  export type ResourceViewUncheckedCreateInput = {
    learnerId: number
    resourceId: number
    viewedAt?: Date | string
  }

  export type ResourceViewUpdateInput = {
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learner?: LearnerUpdateOneRequiredWithoutResourceViewsNestedInput
    resource?: ResourceUpdateOneRequiredWithoutResourceViewsNestedInput
  }

  export type ResourceViewUncheckedUpdateInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceViewCreateManyInput = {
    learnerId: number
    resourceId: number
    viewedAt?: Date | string
  }

  export type ResourceViewUpdateManyMutationInput = {
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceViewUncheckedUpdateManyInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasureProgressCreateInput = {
    completedAt: Date | string
    progressType: string
    status: string
    learner: LearnerCreateNestedOneWithoutMeasureProgressInput
    topic: TopicCreateNestedOneWithoutMeasureProgressInput
    program?: ProgramCreateNestedOneWithoutMeasureProgressInput
    module?: ModuleCreateNestedOneWithoutMeasureProgressInput
    resource?: ResourceCreateNestedOneWithoutMeasureProgressInput
  }

  export type MeasureProgressUncheckedCreateInput = {
    learnerId: number
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    moduleId?: number | null
    resourceId?: number | null
  }

  export type MeasureProgressUpdateInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    learner?: LearnerUpdateOneRequiredWithoutMeasureProgressNestedInput
    topic?: TopicUpdateOneRequiredWithoutMeasureProgressNestedInput
    program?: ProgramUpdateOneWithoutMeasureProgressNestedInput
    module?: ModuleUpdateOneWithoutMeasureProgressNestedInput
    resource?: ResourceUpdateOneWithoutMeasureProgressNestedInput
  }

  export type MeasureProgressUncheckedUpdateInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasureProgressCreateManyInput = {
    learnerId: number
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    moduleId?: number | null
    resourceId?: number | null
  }

  export type MeasureProgressUpdateManyMutationInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MeasureProgressUncheckedUpdateManyInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardCreateInput = {
    totalScore: Decimal | DecimalJsLike | number | string
    lastAttemptAt?: Date | string | null
    program: ProgramCreateNestedOneWithoutLeaderboardsInput
    learner: LearnerCreateNestedOneWithoutLeaderboardsInput
  }

  export type LeaderboardUncheckedCreateInput = {
    programId: number
    learnerId: number
    totalScore: Decimal | DecimalJsLike | number | string
    lastAttemptAt?: Date | string | null
  }

  export type LeaderboardUpdateInput = {
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    program?: ProgramUpdateOneRequiredWithoutLeaderboardsNestedInput
    learner?: LearnerUpdateOneRequiredWithoutLeaderboardsNestedInput
  }

  export type LeaderboardUncheckedUpdateInput = {
    programId?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaderboardCreateManyInput = {
    programId: number
    learnerId: number
    totalScore: Decimal | DecimalJsLike | number | string
    lastAttemptAt?: Date | string | null
  }

  export type LeaderboardUpdateManyMutationInput = {
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaderboardUncheckedUpdateManyInput = {
    programId?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumAdminTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminType | EnumAdminTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminTypeFilter<$PrismaModel> | $Enums.AdminType
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type AdminListRelationFilter = {
    every?: AdminWhereInput
    some?: AdminWhereInput
    none?: AdminWhereInput
  }

  export type QuestionPoolListRelationFilter = {
    every?: QuestionPoolWhereInput
    some?: QuestionPoolWhereInput
    none?: QuestionPoolWhereInput
  }

  export type QuizPaperListRelationFilter = {
    every?: QuizPaperWhereInput
    some?: QuizPaperWhereInput
    none?: QuizPaperWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AdminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionPoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizPaperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    adminType?: SortOrder
    organization?: SortOrder
    bio?: SortOrder
    profile_image?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    adminType?: SortOrder
    organization?: SortOrder
    bio?: SortOrder
    profile_image?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    adminType?: SortOrder
    organization?: SortOrder
    bio?: SortOrder
    profile_image?: SortOrder
    contactPhone?: SortOrder
    website?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    id?: SortOrder
    createdBy?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumAdminTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminType | EnumAdminTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminTypeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type LearnerNullableScalarRelationFilter = {
    is?: LearnerWhereInput | null
    isNot?: LearnerWhereInput | null
  }

  export type LearnerListRelationFilter = {
    every?: LearnerWhereInput
    some?: LearnerWhereInput
    none?: LearnerWhereInput
  }

  export type EnrollmentListRelationFilter = {
    every?: EnrollmentWhereInput
    some?: EnrollmentWhereInput
    none?: EnrollmentWhereInput
  }

  export type QuizAttemptListRelationFilter = {
    every?: QuizAttemptWhereInput
    some?: QuizAttemptWhereInput
    none?: QuizAttemptWhereInput
  }

  export type ResourceViewListRelationFilter = {
    every?: ResourceViewWhereInput
    some?: ResourceViewWhereInput
    none?: ResourceViewWhereInput
  }

  export type MeasureProgressListRelationFilter = {
    every?: MeasureProgressWhereInput
    some?: MeasureProgressWhereInput
    none?: MeasureProgressWhereInput
  }

  export type LeaderboardListRelationFilter = {
    every?: LeaderboardWhereInput
    some?: LeaderboardWhereInput
    none?: LeaderboardWhereInput
  }

  export type LearnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceViewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeasureProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearnerCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    communicationEmail?: SortOrder
    password?: SortOrder
    profile_image?: SortOrder
    organisation?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    location?: SortOrder
    hierarchy_level?: SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    isVerified?: SortOrder
    lastLogin?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueHash?: SortOrder
    status?: SortOrder
    extraConfig?: SortOrder
    metaData?: SortOrder
    role?: SortOrder
  }

  export type LearnerAvgOrderByAggregateInput = {
    id?: SortOrder
    totalPoints?: SortOrder
    createdBy?: SortOrder
    status?: SortOrder
  }

  export type LearnerMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    communicationEmail?: SortOrder
    password?: SortOrder
    profile_image?: SortOrder
    organisation?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    location?: SortOrder
    hierarchy_level?: SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    isVerified?: SortOrder
    lastLogin?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueHash?: SortOrder
    status?: SortOrder
    extraConfig?: SortOrder
    metaData?: SortOrder
    role?: SortOrder
  }

  export type LearnerMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    communicationEmail?: SortOrder
    password?: SortOrder
    profile_image?: SortOrder
    organisation?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    location?: SortOrder
    hierarchy_level?: SortOrder
    totalPoints?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    isVerified?: SortOrder
    lastLogin?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    uniqueHash?: SortOrder
    status?: SortOrder
    extraConfig?: SortOrder
    metaData?: SortOrder
    role?: SortOrder
  }

  export type LearnerSumOrderByAggregateInput = {
    id?: SortOrder
    totalPoints?: SortOrder
    createdBy?: SortOrder
    status?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumProgramTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramType | EnumProgramTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProgramType[] | ListEnumProgramTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProgramType[] | ListEnumProgramTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProgramTypeNullableFilter<$PrismaModel> | $Enums.ProgramType | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type QuizAssignmentListRelationFilter = {
    every?: QuizAssignmentWhereInput
    some?: QuizAssignmentWhereInput
    none?: QuizAssignmentWhereInput
  }

  export type ProgramModuleListRelationFilter = {
    every?: ProgramModuleWhereInput
    some?: ProgramModuleWhereInput
    none?: ProgramModuleWhereInput
  }

  export type QuizAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    instructor?: SortOrder
    instructorAvatar?: SortOrder
    image?: SortOrder
    rating?: SortOrder
    level?: SortOrder
    price?: SortOrder
    type?: SortOrder
    totalTimeLimit?: SortOrder
    status?: SortOrder
    uniqueHash?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    surveyStartDate?: SortOrder
    surveyEndDate?: SortOrder
    maxParticipants?: SortOrder
    passingScore?: SortOrder
    studySettings?: SortOrder
    clientId?: SortOrder
    packageId?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    rating?: SortOrder
    price?: SortOrder
    totalTimeLimit?: SortOrder
    status?: SortOrder
    passingScore?: SortOrder
    clientId?: SortOrder
    packageId?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    instructor?: SortOrder
    instructorAvatar?: SortOrder
    image?: SortOrder
    rating?: SortOrder
    level?: SortOrder
    price?: SortOrder
    type?: SortOrder
    totalTimeLimit?: SortOrder
    status?: SortOrder
    uniqueHash?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    surveyStartDate?: SortOrder
    surveyEndDate?: SortOrder
    maxParticipants?: SortOrder
    passingScore?: SortOrder
    clientId?: SortOrder
    packageId?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    instructor?: SortOrder
    instructorAvatar?: SortOrder
    image?: SortOrder
    rating?: SortOrder
    level?: SortOrder
    price?: SortOrder
    type?: SortOrder
    totalTimeLimit?: SortOrder
    status?: SortOrder
    uniqueHash?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    surveyStartDate?: SortOrder
    surveyEndDate?: SortOrder
    maxParticipants?: SortOrder
    passingScore?: SortOrder
    clientId?: SortOrder
    packageId?: SortOrder
    isActive?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    rating?: SortOrder
    price?: SortOrder
    totalTimeLimit?: SortOrder
    status?: SortOrder
    passingScore?: SortOrder
    clientId?: SortOrder
    packageId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumProgramTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramType | EnumProgramTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProgramType[] | ListEnumProgramTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProgramType[] | ListEnumProgramTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProgramTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProgramType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProgramTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumProgramTypeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type ModuleNullableScalarRelationFilter = {
    is?: ModuleWhereInput | null
    isNot?: ModuleWhereInput | null
  }

  export type ModuleListRelationFilter = {
    every?: ModuleWhereInput
    some?: ModuleWhereInput
    none?: ModuleWhereInput
  }

  export type ModuleTopicListRelationFilter = {
    every?: ModuleTopicWhereInput
    some?: ModuleTopicWhereInput
    none?: ModuleTopicWhereInput
  }

  export type ModuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleTopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ModuleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    prerequisiteModuleId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleAvgOrderByAggregateInput = {
    id?: SortOrder
    prerequisiteModuleId?: SortOrder
    status?: SortOrder
  }

  export type ModuleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    prerequisiteModuleId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    prerequisiteModuleId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ModuleSumOrderByAggregateInput = {
    id?: SortOrder
    prerequisiteModuleId?: SortOrder
    status?: SortOrder
  }

  export type LearnerScalarRelationFilter = {
    is?: LearnerWhereInput
    isNot?: LearnerWhereInput
  }

  export type ProgramScalarRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type EnrollmentLearnerIdProgramIdCompoundUniqueInput = {
    learnerId: number
    programId: number
  }

  export type EnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    learnerId?: SortOrder
    programId?: SortOrder
    enrolledAt?: SortOrder
  }

  export type EnrollmentAvgOrderByAggregateInput = {
    id?: SortOrder
    learnerId?: SortOrder
    programId?: SortOrder
  }

  export type EnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    learnerId?: SortOrder
    programId?: SortOrder
    enrolledAt?: SortOrder
  }

  export type EnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    learnerId?: SortOrder
    programId?: SortOrder
    enrolledAt?: SortOrder
  }

  export type EnrollmentSumOrderByAggregateInput = {
    id?: SortOrder
    learnerId?: SortOrder
    programId?: SortOrder
  }

  export type ModuleScalarRelationFilter = {
    is?: ModuleWhereInput
    isNot?: ModuleWhereInput
  }

  export type ProgramModuleProgramIdPositionCompoundUniqueInput = {
    programId: number
    position: number
  }

  export type ProgramModuleProgramIdModuleIdCompoundUniqueInput = {
    programId: number
    moduleId: number
  }

  export type ProgramModuleCountOrderByAggregateInput = {
    programId?: SortOrder
    moduleId?: SortOrder
    position?: SortOrder
  }

  export type ProgramModuleAvgOrderByAggregateInput = {
    programId?: SortOrder
    moduleId?: SortOrder
    position?: SortOrder
  }

  export type ProgramModuleMaxOrderByAggregateInput = {
    programId?: SortOrder
    moduleId?: SortOrder
    position?: SortOrder
  }

  export type ProgramModuleMinOrderByAggregateInput = {
    programId?: SortOrder
    moduleId?: SortOrder
    position?: SortOrder
  }

  export type ProgramModuleSumOrderByAggregateInput = {
    programId?: SortOrder
    moduleId?: SortOrder
    position?: SortOrder
  }

  export type TopicNullableScalarRelationFilter = {
    is?: TopicWhereInput | null
    isNot?: TopicWhereInput | null
  }

  export type TopicListRelationFilter = {
    every?: TopicWhereInput
    some?: TopicWhereInput
    none?: TopicWhereInput
  }

  export type TopicResourceListRelationFilter = {
    every?: TopicResourceWhereInput
    some?: TopicResourceWhereInput
    none?: TopicResourceWhereInput
  }

  export type TopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    prerequisiteTopicId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicAvgOrderByAggregateInput = {
    id?: SortOrder
    prerequisiteTopicId?: SortOrder
    status?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    prerequisiteTopicId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    prerequisiteTopicId?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicSumOrderByAggregateInput = {
    id?: SortOrder
    prerequisiteTopicId?: SortOrder
    status?: SortOrder
  }

  export type TopicScalarRelationFilter = {
    is?: TopicWhereInput
    isNot?: TopicWhereInput
  }

  export type ModuleTopicModuleIdPositionCompoundUniqueInput = {
    moduleId: number
    position: number
  }

  export type ModuleTopicModuleIdTopicIdCompoundUniqueInput = {
    moduleId: number
    topicId: number
  }

  export type ModuleTopicCountOrderByAggregateInput = {
    moduleId?: SortOrder
    topicId?: SortOrder
    position?: SortOrder
  }

  export type ModuleTopicAvgOrderByAggregateInput = {
    moduleId?: SortOrder
    topicId?: SortOrder
    position?: SortOrder
  }

  export type ModuleTopicMaxOrderByAggregateInput = {
    moduleId?: SortOrder
    topicId?: SortOrder
    position?: SortOrder
  }

  export type ModuleTopicMinOrderByAggregateInput = {
    moduleId?: SortOrder
    topicId?: SortOrder
    position?: SortOrder
  }

  export type ModuleTopicSumOrderByAggregateInput = {
    moduleId?: SortOrder
    topicId?: SortOrder
    position?: SortOrder
  }

  export type EnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    resourceType?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    resourceType?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    resourceType?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type EnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type ResourceScalarRelationFilter = {
    is?: ResourceWhereInput
    isNot?: ResourceWhereInput
  }

  export type TopicResourceTopicIdPositionCompoundUniqueInput = {
    topicId: number
    position: number
  }

  export type TopicResourceTopicIdResourceIdCompoundUniqueInput = {
    topicId: number
    resourceId: number
  }

  export type TopicResourceCountOrderByAggregateInput = {
    topicId?: SortOrder
    resourceId?: SortOrder
    position?: SortOrder
  }

  export type TopicResourceAvgOrderByAggregateInput = {
    topicId?: SortOrder
    resourceId?: SortOrder
    position?: SortOrder
  }

  export type TopicResourceMaxOrderByAggregateInput = {
    topicId?: SortOrder
    resourceId?: SortOrder
    position?: SortOrder
  }

  export type TopicResourceMinOrderByAggregateInput = {
    topicId?: SortOrder
    resourceId?: SortOrder
    position?: SortOrder
  }

  export type TopicResourceSumOrderByAggregateInput = {
    topicId?: SortOrder
    resourceId?: SortOrder
    position?: SortOrder
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type QuizPaperQuestionListRelationFilter = {
    every?: QuizPaperQuestionWhereInput
    some?: QuizPaperQuestionWhereInput
    none?: QuizPaperQuestionWhereInput
  }

  export type QuestionAttemptListRelationFilter = {
    every?: QuestionAttemptWhereInput
    some?: QuestionAttemptWhereInput
    none?: QuestionAttemptWhereInput
  }

  export type QuizPaperQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionPoolCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    metadata?: SortOrder
    explanation?: SortOrder
    timeLimitSec?: SortOrder
    points?: SortOrder
    option1?: SortOrder
    option2?: SortOrder
    option3?: SortOrder
    option4?: SortOrder
    option5?: SortOrder
    option6?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionPoolAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    timeLimitSec?: SortOrder
    points?: SortOrder
  }

  export type QuestionPoolMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    explanation?: SortOrder
    timeLimitSec?: SortOrder
    points?: SortOrder
    option1?: SortOrder
    option2?: SortOrder
    option3?: SortOrder
    option4?: SortOrder
    option5?: SortOrder
    option6?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionPoolMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    explanation?: SortOrder
    timeLimitSec?: SortOrder
    points?: SortOrder
    option1?: SortOrder
    option2?: SortOrder
    option3?: SortOrder
    option4?: SortOrder
    option5?: SortOrder
    option6?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionPoolSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    timeLimitSec?: SortOrder
    points?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type QuizPaperCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizPaperAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type QuizPaperMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizPaperMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizPaperSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
  }

  export type QuizPaperScalarRelationFilter = {
    is?: QuizPaperWhereInput
    isNot?: QuizPaperWhereInput
  }

  export type QuestionPoolScalarRelationFilter = {
    is?: QuestionPoolWhereInput
    isNot?: QuestionPoolWhereInput
  }

  export type QuizPaperQuestionQuizPaperIdQuestionIdCompoundUniqueInput = {
    quizPaperId: number
    questionId: number
  }

  export type QuizPaperQuestionCountOrderByAggregateInput = {
    quizPaperId?: SortOrder
    questionId?: SortOrder
    position?: SortOrder
    timeMode?: SortOrder
    timeLimit?: SortOrder
  }

  export type QuizPaperQuestionAvgOrderByAggregateInput = {
    quizPaperId?: SortOrder
    questionId?: SortOrder
    position?: SortOrder
    timeLimit?: SortOrder
  }

  export type QuizPaperQuestionMaxOrderByAggregateInput = {
    quizPaperId?: SortOrder
    questionId?: SortOrder
    position?: SortOrder
    timeMode?: SortOrder
    timeLimit?: SortOrder
  }

  export type QuizPaperQuestionMinOrderByAggregateInput = {
    quizPaperId?: SortOrder
    questionId?: SortOrder
    position?: SortOrder
    timeMode?: SortOrder
    timeLimit?: SortOrder
  }

  export type QuizPaperQuestionSumOrderByAggregateInput = {
    quizPaperId?: SortOrder
    questionId?: SortOrder
    position?: SortOrder
    timeLimit?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type EnumTimeModeFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeMode | EnumTimeModeFieldRefInput<$PrismaModel>
    in?: $Enums.TimeMode[] | ListEnumTimeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeMode[] | ListEnumTimeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeModeFilter<$PrismaModel> | $Enums.TimeMode
  }

  export type EnumWrongAnswerModeFilter<$PrismaModel = never> = {
    equals?: $Enums.WrongAnswerMode | EnumWrongAnswerModeFieldRefInput<$PrismaModel>
    in?: $Enums.WrongAnswerMode[] | ListEnumWrongAnswerModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WrongAnswerMode[] | ListEnumWrongAnswerModeFieldRefInput<$PrismaModel>
    not?: NestedEnumWrongAnswerModeFilter<$PrismaModel> | $Enums.WrongAnswerMode
  }

  export type EnumResultModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultMode | EnumResultModeFieldRefInput<$PrismaModel>
    in?: $Enums.ResultMode[] | ListEnumResultModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultMode[] | ListEnumResultModeFieldRefInput<$PrismaModel>
    not?: NestedEnumResultModeFilter<$PrismaModel> | $Enums.ResultMode
  }

  export type ProgramNullableScalarRelationFilter = {
    is?: ProgramWhereInput | null
    isNot?: ProgramWhereInput | null
  }

  export type QuizAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    quizPaperId?: SortOrder
    programId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    uniqueLinkToken?: SortOrder
    timeMode?: SortOrder
    wrongAnsMode?: SortOrder
    resultMode?: SortOrder
    totalTimeLimit?: SortOrder
    passingScore?: SortOrder
    enabled?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    quizPaperId?: SortOrder
    programId?: SortOrder
    totalTimeLimit?: SortOrder
    passingScore?: SortOrder
  }

  export type QuizAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    quizPaperId?: SortOrder
    programId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    uniqueLinkToken?: SortOrder
    timeMode?: SortOrder
    wrongAnsMode?: SortOrder
    resultMode?: SortOrder
    totalTimeLimit?: SortOrder
    passingScore?: SortOrder
    enabled?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    quizPaperId?: SortOrder
    programId?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    uniqueLinkToken?: SortOrder
    timeMode?: SortOrder
    wrongAnsMode?: SortOrder
    resultMode?: SortOrder
    totalTimeLimit?: SortOrder
    passingScore?: SortOrder
    enabled?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    quizPaperId?: SortOrder
    programId?: SortOrder
    totalTimeLimit?: SortOrder
    passingScore?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumTimeModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeMode | EnumTimeModeFieldRefInput<$PrismaModel>
    in?: $Enums.TimeMode[] | ListEnumTimeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeMode[] | ListEnumTimeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeModeWithAggregatesFilter<$PrismaModel> | $Enums.TimeMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeModeFilter<$PrismaModel>
    _max?: NestedEnumTimeModeFilter<$PrismaModel>
  }

  export type EnumWrongAnswerModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WrongAnswerMode | EnumWrongAnswerModeFieldRefInput<$PrismaModel>
    in?: $Enums.WrongAnswerMode[] | ListEnumWrongAnswerModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WrongAnswerMode[] | ListEnumWrongAnswerModeFieldRefInput<$PrismaModel>
    not?: NestedEnumWrongAnswerModeWithAggregatesFilter<$PrismaModel> | $Enums.WrongAnswerMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWrongAnswerModeFilter<$PrismaModel>
    _max?: NestedEnumWrongAnswerModeFilter<$PrismaModel>
  }

  export type EnumResultModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultMode | EnumResultModeFieldRefInput<$PrismaModel>
    in?: $Enums.ResultMode[] | ListEnumResultModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultMode[] | ListEnumResultModeFieldRefInput<$PrismaModel>
    not?: NestedEnumResultModeWithAggregatesFilter<$PrismaModel> | $Enums.ResultMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResultModeFilter<$PrismaModel>
    _max?: NestedEnumResultModeFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type QuizAssignmentScalarRelationFilter = {
    is?: QuizAssignmentWhereInput
    isNot?: QuizAssignmentWhereInput
  }

  export type QuizAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    learnerId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    totalTimeSpent?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAttemptAvgOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    learnerId?: SortOrder
    totalTimeSpent?: SortOrder
    score?: SortOrder
  }

  export type QuizAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    learnerId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    totalTimeSpent?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    learnerId?: SortOrder
    startedAt?: SortOrder
    submittedAt?: SortOrder
    totalTimeSpent?: SortOrder
    score?: SortOrder
    passed?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizAttemptSumOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    learnerId?: SortOrder
    totalTimeSpent?: SortOrder
    score?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type QuizAttemptScalarRelationFilter = {
    is?: QuizAttemptWhereInput
    isNot?: QuizAttemptWhereInput
  }

  export type QuestionAttemptAttemptIdQuestionIdCompoundUniqueInput = {
    attemptId: number
    questionId: number
  }

  export type QuestionAttemptCountOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    answerText?: SortOrder
    isCorrect?: SortOrder
    timeTakenSec?: SortOrder
  }

  export type QuestionAttemptAvgOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    timeTakenSec?: SortOrder
  }

  export type QuestionAttemptMaxOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    answerText?: SortOrder
    isCorrect?: SortOrder
    timeTakenSec?: SortOrder
  }

  export type QuestionAttemptMinOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    answerText?: SortOrder
    isCorrect?: SortOrder
    timeTakenSec?: SortOrder
  }

  export type QuestionAttemptSumOrderByAggregateInput = {
    attemptId?: SortOrder
    questionId?: SortOrder
    timeTakenSec?: SortOrder
  }

  export type ResourceViewLearnerIdResourceIdCompoundUniqueInput = {
    learnerId: number
    resourceId: number
  }

  export type ResourceViewCountOrderByAggregateInput = {
    learnerId?: SortOrder
    resourceId?: SortOrder
    viewedAt?: SortOrder
  }

  export type ResourceViewAvgOrderByAggregateInput = {
    learnerId?: SortOrder
    resourceId?: SortOrder
  }

  export type ResourceViewMaxOrderByAggregateInput = {
    learnerId?: SortOrder
    resourceId?: SortOrder
    viewedAt?: SortOrder
  }

  export type ResourceViewMinOrderByAggregateInput = {
    learnerId?: SortOrder
    resourceId?: SortOrder
    viewedAt?: SortOrder
  }

  export type ResourceViewSumOrderByAggregateInput = {
    learnerId?: SortOrder
    resourceId?: SortOrder
  }

  export type ResourceNullableScalarRelationFilter = {
    is?: ResourceWhereInput | null
    isNot?: ResourceWhereInput | null
  }

  export type MeasureProgressLearnerIdTopicIdCompoundUniqueInput = {
    learnerId: number
    topicId: number
  }

  export type MeasureProgressCountOrderByAggregateInput = {
    learnerId?: SortOrder
    topicId?: SortOrder
    completedAt?: SortOrder
    progressType?: SortOrder
    status?: SortOrder
    programId?: SortOrder
    moduleId?: SortOrder
    resourceId?: SortOrder
  }

  export type MeasureProgressAvgOrderByAggregateInput = {
    learnerId?: SortOrder
    topicId?: SortOrder
    programId?: SortOrder
    moduleId?: SortOrder
    resourceId?: SortOrder
  }

  export type MeasureProgressMaxOrderByAggregateInput = {
    learnerId?: SortOrder
    topicId?: SortOrder
    completedAt?: SortOrder
    progressType?: SortOrder
    status?: SortOrder
    programId?: SortOrder
    moduleId?: SortOrder
    resourceId?: SortOrder
  }

  export type MeasureProgressMinOrderByAggregateInput = {
    learnerId?: SortOrder
    topicId?: SortOrder
    completedAt?: SortOrder
    progressType?: SortOrder
    status?: SortOrder
    programId?: SortOrder
    moduleId?: SortOrder
    resourceId?: SortOrder
  }

  export type MeasureProgressSumOrderByAggregateInput = {
    learnerId?: SortOrder
    topicId?: SortOrder
    programId?: SortOrder
    moduleId?: SortOrder
    resourceId?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type LeaderboardProgramIdLearnerIdCompoundUniqueInput = {
    programId: number
    learnerId: number
  }

  export type LeaderboardCountOrderByAggregateInput = {
    programId?: SortOrder
    learnerId?: SortOrder
    totalScore?: SortOrder
    lastAttemptAt?: SortOrder
  }

  export type LeaderboardAvgOrderByAggregateInput = {
    programId?: SortOrder
    learnerId?: SortOrder
    totalScore?: SortOrder
  }

  export type LeaderboardMaxOrderByAggregateInput = {
    programId?: SortOrder
    learnerId?: SortOrder
    totalScore?: SortOrder
    lastAttemptAt?: SortOrder
  }

  export type LeaderboardMinOrderByAggregateInput = {
    programId?: SortOrder
    learnerId?: SortOrder
    totalScore?: SortOrder
    lastAttemptAt?: SortOrder
  }

  export type LeaderboardSumOrderByAggregateInput = {
    programId?: SortOrder
    learnerId?: SortOrder
    totalScore?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AdminCreateNestedOneWithoutCreatedAdminsInput = {
    create?: XOR<AdminCreateWithoutCreatedAdminsInput, AdminUncheckedCreateWithoutCreatedAdminsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedAdminsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AdminCreateWithoutCreatorInput, AdminUncheckedCreateWithoutCreatorInput> | AdminCreateWithoutCreatorInput[] | AdminUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCreatorInput | AdminCreateOrConnectWithoutCreatorInput[]
    createMany?: AdminCreateManyCreatorInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type QuestionPoolCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QuestionPoolCreateWithoutAuthorInput, QuestionPoolUncheckedCreateWithoutAuthorInput> | QuestionPoolCreateWithoutAuthorInput[] | QuestionPoolUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuestionPoolCreateOrConnectWithoutAuthorInput | QuestionPoolCreateOrConnectWithoutAuthorInput[]
    createMany?: QuestionPoolCreateManyAuthorInputEnvelope
    connect?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
  }

  export type QuizPaperCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QuizPaperCreateWithoutAuthorInput, QuizPaperUncheckedCreateWithoutAuthorInput> | QuizPaperCreateWithoutAuthorInput[] | QuizPaperUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuizPaperCreateOrConnectWithoutAuthorInput | QuizPaperCreateOrConnectWithoutAuthorInput[]
    createMany?: QuizPaperCreateManyAuthorInputEnvelope
    connect?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
  }

  export type AdminUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AdminCreateWithoutCreatorInput, AdminUncheckedCreateWithoutCreatorInput> | AdminCreateWithoutCreatorInput[] | AdminUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCreatorInput | AdminCreateOrConnectWithoutCreatorInput[]
    createMany?: AdminCreateManyCreatorInputEnvelope
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
  }

  export type QuestionPoolUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QuestionPoolCreateWithoutAuthorInput, QuestionPoolUncheckedCreateWithoutAuthorInput> | QuestionPoolCreateWithoutAuthorInput[] | QuestionPoolUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuestionPoolCreateOrConnectWithoutAuthorInput | QuestionPoolCreateOrConnectWithoutAuthorInput[]
    createMany?: QuestionPoolCreateManyAuthorInputEnvelope
    connect?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
  }

  export type QuizPaperUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<QuizPaperCreateWithoutAuthorInput, QuizPaperUncheckedCreateWithoutAuthorInput> | QuizPaperCreateWithoutAuthorInput[] | QuizPaperUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuizPaperCreateOrConnectWithoutAuthorInput | QuizPaperCreateOrConnectWithoutAuthorInput[]
    createMany?: QuizPaperCreateManyAuthorInputEnvelope
    connect?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumAdminTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdminType
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AdminUpdateOneWithoutCreatedAdminsNestedInput = {
    create?: XOR<AdminCreateWithoutCreatedAdminsInput, AdminUncheckedCreateWithoutCreatedAdminsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCreatedAdminsInput
    upsert?: AdminUpsertWithoutCreatedAdminsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCreatedAdminsInput, AdminUpdateWithoutCreatedAdminsInput>, AdminUncheckedUpdateWithoutCreatedAdminsInput>
  }

  export type AdminUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AdminCreateWithoutCreatorInput, AdminUncheckedCreateWithoutCreatorInput> | AdminCreateWithoutCreatorInput[] | AdminUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCreatorInput | AdminCreateOrConnectWithoutCreatorInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCreatorInput | AdminUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AdminCreateManyCreatorInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCreatorInput | AdminUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCreatorInput | AdminUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type QuestionPoolUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QuestionPoolCreateWithoutAuthorInput, QuestionPoolUncheckedCreateWithoutAuthorInput> | QuestionPoolCreateWithoutAuthorInput[] | QuestionPoolUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuestionPoolCreateOrConnectWithoutAuthorInput | QuestionPoolCreateOrConnectWithoutAuthorInput[]
    upsert?: QuestionPoolUpsertWithWhereUniqueWithoutAuthorInput | QuestionPoolUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QuestionPoolCreateManyAuthorInputEnvelope
    set?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
    disconnect?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
    delete?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
    connect?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
    update?: QuestionPoolUpdateWithWhereUniqueWithoutAuthorInput | QuestionPoolUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QuestionPoolUpdateManyWithWhereWithoutAuthorInput | QuestionPoolUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QuestionPoolScalarWhereInput | QuestionPoolScalarWhereInput[]
  }

  export type QuizPaperUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QuizPaperCreateWithoutAuthorInput, QuizPaperUncheckedCreateWithoutAuthorInput> | QuizPaperCreateWithoutAuthorInput[] | QuizPaperUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuizPaperCreateOrConnectWithoutAuthorInput | QuizPaperCreateOrConnectWithoutAuthorInput[]
    upsert?: QuizPaperUpsertWithWhereUniqueWithoutAuthorInput | QuizPaperUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QuizPaperCreateManyAuthorInputEnvelope
    set?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
    disconnect?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
    delete?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
    connect?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
    update?: QuizPaperUpdateWithWhereUniqueWithoutAuthorInput | QuizPaperUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QuizPaperUpdateManyWithWhereWithoutAuthorInput | QuizPaperUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QuizPaperScalarWhereInput | QuizPaperScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AdminUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AdminCreateWithoutCreatorInput, AdminUncheckedCreateWithoutCreatorInput> | AdminCreateWithoutCreatorInput[] | AdminUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AdminCreateOrConnectWithoutCreatorInput | AdminCreateOrConnectWithoutCreatorInput[]
    upsert?: AdminUpsertWithWhereUniqueWithoutCreatorInput | AdminUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AdminCreateManyCreatorInputEnvelope
    set?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    disconnect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    delete?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    connect?: AdminWhereUniqueInput | AdminWhereUniqueInput[]
    update?: AdminUpdateWithWhereUniqueWithoutCreatorInput | AdminUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AdminUpdateManyWithWhereWithoutCreatorInput | AdminUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AdminScalarWhereInput | AdminScalarWhereInput[]
  }

  export type QuestionPoolUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QuestionPoolCreateWithoutAuthorInput, QuestionPoolUncheckedCreateWithoutAuthorInput> | QuestionPoolCreateWithoutAuthorInput[] | QuestionPoolUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuestionPoolCreateOrConnectWithoutAuthorInput | QuestionPoolCreateOrConnectWithoutAuthorInput[]
    upsert?: QuestionPoolUpsertWithWhereUniqueWithoutAuthorInput | QuestionPoolUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QuestionPoolCreateManyAuthorInputEnvelope
    set?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
    disconnect?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
    delete?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
    connect?: QuestionPoolWhereUniqueInput | QuestionPoolWhereUniqueInput[]
    update?: QuestionPoolUpdateWithWhereUniqueWithoutAuthorInput | QuestionPoolUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QuestionPoolUpdateManyWithWhereWithoutAuthorInput | QuestionPoolUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QuestionPoolScalarWhereInput | QuestionPoolScalarWhereInput[]
  }

  export type QuizPaperUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<QuizPaperCreateWithoutAuthorInput, QuizPaperUncheckedCreateWithoutAuthorInput> | QuizPaperCreateWithoutAuthorInput[] | QuizPaperUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: QuizPaperCreateOrConnectWithoutAuthorInput | QuizPaperCreateOrConnectWithoutAuthorInput[]
    upsert?: QuizPaperUpsertWithWhereUniqueWithoutAuthorInput | QuizPaperUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: QuizPaperCreateManyAuthorInputEnvelope
    set?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
    disconnect?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
    delete?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
    connect?: QuizPaperWhereUniqueInput | QuizPaperWhereUniqueInput[]
    update?: QuizPaperUpdateWithWhereUniqueWithoutAuthorInput | QuizPaperUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: QuizPaperUpdateManyWithWhereWithoutAuthorInput | QuizPaperUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: QuizPaperScalarWhereInput | QuizPaperScalarWhereInput[]
  }

  export type LearnerCreateNestedOneWithoutCreatedLearnersInput = {
    create?: XOR<LearnerCreateWithoutCreatedLearnersInput, LearnerUncheckedCreateWithoutCreatedLearnersInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutCreatedLearnersInput
    connect?: LearnerWhereUniqueInput
  }

  export type LearnerCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LearnerCreateWithoutCreatorInput, LearnerUncheckedCreateWithoutCreatorInput> | LearnerCreateWithoutCreatorInput[] | LearnerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LearnerCreateOrConnectWithoutCreatorInput | LearnerCreateOrConnectWithoutCreatorInput[]
    createMany?: LearnerCreateManyCreatorInputEnvelope
    connect?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
  }

  export type EnrollmentCreateNestedManyWithoutLearnerInput = {
    create?: XOR<EnrollmentCreateWithoutLearnerInput, EnrollmentUncheckedCreateWithoutLearnerInput> | EnrollmentCreateWithoutLearnerInput[] | EnrollmentUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutLearnerInput | EnrollmentCreateOrConnectWithoutLearnerInput[]
    createMany?: EnrollmentCreateManyLearnerInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutLearnerInput = {
    create?: XOR<QuizAttemptCreateWithoutLearnerInput, QuizAttemptUncheckedCreateWithoutLearnerInput> | QuizAttemptCreateWithoutLearnerInput[] | QuizAttemptUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutLearnerInput | QuizAttemptCreateOrConnectWithoutLearnerInput[]
    createMany?: QuizAttemptCreateManyLearnerInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ResourceViewCreateNestedManyWithoutLearnerInput = {
    create?: XOR<ResourceViewCreateWithoutLearnerInput, ResourceViewUncheckedCreateWithoutLearnerInput> | ResourceViewCreateWithoutLearnerInput[] | ResourceViewUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: ResourceViewCreateOrConnectWithoutLearnerInput | ResourceViewCreateOrConnectWithoutLearnerInput[]
    createMany?: ResourceViewCreateManyLearnerInputEnvelope
    connect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
  }

  export type MeasureProgressCreateNestedManyWithoutLearnerInput = {
    create?: XOR<MeasureProgressCreateWithoutLearnerInput, MeasureProgressUncheckedCreateWithoutLearnerInput> | MeasureProgressCreateWithoutLearnerInput[] | MeasureProgressUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutLearnerInput | MeasureProgressCreateOrConnectWithoutLearnerInput[]
    createMany?: MeasureProgressCreateManyLearnerInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type LeaderboardCreateNestedManyWithoutLearnerInput = {
    create?: XOR<LeaderboardCreateWithoutLearnerInput, LeaderboardUncheckedCreateWithoutLearnerInput> | LeaderboardCreateWithoutLearnerInput[] | LeaderboardUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutLearnerInput | LeaderboardCreateOrConnectWithoutLearnerInput[]
    createMany?: LeaderboardCreateManyLearnerInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type LearnerUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<LearnerCreateWithoutCreatorInput, LearnerUncheckedCreateWithoutCreatorInput> | LearnerCreateWithoutCreatorInput[] | LearnerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LearnerCreateOrConnectWithoutCreatorInput | LearnerCreateOrConnectWithoutCreatorInput[]
    createMany?: LearnerCreateManyCreatorInputEnvelope
    connect?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutLearnerInput = {
    create?: XOR<EnrollmentCreateWithoutLearnerInput, EnrollmentUncheckedCreateWithoutLearnerInput> | EnrollmentCreateWithoutLearnerInput[] | EnrollmentUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutLearnerInput | EnrollmentCreateOrConnectWithoutLearnerInput[]
    createMany?: EnrollmentCreateManyLearnerInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutLearnerInput = {
    create?: XOR<QuizAttemptCreateWithoutLearnerInput, QuizAttemptUncheckedCreateWithoutLearnerInput> | QuizAttemptCreateWithoutLearnerInput[] | QuizAttemptUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutLearnerInput | QuizAttemptCreateOrConnectWithoutLearnerInput[]
    createMany?: QuizAttemptCreateManyLearnerInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type ResourceViewUncheckedCreateNestedManyWithoutLearnerInput = {
    create?: XOR<ResourceViewCreateWithoutLearnerInput, ResourceViewUncheckedCreateWithoutLearnerInput> | ResourceViewCreateWithoutLearnerInput[] | ResourceViewUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: ResourceViewCreateOrConnectWithoutLearnerInput | ResourceViewCreateOrConnectWithoutLearnerInput[]
    createMany?: ResourceViewCreateManyLearnerInputEnvelope
    connect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
  }

  export type MeasureProgressUncheckedCreateNestedManyWithoutLearnerInput = {
    create?: XOR<MeasureProgressCreateWithoutLearnerInput, MeasureProgressUncheckedCreateWithoutLearnerInput> | MeasureProgressCreateWithoutLearnerInput[] | MeasureProgressUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutLearnerInput | MeasureProgressCreateOrConnectWithoutLearnerInput[]
    createMany?: MeasureProgressCreateManyLearnerInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type LeaderboardUncheckedCreateNestedManyWithoutLearnerInput = {
    create?: XOR<LeaderboardCreateWithoutLearnerInput, LeaderboardUncheckedCreateWithoutLearnerInput> | LeaderboardCreateWithoutLearnerInput[] | LeaderboardUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutLearnerInput | LeaderboardCreateOrConnectWithoutLearnerInput[]
    createMany?: LeaderboardCreateManyLearnerInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type LearnerUpdateOneWithoutCreatedLearnersNestedInput = {
    create?: XOR<LearnerCreateWithoutCreatedLearnersInput, LearnerUncheckedCreateWithoutCreatedLearnersInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutCreatedLearnersInput
    upsert?: LearnerUpsertWithoutCreatedLearnersInput
    disconnect?: LearnerWhereInput | boolean
    delete?: LearnerWhereInput | boolean
    connect?: LearnerWhereUniqueInput
    update?: XOR<XOR<LearnerUpdateToOneWithWhereWithoutCreatedLearnersInput, LearnerUpdateWithoutCreatedLearnersInput>, LearnerUncheckedUpdateWithoutCreatedLearnersInput>
  }

  export type LearnerUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LearnerCreateWithoutCreatorInput, LearnerUncheckedCreateWithoutCreatorInput> | LearnerCreateWithoutCreatorInput[] | LearnerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LearnerCreateOrConnectWithoutCreatorInput | LearnerCreateOrConnectWithoutCreatorInput[]
    upsert?: LearnerUpsertWithWhereUniqueWithoutCreatorInput | LearnerUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LearnerCreateManyCreatorInputEnvelope
    set?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
    disconnect?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
    delete?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
    connect?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
    update?: LearnerUpdateWithWhereUniqueWithoutCreatorInput | LearnerUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LearnerUpdateManyWithWhereWithoutCreatorInput | LearnerUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LearnerScalarWhereInput | LearnerScalarWhereInput[]
  }

  export type EnrollmentUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<EnrollmentCreateWithoutLearnerInput, EnrollmentUncheckedCreateWithoutLearnerInput> | EnrollmentCreateWithoutLearnerInput[] | EnrollmentUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutLearnerInput | EnrollmentCreateOrConnectWithoutLearnerInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutLearnerInput | EnrollmentUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: EnrollmentCreateManyLearnerInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutLearnerInput | EnrollmentUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutLearnerInput | EnrollmentUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutLearnerInput, QuizAttemptUncheckedCreateWithoutLearnerInput> | QuizAttemptCreateWithoutLearnerInput[] | QuizAttemptUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutLearnerInput | QuizAttemptCreateOrConnectWithoutLearnerInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutLearnerInput | QuizAttemptUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: QuizAttemptCreateManyLearnerInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutLearnerInput | QuizAttemptUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutLearnerInput | QuizAttemptUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ResourceViewUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<ResourceViewCreateWithoutLearnerInput, ResourceViewUncheckedCreateWithoutLearnerInput> | ResourceViewCreateWithoutLearnerInput[] | ResourceViewUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: ResourceViewCreateOrConnectWithoutLearnerInput | ResourceViewCreateOrConnectWithoutLearnerInput[]
    upsert?: ResourceViewUpsertWithWhereUniqueWithoutLearnerInput | ResourceViewUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: ResourceViewCreateManyLearnerInputEnvelope
    set?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    disconnect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    delete?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    connect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    update?: ResourceViewUpdateWithWhereUniqueWithoutLearnerInput | ResourceViewUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: ResourceViewUpdateManyWithWhereWithoutLearnerInput | ResourceViewUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: ResourceViewScalarWhereInput | ResourceViewScalarWhereInput[]
  }

  export type MeasureProgressUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutLearnerInput, MeasureProgressUncheckedCreateWithoutLearnerInput> | MeasureProgressCreateWithoutLearnerInput[] | MeasureProgressUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutLearnerInput | MeasureProgressCreateOrConnectWithoutLearnerInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutLearnerInput | MeasureProgressUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: MeasureProgressCreateManyLearnerInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutLearnerInput | MeasureProgressUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutLearnerInput | MeasureProgressUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type LeaderboardUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<LeaderboardCreateWithoutLearnerInput, LeaderboardUncheckedCreateWithoutLearnerInput> | LeaderboardCreateWithoutLearnerInput[] | LeaderboardUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutLearnerInput | LeaderboardCreateOrConnectWithoutLearnerInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutLearnerInput | LeaderboardUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: LeaderboardCreateManyLearnerInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutLearnerInput | LeaderboardUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutLearnerInput | LeaderboardUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type LearnerUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<LearnerCreateWithoutCreatorInput, LearnerUncheckedCreateWithoutCreatorInput> | LearnerCreateWithoutCreatorInput[] | LearnerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: LearnerCreateOrConnectWithoutCreatorInput | LearnerCreateOrConnectWithoutCreatorInput[]
    upsert?: LearnerUpsertWithWhereUniqueWithoutCreatorInput | LearnerUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: LearnerCreateManyCreatorInputEnvelope
    set?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
    disconnect?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
    delete?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
    connect?: LearnerWhereUniqueInput | LearnerWhereUniqueInput[]
    update?: LearnerUpdateWithWhereUniqueWithoutCreatorInput | LearnerUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: LearnerUpdateManyWithWhereWithoutCreatorInput | LearnerUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: LearnerScalarWhereInput | LearnerScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<EnrollmentCreateWithoutLearnerInput, EnrollmentUncheckedCreateWithoutLearnerInput> | EnrollmentCreateWithoutLearnerInput[] | EnrollmentUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutLearnerInput | EnrollmentCreateOrConnectWithoutLearnerInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutLearnerInput | EnrollmentUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: EnrollmentCreateManyLearnerInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutLearnerInput | EnrollmentUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutLearnerInput | EnrollmentUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutLearnerInput, QuizAttemptUncheckedCreateWithoutLearnerInput> | QuizAttemptCreateWithoutLearnerInput[] | QuizAttemptUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutLearnerInput | QuizAttemptCreateOrConnectWithoutLearnerInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutLearnerInput | QuizAttemptUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: QuizAttemptCreateManyLearnerInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutLearnerInput | QuizAttemptUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutLearnerInput | QuizAttemptUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type ResourceViewUncheckedUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<ResourceViewCreateWithoutLearnerInput, ResourceViewUncheckedCreateWithoutLearnerInput> | ResourceViewCreateWithoutLearnerInput[] | ResourceViewUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: ResourceViewCreateOrConnectWithoutLearnerInput | ResourceViewCreateOrConnectWithoutLearnerInput[]
    upsert?: ResourceViewUpsertWithWhereUniqueWithoutLearnerInput | ResourceViewUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: ResourceViewCreateManyLearnerInputEnvelope
    set?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    disconnect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    delete?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    connect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    update?: ResourceViewUpdateWithWhereUniqueWithoutLearnerInput | ResourceViewUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: ResourceViewUpdateManyWithWhereWithoutLearnerInput | ResourceViewUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: ResourceViewScalarWhereInput | ResourceViewScalarWhereInput[]
  }

  export type MeasureProgressUncheckedUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutLearnerInput, MeasureProgressUncheckedCreateWithoutLearnerInput> | MeasureProgressCreateWithoutLearnerInput[] | MeasureProgressUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutLearnerInput | MeasureProgressCreateOrConnectWithoutLearnerInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutLearnerInput | MeasureProgressUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: MeasureProgressCreateManyLearnerInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutLearnerInput | MeasureProgressUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutLearnerInput | MeasureProgressUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type LeaderboardUncheckedUpdateManyWithoutLearnerNestedInput = {
    create?: XOR<LeaderboardCreateWithoutLearnerInput, LeaderboardUncheckedCreateWithoutLearnerInput> | LeaderboardCreateWithoutLearnerInput[] | LeaderboardUncheckedCreateWithoutLearnerInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutLearnerInput | LeaderboardCreateOrConnectWithoutLearnerInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutLearnerInput | LeaderboardUpsertWithWhereUniqueWithoutLearnerInput[]
    createMany?: LeaderboardCreateManyLearnerInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutLearnerInput | LeaderboardUpdateWithWhereUniqueWithoutLearnerInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutLearnerInput | LeaderboardUpdateManyWithWhereWithoutLearnerInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type EnrollmentCreateNestedManyWithoutProgramInput = {
    create?: XOR<EnrollmentCreateWithoutProgramInput, EnrollmentUncheckedCreateWithoutProgramInput> | EnrollmentCreateWithoutProgramInput[] | EnrollmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutProgramInput | EnrollmentCreateOrConnectWithoutProgramInput[]
    createMany?: EnrollmentCreateManyProgramInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type QuizAssignmentCreateNestedManyWithoutProgramInput = {
    create?: XOR<QuizAssignmentCreateWithoutProgramInput, QuizAssignmentUncheckedCreateWithoutProgramInput> | QuizAssignmentCreateWithoutProgramInput[] | QuizAssignmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutProgramInput | QuizAssignmentCreateOrConnectWithoutProgramInput[]
    createMany?: QuizAssignmentCreateManyProgramInputEnvelope
    connect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
  }

  export type MeasureProgressCreateNestedManyWithoutProgramInput = {
    create?: XOR<MeasureProgressCreateWithoutProgramInput, MeasureProgressUncheckedCreateWithoutProgramInput> | MeasureProgressCreateWithoutProgramInput[] | MeasureProgressUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutProgramInput | MeasureProgressCreateOrConnectWithoutProgramInput[]
    createMany?: MeasureProgressCreateManyProgramInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type LeaderboardCreateNestedManyWithoutProgramInput = {
    create?: XOR<LeaderboardCreateWithoutProgramInput, LeaderboardUncheckedCreateWithoutProgramInput> | LeaderboardCreateWithoutProgramInput[] | LeaderboardUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutProgramInput | LeaderboardCreateOrConnectWithoutProgramInput[]
    createMany?: LeaderboardCreateManyProgramInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type ProgramModuleCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramModuleCreateWithoutProgramInput, ProgramModuleUncheckedCreateWithoutProgramInput> | ProgramModuleCreateWithoutProgramInput[] | ProgramModuleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramModuleCreateOrConnectWithoutProgramInput | ProgramModuleCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramModuleCreateManyProgramInputEnvelope
    connect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
  }

  export type EnrollmentUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<EnrollmentCreateWithoutProgramInput, EnrollmentUncheckedCreateWithoutProgramInput> | EnrollmentCreateWithoutProgramInput[] | EnrollmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutProgramInput | EnrollmentCreateOrConnectWithoutProgramInput[]
    createMany?: EnrollmentCreateManyProgramInputEnvelope
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
  }

  export type QuizAssignmentUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<QuizAssignmentCreateWithoutProgramInput, QuizAssignmentUncheckedCreateWithoutProgramInput> | QuizAssignmentCreateWithoutProgramInput[] | QuizAssignmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutProgramInput | QuizAssignmentCreateOrConnectWithoutProgramInput[]
    createMany?: QuizAssignmentCreateManyProgramInputEnvelope
    connect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
  }

  export type MeasureProgressUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<MeasureProgressCreateWithoutProgramInput, MeasureProgressUncheckedCreateWithoutProgramInput> | MeasureProgressCreateWithoutProgramInput[] | MeasureProgressUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutProgramInput | MeasureProgressCreateOrConnectWithoutProgramInput[]
    createMany?: MeasureProgressCreateManyProgramInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type LeaderboardUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<LeaderboardCreateWithoutProgramInput, LeaderboardUncheckedCreateWithoutProgramInput> | LeaderboardCreateWithoutProgramInput[] | LeaderboardUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutProgramInput | LeaderboardCreateOrConnectWithoutProgramInput[]
    createMany?: LeaderboardCreateManyProgramInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type ProgramModuleUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramModuleCreateWithoutProgramInput, ProgramModuleUncheckedCreateWithoutProgramInput> | ProgramModuleCreateWithoutProgramInput[] | ProgramModuleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramModuleCreateOrConnectWithoutProgramInput | ProgramModuleCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramModuleCreateManyProgramInputEnvelope
    connect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumProgramTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProgramType | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type EnrollmentUpdateManyWithoutProgramNestedInput = {
    create?: XOR<EnrollmentCreateWithoutProgramInput, EnrollmentUncheckedCreateWithoutProgramInput> | EnrollmentCreateWithoutProgramInput[] | EnrollmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutProgramInput | EnrollmentCreateOrConnectWithoutProgramInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutProgramInput | EnrollmentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: EnrollmentCreateManyProgramInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutProgramInput | EnrollmentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutProgramInput | EnrollmentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type QuizAssignmentUpdateManyWithoutProgramNestedInput = {
    create?: XOR<QuizAssignmentCreateWithoutProgramInput, QuizAssignmentUncheckedCreateWithoutProgramInput> | QuizAssignmentCreateWithoutProgramInput[] | QuizAssignmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutProgramInput | QuizAssignmentCreateOrConnectWithoutProgramInput[]
    upsert?: QuizAssignmentUpsertWithWhereUniqueWithoutProgramInput | QuizAssignmentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: QuizAssignmentCreateManyProgramInputEnvelope
    set?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    disconnect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    delete?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    connect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    update?: QuizAssignmentUpdateWithWhereUniqueWithoutProgramInput | QuizAssignmentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: QuizAssignmentUpdateManyWithWhereWithoutProgramInput | QuizAssignmentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: QuizAssignmentScalarWhereInput | QuizAssignmentScalarWhereInput[]
  }

  export type MeasureProgressUpdateManyWithoutProgramNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutProgramInput, MeasureProgressUncheckedCreateWithoutProgramInput> | MeasureProgressCreateWithoutProgramInput[] | MeasureProgressUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutProgramInput | MeasureProgressCreateOrConnectWithoutProgramInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutProgramInput | MeasureProgressUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: MeasureProgressCreateManyProgramInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutProgramInput | MeasureProgressUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutProgramInput | MeasureProgressUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type LeaderboardUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LeaderboardCreateWithoutProgramInput, LeaderboardUncheckedCreateWithoutProgramInput> | LeaderboardCreateWithoutProgramInput[] | LeaderboardUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutProgramInput | LeaderboardCreateOrConnectWithoutProgramInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutProgramInput | LeaderboardUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LeaderboardCreateManyProgramInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutProgramInput | LeaderboardUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutProgramInput | LeaderboardUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type ProgramModuleUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramModuleCreateWithoutProgramInput, ProgramModuleUncheckedCreateWithoutProgramInput> | ProgramModuleCreateWithoutProgramInput[] | ProgramModuleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramModuleCreateOrConnectWithoutProgramInput | ProgramModuleCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramModuleUpsertWithWhereUniqueWithoutProgramInput | ProgramModuleUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramModuleCreateManyProgramInputEnvelope
    set?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    disconnect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    delete?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    connect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    update?: ProgramModuleUpdateWithWhereUniqueWithoutProgramInput | ProgramModuleUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramModuleUpdateManyWithWhereWithoutProgramInput | ProgramModuleUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramModuleScalarWhereInput | ProgramModuleScalarWhereInput[]
  }

  export type EnrollmentUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<EnrollmentCreateWithoutProgramInput, EnrollmentUncheckedCreateWithoutProgramInput> | EnrollmentCreateWithoutProgramInput[] | EnrollmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: EnrollmentCreateOrConnectWithoutProgramInput | EnrollmentCreateOrConnectWithoutProgramInput[]
    upsert?: EnrollmentUpsertWithWhereUniqueWithoutProgramInput | EnrollmentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: EnrollmentCreateManyProgramInputEnvelope
    set?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    disconnect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    delete?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    connect?: EnrollmentWhereUniqueInput | EnrollmentWhereUniqueInput[]
    update?: EnrollmentUpdateWithWhereUniqueWithoutProgramInput | EnrollmentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: EnrollmentUpdateManyWithWhereWithoutProgramInput | EnrollmentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
  }

  export type QuizAssignmentUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<QuizAssignmentCreateWithoutProgramInput, QuizAssignmentUncheckedCreateWithoutProgramInput> | QuizAssignmentCreateWithoutProgramInput[] | QuizAssignmentUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutProgramInput | QuizAssignmentCreateOrConnectWithoutProgramInput[]
    upsert?: QuizAssignmentUpsertWithWhereUniqueWithoutProgramInput | QuizAssignmentUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: QuizAssignmentCreateManyProgramInputEnvelope
    set?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    disconnect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    delete?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    connect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    update?: QuizAssignmentUpdateWithWhereUniqueWithoutProgramInput | QuizAssignmentUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: QuizAssignmentUpdateManyWithWhereWithoutProgramInput | QuizAssignmentUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: QuizAssignmentScalarWhereInput | QuizAssignmentScalarWhereInput[]
  }

  export type MeasureProgressUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutProgramInput, MeasureProgressUncheckedCreateWithoutProgramInput> | MeasureProgressCreateWithoutProgramInput[] | MeasureProgressUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutProgramInput | MeasureProgressCreateOrConnectWithoutProgramInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutProgramInput | MeasureProgressUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: MeasureProgressCreateManyProgramInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutProgramInput | MeasureProgressUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutProgramInput | MeasureProgressUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type LeaderboardUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<LeaderboardCreateWithoutProgramInput, LeaderboardUncheckedCreateWithoutProgramInput> | LeaderboardCreateWithoutProgramInput[] | LeaderboardUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutProgramInput | LeaderboardCreateOrConnectWithoutProgramInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutProgramInput | LeaderboardUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: LeaderboardCreateManyProgramInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutProgramInput | LeaderboardUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutProgramInput | LeaderboardUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type ProgramModuleUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramModuleCreateWithoutProgramInput, ProgramModuleUncheckedCreateWithoutProgramInput> | ProgramModuleCreateWithoutProgramInput[] | ProgramModuleUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramModuleCreateOrConnectWithoutProgramInput | ProgramModuleCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramModuleUpsertWithWhereUniqueWithoutProgramInput | ProgramModuleUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramModuleCreateManyProgramInputEnvelope
    set?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    disconnect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    delete?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    connect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    update?: ProgramModuleUpdateWithWhereUniqueWithoutProgramInput | ProgramModuleUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramModuleUpdateManyWithWhereWithoutProgramInput | ProgramModuleUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramModuleScalarWhereInput | ProgramModuleScalarWhereInput[]
  }

  export type ModuleCreateNestedOneWithoutDependentModulesInput = {
    create?: XOR<ModuleCreateWithoutDependentModulesInput, ModuleUncheckedCreateWithoutDependentModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutDependentModulesInput
    connect?: ModuleWhereUniqueInput
  }

  export type ModuleCreateNestedManyWithoutPrerequisiteModuleInput = {
    create?: XOR<ModuleCreateWithoutPrerequisiteModuleInput, ModuleUncheckedCreateWithoutPrerequisiteModuleInput> | ModuleCreateWithoutPrerequisiteModuleInput[] | ModuleUncheckedCreateWithoutPrerequisiteModuleInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutPrerequisiteModuleInput | ModuleCreateOrConnectWithoutPrerequisiteModuleInput[]
    createMany?: ModuleCreateManyPrerequisiteModuleInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type MeasureProgressCreateNestedManyWithoutModuleInput = {
    create?: XOR<MeasureProgressCreateWithoutModuleInput, MeasureProgressUncheckedCreateWithoutModuleInput> | MeasureProgressCreateWithoutModuleInput[] | MeasureProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutModuleInput | MeasureProgressCreateOrConnectWithoutModuleInput[]
    createMany?: MeasureProgressCreateManyModuleInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type ProgramModuleCreateNestedManyWithoutModuleInput = {
    create?: XOR<ProgramModuleCreateWithoutModuleInput, ProgramModuleUncheckedCreateWithoutModuleInput> | ProgramModuleCreateWithoutModuleInput[] | ProgramModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ProgramModuleCreateOrConnectWithoutModuleInput | ProgramModuleCreateOrConnectWithoutModuleInput[]
    createMany?: ProgramModuleCreateManyModuleInputEnvelope
    connect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
  }

  export type ModuleTopicCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleTopicCreateWithoutModuleInput, ModuleTopicUncheckedCreateWithoutModuleInput> | ModuleTopicCreateWithoutModuleInput[] | ModuleTopicUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleTopicCreateOrConnectWithoutModuleInput | ModuleTopicCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleTopicCreateManyModuleInputEnvelope
    connect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
  }

  export type ModuleUncheckedCreateNestedManyWithoutPrerequisiteModuleInput = {
    create?: XOR<ModuleCreateWithoutPrerequisiteModuleInput, ModuleUncheckedCreateWithoutPrerequisiteModuleInput> | ModuleCreateWithoutPrerequisiteModuleInput[] | ModuleUncheckedCreateWithoutPrerequisiteModuleInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutPrerequisiteModuleInput | ModuleCreateOrConnectWithoutPrerequisiteModuleInput[]
    createMany?: ModuleCreateManyPrerequisiteModuleInputEnvelope
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
  }

  export type MeasureProgressUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<MeasureProgressCreateWithoutModuleInput, MeasureProgressUncheckedCreateWithoutModuleInput> | MeasureProgressCreateWithoutModuleInput[] | MeasureProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutModuleInput | MeasureProgressCreateOrConnectWithoutModuleInput[]
    createMany?: MeasureProgressCreateManyModuleInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type ProgramModuleUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ProgramModuleCreateWithoutModuleInput, ProgramModuleUncheckedCreateWithoutModuleInput> | ProgramModuleCreateWithoutModuleInput[] | ProgramModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ProgramModuleCreateOrConnectWithoutModuleInput | ProgramModuleCreateOrConnectWithoutModuleInput[]
    createMany?: ProgramModuleCreateManyModuleInputEnvelope
    connect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
  }

  export type ModuleTopicUncheckedCreateNestedManyWithoutModuleInput = {
    create?: XOR<ModuleTopicCreateWithoutModuleInput, ModuleTopicUncheckedCreateWithoutModuleInput> | ModuleTopicCreateWithoutModuleInput[] | ModuleTopicUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleTopicCreateOrConnectWithoutModuleInput | ModuleTopicCreateOrConnectWithoutModuleInput[]
    createMany?: ModuleTopicCreateManyModuleInputEnvelope
    connect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
  }

  export type ModuleUpdateOneWithoutDependentModulesNestedInput = {
    create?: XOR<ModuleCreateWithoutDependentModulesInput, ModuleUncheckedCreateWithoutDependentModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutDependentModulesInput
    upsert?: ModuleUpsertWithoutDependentModulesInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutDependentModulesInput, ModuleUpdateWithoutDependentModulesInput>, ModuleUncheckedUpdateWithoutDependentModulesInput>
  }

  export type ModuleUpdateManyWithoutPrerequisiteModuleNestedInput = {
    create?: XOR<ModuleCreateWithoutPrerequisiteModuleInput, ModuleUncheckedCreateWithoutPrerequisiteModuleInput> | ModuleCreateWithoutPrerequisiteModuleInput[] | ModuleUncheckedCreateWithoutPrerequisiteModuleInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutPrerequisiteModuleInput | ModuleCreateOrConnectWithoutPrerequisiteModuleInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutPrerequisiteModuleInput | ModuleUpsertWithWhereUniqueWithoutPrerequisiteModuleInput[]
    createMany?: ModuleCreateManyPrerequisiteModuleInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutPrerequisiteModuleInput | ModuleUpdateWithWhereUniqueWithoutPrerequisiteModuleInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutPrerequisiteModuleInput | ModuleUpdateManyWithWhereWithoutPrerequisiteModuleInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type MeasureProgressUpdateManyWithoutModuleNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutModuleInput, MeasureProgressUncheckedCreateWithoutModuleInput> | MeasureProgressCreateWithoutModuleInput[] | MeasureProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutModuleInput | MeasureProgressCreateOrConnectWithoutModuleInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutModuleInput | MeasureProgressUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: MeasureProgressCreateManyModuleInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutModuleInput | MeasureProgressUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutModuleInput | MeasureProgressUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type ProgramModuleUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ProgramModuleCreateWithoutModuleInput, ProgramModuleUncheckedCreateWithoutModuleInput> | ProgramModuleCreateWithoutModuleInput[] | ProgramModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ProgramModuleCreateOrConnectWithoutModuleInput | ProgramModuleCreateOrConnectWithoutModuleInput[]
    upsert?: ProgramModuleUpsertWithWhereUniqueWithoutModuleInput | ProgramModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ProgramModuleCreateManyModuleInputEnvelope
    set?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    disconnect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    delete?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    connect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    update?: ProgramModuleUpdateWithWhereUniqueWithoutModuleInput | ProgramModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ProgramModuleUpdateManyWithWhereWithoutModuleInput | ProgramModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ProgramModuleScalarWhereInput | ProgramModuleScalarWhereInput[]
  }

  export type ModuleTopicUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleTopicCreateWithoutModuleInput, ModuleTopicUncheckedCreateWithoutModuleInput> | ModuleTopicCreateWithoutModuleInput[] | ModuleTopicUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleTopicCreateOrConnectWithoutModuleInput | ModuleTopicCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleTopicUpsertWithWhereUniqueWithoutModuleInput | ModuleTopicUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleTopicCreateManyModuleInputEnvelope
    set?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    disconnect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    delete?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    connect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    update?: ModuleTopicUpdateWithWhereUniqueWithoutModuleInput | ModuleTopicUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleTopicUpdateManyWithWhereWithoutModuleInput | ModuleTopicUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleTopicScalarWhereInput | ModuleTopicScalarWhereInput[]
  }

  export type ModuleUncheckedUpdateManyWithoutPrerequisiteModuleNestedInput = {
    create?: XOR<ModuleCreateWithoutPrerequisiteModuleInput, ModuleUncheckedCreateWithoutPrerequisiteModuleInput> | ModuleCreateWithoutPrerequisiteModuleInput[] | ModuleUncheckedCreateWithoutPrerequisiteModuleInput[]
    connectOrCreate?: ModuleCreateOrConnectWithoutPrerequisiteModuleInput | ModuleCreateOrConnectWithoutPrerequisiteModuleInput[]
    upsert?: ModuleUpsertWithWhereUniqueWithoutPrerequisiteModuleInput | ModuleUpsertWithWhereUniqueWithoutPrerequisiteModuleInput[]
    createMany?: ModuleCreateManyPrerequisiteModuleInputEnvelope
    set?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    disconnect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    delete?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    connect?: ModuleWhereUniqueInput | ModuleWhereUniqueInput[]
    update?: ModuleUpdateWithWhereUniqueWithoutPrerequisiteModuleInput | ModuleUpdateWithWhereUniqueWithoutPrerequisiteModuleInput[]
    updateMany?: ModuleUpdateManyWithWhereWithoutPrerequisiteModuleInput | ModuleUpdateManyWithWhereWithoutPrerequisiteModuleInput[]
    deleteMany?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
  }

  export type MeasureProgressUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutModuleInput, MeasureProgressUncheckedCreateWithoutModuleInput> | MeasureProgressCreateWithoutModuleInput[] | MeasureProgressUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutModuleInput | MeasureProgressCreateOrConnectWithoutModuleInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutModuleInput | MeasureProgressUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: MeasureProgressCreateManyModuleInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutModuleInput | MeasureProgressUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutModuleInput | MeasureProgressUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type ProgramModuleUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ProgramModuleCreateWithoutModuleInput, ProgramModuleUncheckedCreateWithoutModuleInput> | ProgramModuleCreateWithoutModuleInput[] | ProgramModuleUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ProgramModuleCreateOrConnectWithoutModuleInput | ProgramModuleCreateOrConnectWithoutModuleInput[]
    upsert?: ProgramModuleUpsertWithWhereUniqueWithoutModuleInput | ProgramModuleUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ProgramModuleCreateManyModuleInputEnvelope
    set?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    disconnect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    delete?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    connect?: ProgramModuleWhereUniqueInput | ProgramModuleWhereUniqueInput[]
    update?: ProgramModuleUpdateWithWhereUniqueWithoutModuleInput | ProgramModuleUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ProgramModuleUpdateManyWithWhereWithoutModuleInput | ProgramModuleUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ProgramModuleScalarWhereInput | ProgramModuleScalarWhereInput[]
  }

  export type ModuleTopicUncheckedUpdateManyWithoutModuleNestedInput = {
    create?: XOR<ModuleTopicCreateWithoutModuleInput, ModuleTopicUncheckedCreateWithoutModuleInput> | ModuleTopicCreateWithoutModuleInput[] | ModuleTopicUncheckedCreateWithoutModuleInput[]
    connectOrCreate?: ModuleTopicCreateOrConnectWithoutModuleInput | ModuleTopicCreateOrConnectWithoutModuleInput[]
    upsert?: ModuleTopicUpsertWithWhereUniqueWithoutModuleInput | ModuleTopicUpsertWithWhereUniqueWithoutModuleInput[]
    createMany?: ModuleTopicCreateManyModuleInputEnvelope
    set?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    disconnect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    delete?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    connect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    update?: ModuleTopicUpdateWithWhereUniqueWithoutModuleInput | ModuleTopicUpdateWithWhereUniqueWithoutModuleInput[]
    updateMany?: ModuleTopicUpdateManyWithWhereWithoutModuleInput | ModuleTopicUpdateManyWithWhereWithoutModuleInput[]
    deleteMany?: ModuleTopicScalarWhereInput | ModuleTopicScalarWhereInput[]
  }

  export type LearnerCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<LearnerCreateWithoutEnrollmentsInput, LearnerUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutEnrollmentsInput
    connect?: LearnerWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<ProgramCreateWithoutEnrollmentsInput, ProgramUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutEnrollmentsInput
    connect?: ProgramWhereUniqueInput
  }

  export type LearnerUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<LearnerCreateWithoutEnrollmentsInput, LearnerUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutEnrollmentsInput
    upsert?: LearnerUpsertWithoutEnrollmentsInput
    connect?: LearnerWhereUniqueInput
    update?: XOR<XOR<LearnerUpdateToOneWithWhereWithoutEnrollmentsInput, LearnerUpdateWithoutEnrollmentsInput>, LearnerUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ProgramUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<ProgramCreateWithoutEnrollmentsInput, ProgramUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutEnrollmentsInput
    upsert?: ProgramUpsertWithoutEnrollmentsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutEnrollmentsInput, ProgramUpdateWithoutEnrollmentsInput>, ProgramUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ProgramCreateNestedOneWithoutProgramModulesInput = {
    create?: XOR<ProgramCreateWithoutProgramModulesInput, ProgramUncheckedCreateWithoutProgramModulesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProgramModulesInput
    connect?: ProgramWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutProgramModulesInput = {
    create?: XOR<ModuleCreateWithoutProgramModulesInput, ModuleUncheckedCreateWithoutProgramModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutProgramModulesInput
    connect?: ModuleWhereUniqueInput
  }

  export type ProgramUpdateOneRequiredWithoutProgramModulesNestedInput = {
    create?: XOR<ProgramCreateWithoutProgramModulesInput, ProgramUncheckedCreateWithoutProgramModulesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutProgramModulesInput
    upsert?: ProgramUpsertWithoutProgramModulesInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutProgramModulesInput, ProgramUpdateWithoutProgramModulesInput>, ProgramUncheckedUpdateWithoutProgramModulesInput>
  }

  export type ModuleUpdateOneRequiredWithoutProgramModulesNestedInput = {
    create?: XOR<ModuleCreateWithoutProgramModulesInput, ModuleUncheckedCreateWithoutProgramModulesInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutProgramModulesInput
    upsert?: ModuleUpsertWithoutProgramModulesInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutProgramModulesInput, ModuleUpdateWithoutProgramModulesInput>, ModuleUncheckedUpdateWithoutProgramModulesInput>
  }

  export type TopicCreateNestedOneWithoutDependentTopicsInput = {
    create?: XOR<TopicCreateWithoutDependentTopicsInput, TopicUncheckedCreateWithoutDependentTopicsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutDependentTopicsInput
    connect?: TopicWhereUniqueInput
  }

  export type TopicCreateNestedManyWithoutPrerequisiteTopicInput = {
    create?: XOR<TopicCreateWithoutPrerequisiteTopicInput, TopicUncheckedCreateWithoutPrerequisiteTopicInput> | TopicCreateWithoutPrerequisiteTopicInput[] | TopicUncheckedCreateWithoutPrerequisiteTopicInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutPrerequisiteTopicInput | TopicCreateOrConnectWithoutPrerequisiteTopicInput[]
    createMany?: TopicCreateManyPrerequisiteTopicInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type MeasureProgressCreateNestedManyWithoutTopicInput = {
    create?: XOR<MeasureProgressCreateWithoutTopicInput, MeasureProgressUncheckedCreateWithoutTopicInput> | MeasureProgressCreateWithoutTopicInput[] | MeasureProgressUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutTopicInput | MeasureProgressCreateOrConnectWithoutTopicInput[]
    createMany?: MeasureProgressCreateManyTopicInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type ModuleTopicCreateNestedManyWithoutTopicInput = {
    create?: XOR<ModuleTopicCreateWithoutTopicInput, ModuleTopicUncheckedCreateWithoutTopicInput> | ModuleTopicCreateWithoutTopicInput[] | ModuleTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ModuleTopicCreateOrConnectWithoutTopicInput | ModuleTopicCreateOrConnectWithoutTopicInput[]
    createMany?: ModuleTopicCreateManyTopicInputEnvelope
    connect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
  }

  export type TopicResourceCreateNestedManyWithoutTopicInput = {
    create?: XOR<TopicResourceCreateWithoutTopicInput, TopicResourceUncheckedCreateWithoutTopicInput> | TopicResourceCreateWithoutTopicInput[] | TopicResourceUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: TopicResourceCreateOrConnectWithoutTopicInput | TopicResourceCreateOrConnectWithoutTopicInput[]
    createMany?: TopicResourceCreateManyTopicInputEnvelope
    connect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
  }

  export type TopicUncheckedCreateNestedManyWithoutPrerequisiteTopicInput = {
    create?: XOR<TopicCreateWithoutPrerequisiteTopicInput, TopicUncheckedCreateWithoutPrerequisiteTopicInput> | TopicCreateWithoutPrerequisiteTopicInput[] | TopicUncheckedCreateWithoutPrerequisiteTopicInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutPrerequisiteTopicInput | TopicCreateOrConnectWithoutPrerequisiteTopicInput[]
    createMany?: TopicCreateManyPrerequisiteTopicInputEnvelope
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
  }

  export type MeasureProgressUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<MeasureProgressCreateWithoutTopicInput, MeasureProgressUncheckedCreateWithoutTopicInput> | MeasureProgressCreateWithoutTopicInput[] | MeasureProgressUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutTopicInput | MeasureProgressCreateOrConnectWithoutTopicInput[]
    createMany?: MeasureProgressCreateManyTopicInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type ModuleTopicUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<ModuleTopicCreateWithoutTopicInput, ModuleTopicUncheckedCreateWithoutTopicInput> | ModuleTopicCreateWithoutTopicInput[] | ModuleTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ModuleTopicCreateOrConnectWithoutTopicInput | ModuleTopicCreateOrConnectWithoutTopicInput[]
    createMany?: ModuleTopicCreateManyTopicInputEnvelope
    connect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
  }

  export type TopicResourceUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<TopicResourceCreateWithoutTopicInput, TopicResourceUncheckedCreateWithoutTopicInput> | TopicResourceCreateWithoutTopicInput[] | TopicResourceUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: TopicResourceCreateOrConnectWithoutTopicInput | TopicResourceCreateOrConnectWithoutTopicInput[]
    createMany?: TopicResourceCreateManyTopicInputEnvelope
    connect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
  }

  export type TopicUpdateOneWithoutDependentTopicsNestedInput = {
    create?: XOR<TopicCreateWithoutDependentTopicsInput, TopicUncheckedCreateWithoutDependentTopicsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutDependentTopicsInput
    upsert?: TopicUpsertWithoutDependentTopicsInput
    disconnect?: TopicWhereInput | boolean
    delete?: TopicWhereInput | boolean
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutDependentTopicsInput, TopicUpdateWithoutDependentTopicsInput>, TopicUncheckedUpdateWithoutDependentTopicsInput>
  }

  export type TopicUpdateManyWithoutPrerequisiteTopicNestedInput = {
    create?: XOR<TopicCreateWithoutPrerequisiteTopicInput, TopicUncheckedCreateWithoutPrerequisiteTopicInput> | TopicCreateWithoutPrerequisiteTopicInput[] | TopicUncheckedCreateWithoutPrerequisiteTopicInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutPrerequisiteTopicInput | TopicCreateOrConnectWithoutPrerequisiteTopicInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutPrerequisiteTopicInput | TopicUpsertWithWhereUniqueWithoutPrerequisiteTopicInput[]
    createMany?: TopicCreateManyPrerequisiteTopicInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutPrerequisiteTopicInput | TopicUpdateWithWhereUniqueWithoutPrerequisiteTopicInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutPrerequisiteTopicInput | TopicUpdateManyWithWhereWithoutPrerequisiteTopicInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type MeasureProgressUpdateManyWithoutTopicNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutTopicInput, MeasureProgressUncheckedCreateWithoutTopicInput> | MeasureProgressCreateWithoutTopicInput[] | MeasureProgressUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutTopicInput | MeasureProgressCreateOrConnectWithoutTopicInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutTopicInput | MeasureProgressUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: MeasureProgressCreateManyTopicInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutTopicInput | MeasureProgressUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutTopicInput | MeasureProgressUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type ModuleTopicUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ModuleTopicCreateWithoutTopicInput, ModuleTopicUncheckedCreateWithoutTopicInput> | ModuleTopicCreateWithoutTopicInput[] | ModuleTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ModuleTopicCreateOrConnectWithoutTopicInput | ModuleTopicCreateOrConnectWithoutTopicInput[]
    upsert?: ModuleTopicUpsertWithWhereUniqueWithoutTopicInput | ModuleTopicUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ModuleTopicCreateManyTopicInputEnvelope
    set?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    disconnect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    delete?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    connect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    update?: ModuleTopicUpdateWithWhereUniqueWithoutTopicInput | ModuleTopicUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ModuleTopicUpdateManyWithWhereWithoutTopicInput | ModuleTopicUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ModuleTopicScalarWhereInput | ModuleTopicScalarWhereInput[]
  }

  export type TopicResourceUpdateManyWithoutTopicNestedInput = {
    create?: XOR<TopicResourceCreateWithoutTopicInput, TopicResourceUncheckedCreateWithoutTopicInput> | TopicResourceCreateWithoutTopicInput[] | TopicResourceUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: TopicResourceCreateOrConnectWithoutTopicInput | TopicResourceCreateOrConnectWithoutTopicInput[]
    upsert?: TopicResourceUpsertWithWhereUniqueWithoutTopicInput | TopicResourceUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: TopicResourceCreateManyTopicInputEnvelope
    set?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    disconnect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    delete?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    connect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    update?: TopicResourceUpdateWithWhereUniqueWithoutTopicInput | TopicResourceUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: TopicResourceUpdateManyWithWhereWithoutTopicInput | TopicResourceUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: TopicResourceScalarWhereInput | TopicResourceScalarWhereInput[]
  }

  export type TopicUncheckedUpdateManyWithoutPrerequisiteTopicNestedInput = {
    create?: XOR<TopicCreateWithoutPrerequisiteTopicInput, TopicUncheckedCreateWithoutPrerequisiteTopicInput> | TopicCreateWithoutPrerequisiteTopicInput[] | TopicUncheckedCreateWithoutPrerequisiteTopicInput[]
    connectOrCreate?: TopicCreateOrConnectWithoutPrerequisiteTopicInput | TopicCreateOrConnectWithoutPrerequisiteTopicInput[]
    upsert?: TopicUpsertWithWhereUniqueWithoutPrerequisiteTopicInput | TopicUpsertWithWhereUniqueWithoutPrerequisiteTopicInput[]
    createMany?: TopicCreateManyPrerequisiteTopicInputEnvelope
    set?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    disconnect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    delete?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    connect?: TopicWhereUniqueInput | TopicWhereUniqueInput[]
    update?: TopicUpdateWithWhereUniqueWithoutPrerequisiteTopicInput | TopicUpdateWithWhereUniqueWithoutPrerequisiteTopicInput[]
    updateMany?: TopicUpdateManyWithWhereWithoutPrerequisiteTopicInput | TopicUpdateManyWithWhereWithoutPrerequisiteTopicInput[]
    deleteMany?: TopicScalarWhereInput | TopicScalarWhereInput[]
  }

  export type MeasureProgressUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutTopicInput, MeasureProgressUncheckedCreateWithoutTopicInput> | MeasureProgressCreateWithoutTopicInput[] | MeasureProgressUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutTopicInput | MeasureProgressCreateOrConnectWithoutTopicInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutTopicInput | MeasureProgressUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: MeasureProgressCreateManyTopicInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutTopicInput | MeasureProgressUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutTopicInput | MeasureProgressUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type ModuleTopicUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<ModuleTopicCreateWithoutTopicInput, ModuleTopicUncheckedCreateWithoutTopicInput> | ModuleTopicCreateWithoutTopicInput[] | ModuleTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: ModuleTopicCreateOrConnectWithoutTopicInput | ModuleTopicCreateOrConnectWithoutTopicInput[]
    upsert?: ModuleTopicUpsertWithWhereUniqueWithoutTopicInput | ModuleTopicUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: ModuleTopicCreateManyTopicInputEnvelope
    set?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    disconnect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    delete?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    connect?: ModuleTopicWhereUniqueInput | ModuleTopicWhereUniqueInput[]
    update?: ModuleTopicUpdateWithWhereUniqueWithoutTopicInput | ModuleTopicUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: ModuleTopicUpdateManyWithWhereWithoutTopicInput | ModuleTopicUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: ModuleTopicScalarWhereInput | ModuleTopicScalarWhereInput[]
  }

  export type TopicResourceUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<TopicResourceCreateWithoutTopicInput, TopicResourceUncheckedCreateWithoutTopicInput> | TopicResourceCreateWithoutTopicInput[] | TopicResourceUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: TopicResourceCreateOrConnectWithoutTopicInput | TopicResourceCreateOrConnectWithoutTopicInput[]
    upsert?: TopicResourceUpsertWithWhereUniqueWithoutTopicInput | TopicResourceUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: TopicResourceCreateManyTopicInputEnvelope
    set?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    disconnect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    delete?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    connect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    update?: TopicResourceUpdateWithWhereUniqueWithoutTopicInput | TopicResourceUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: TopicResourceUpdateManyWithWhereWithoutTopicInput | TopicResourceUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: TopicResourceScalarWhereInput | TopicResourceScalarWhereInput[]
  }

  export type ModuleCreateNestedOneWithoutModuleTopicsInput = {
    create?: XOR<ModuleCreateWithoutModuleTopicsInput, ModuleUncheckedCreateWithoutModuleTopicsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutModuleTopicsInput
    connect?: ModuleWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutModuleTopicsInput = {
    create?: XOR<TopicCreateWithoutModuleTopicsInput, TopicUncheckedCreateWithoutModuleTopicsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutModuleTopicsInput
    connect?: TopicWhereUniqueInput
  }

  export type ModuleUpdateOneRequiredWithoutModuleTopicsNestedInput = {
    create?: XOR<ModuleCreateWithoutModuleTopicsInput, ModuleUncheckedCreateWithoutModuleTopicsInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutModuleTopicsInput
    upsert?: ModuleUpsertWithoutModuleTopicsInput
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutModuleTopicsInput, ModuleUpdateWithoutModuleTopicsInput>, ModuleUncheckedUpdateWithoutModuleTopicsInput>
  }

  export type TopicUpdateOneRequiredWithoutModuleTopicsNestedInput = {
    create?: XOR<TopicCreateWithoutModuleTopicsInput, TopicUncheckedCreateWithoutModuleTopicsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutModuleTopicsInput
    upsert?: TopicUpsertWithoutModuleTopicsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutModuleTopicsInput, TopicUpdateWithoutModuleTopicsInput>, TopicUncheckedUpdateWithoutModuleTopicsInput>
  }

  export type ResourceViewCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceViewCreateWithoutResourceInput, ResourceViewUncheckedCreateWithoutResourceInput> | ResourceViewCreateWithoutResourceInput[] | ResourceViewUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceViewCreateOrConnectWithoutResourceInput | ResourceViewCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceViewCreateManyResourceInputEnvelope
    connect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
  }

  export type MeasureProgressCreateNestedManyWithoutResourceInput = {
    create?: XOR<MeasureProgressCreateWithoutResourceInput, MeasureProgressUncheckedCreateWithoutResourceInput> | MeasureProgressCreateWithoutResourceInput[] | MeasureProgressUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutResourceInput | MeasureProgressCreateOrConnectWithoutResourceInput[]
    createMany?: MeasureProgressCreateManyResourceInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type TopicResourceCreateNestedManyWithoutResourceInput = {
    create?: XOR<TopicResourceCreateWithoutResourceInput, TopicResourceUncheckedCreateWithoutResourceInput> | TopicResourceCreateWithoutResourceInput[] | TopicResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: TopicResourceCreateOrConnectWithoutResourceInput | TopicResourceCreateOrConnectWithoutResourceInput[]
    createMany?: TopicResourceCreateManyResourceInputEnvelope
    connect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
  }

  export type ResourceViewUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<ResourceViewCreateWithoutResourceInput, ResourceViewUncheckedCreateWithoutResourceInput> | ResourceViewCreateWithoutResourceInput[] | ResourceViewUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceViewCreateOrConnectWithoutResourceInput | ResourceViewCreateOrConnectWithoutResourceInput[]
    createMany?: ResourceViewCreateManyResourceInputEnvelope
    connect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
  }

  export type MeasureProgressUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<MeasureProgressCreateWithoutResourceInput, MeasureProgressUncheckedCreateWithoutResourceInput> | MeasureProgressCreateWithoutResourceInput[] | MeasureProgressUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutResourceInput | MeasureProgressCreateOrConnectWithoutResourceInput[]
    createMany?: MeasureProgressCreateManyResourceInputEnvelope
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
  }

  export type TopicResourceUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<TopicResourceCreateWithoutResourceInput, TopicResourceUncheckedCreateWithoutResourceInput> | TopicResourceCreateWithoutResourceInput[] | TopicResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: TopicResourceCreateOrConnectWithoutResourceInput | TopicResourceCreateOrConnectWithoutResourceInput[]
    createMany?: TopicResourceCreateManyResourceInputEnvelope
    connect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType
  }

  export type ResourceViewUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceViewCreateWithoutResourceInput, ResourceViewUncheckedCreateWithoutResourceInput> | ResourceViewCreateWithoutResourceInput[] | ResourceViewUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceViewCreateOrConnectWithoutResourceInput | ResourceViewCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceViewUpsertWithWhereUniqueWithoutResourceInput | ResourceViewUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceViewCreateManyResourceInputEnvelope
    set?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    disconnect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    delete?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    connect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    update?: ResourceViewUpdateWithWhereUniqueWithoutResourceInput | ResourceViewUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceViewUpdateManyWithWhereWithoutResourceInput | ResourceViewUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceViewScalarWhereInput | ResourceViewScalarWhereInput[]
  }

  export type MeasureProgressUpdateManyWithoutResourceNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutResourceInput, MeasureProgressUncheckedCreateWithoutResourceInput> | MeasureProgressCreateWithoutResourceInput[] | MeasureProgressUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutResourceInput | MeasureProgressCreateOrConnectWithoutResourceInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutResourceInput | MeasureProgressUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: MeasureProgressCreateManyResourceInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutResourceInput | MeasureProgressUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutResourceInput | MeasureProgressUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type TopicResourceUpdateManyWithoutResourceNestedInput = {
    create?: XOR<TopicResourceCreateWithoutResourceInput, TopicResourceUncheckedCreateWithoutResourceInput> | TopicResourceCreateWithoutResourceInput[] | TopicResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: TopicResourceCreateOrConnectWithoutResourceInput | TopicResourceCreateOrConnectWithoutResourceInput[]
    upsert?: TopicResourceUpsertWithWhereUniqueWithoutResourceInput | TopicResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: TopicResourceCreateManyResourceInputEnvelope
    set?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    disconnect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    delete?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    connect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    update?: TopicResourceUpdateWithWhereUniqueWithoutResourceInput | TopicResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: TopicResourceUpdateManyWithWhereWithoutResourceInput | TopicResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: TopicResourceScalarWhereInput | TopicResourceScalarWhereInput[]
  }

  export type ResourceViewUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<ResourceViewCreateWithoutResourceInput, ResourceViewUncheckedCreateWithoutResourceInput> | ResourceViewCreateWithoutResourceInput[] | ResourceViewUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: ResourceViewCreateOrConnectWithoutResourceInput | ResourceViewCreateOrConnectWithoutResourceInput[]
    upsert?: ResourceViewUpsertWithWhereUniqueWithoutResourceInput | ResourceViewUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: ResourceViewCreateManyResourceInputEnvelope
    set?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    disconnect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    delete?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    connect?: ResourceViewWhereUniqueInput | ResourceViewWhereUniqueInput[]
    update?: ResourceViewUpdateWithWhereUniqueWithoutResourceInput | ResourceViewUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: ResourceViewUpdateManyWithWhereWithoutResourceInput | ResourceViewUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: ResourceViewScalarWhereInput | ResourceViewScalarWhereInput[]
  }

  export type MeasureProgressUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<MeasureProgressCreateWithoutResourceInput, MeasureProgressUncheckedCreateWithoutResourceInput> | MeasureProgressCreateWithoutResourceInput[] | MeasureProgressUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: MeasureProgressCreateOrConnectWithoutResourceInput | MeasureProgressCreateOrConnectWithoutResourceInput[]
    upsert?: MeasureProgressUpsertWithWhereUniqueWithoutResourceInput | MeasureProgressUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: MeasureProgressCreateManyResourceInputEnvelope
    set?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    disconnect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    delete?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    connect?: MeasureProgressWhereUniqueInput | MeasureProgressWhereUniqueInput[]
    update?: MeasureProgressUpdateWithWhereUniqueWithoutResourceInput | MeasureProgressUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: MeasureProgressUpdateManyWithWhereWithoutResourceInput | MeasureProgressUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
  }

  export type TopicResourceUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<TopicResourceCreateWithoutResourceInput, TopicResourceUncheckedCreateWithoutResourceInput> | TopicResourceCreateWithoutResourceInput[] | TopicResourceUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: TopicResourceCreateOrConnectWithoutResourceInput | TopicResourceCreateOrConnectWithoutResourceInput[]
    upsert?: TopicResourceUpsertWithWhereUniqueWithoutResourceInput | TopicResourceUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: TopicResourceCreateManyResourceInputEnvelope
    set?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    disconnect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    delete?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    connect?: TopicResourceWhereUniqueInput | TopicResourceWhereUniqueInput[]
    update?: TopicResourceUpdateWithWhereUniqueWithoutResourceInput | TopicResourceUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: TopicResourceUpdateManyWithWhereWithoutResourceInput | TopicResourceUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: TopicResourceScalarWhereInput | TopicResourceScalarWhereInput[]
  }

  export type TopicCreateNestedOneWithoutTopicResourcesInput = {
    create?: XOR<TopicCreateWithoutTopicResourcesInput, TopicUncheckedCreateWithoutTopicResourcesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutTopicResourcesInput
    connect?: TopicWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutTopicResourcesInput = {
    create?: XOR<ResourceCreateWithoutTopicResourcesInput, ResourceUncheckedCreateWithoutTopicResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutTopicResourcesInput
    connect?: ResourceWhereUniqueInput
  }

  export type TopicUpdateOneRequiredWithoutTopicResourcesNestedInput = {
    create?: XOR<TopicCreateWithoutTopicResourcesInput, TopicUncheckedCreateWithoutTopicResourcesInput>
    connectOrCreate?: TopicCreateOrConnectWithoutTopicResourcesInput
    upsert?: TopicUpsertWithoutTopicResourcesInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutTopicResourcesInput, TopicUpdateWithoutTopicResourcesInput>, TopicUncheckedUpdateWithoutTopicResourcesInput>
  }

  export type ResourceUpdateOneRequiredWithoutTopicResourcesNestedInput = {
    create?: XOR<ResourceCreateWithoutTopicResourcesInput, ResourceUncheckedCreateWithoutTopicResourcesInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutTopicResourcesInput
    upsert?: ResourceUpsertWithoutTopicResourcesInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutTopicResourcesInput, ResourceUpdateWithoutTopicResourcesInput>, ResourceUncheckedUpdateWithoutTopicResourcesInput>
  }

  export type AdminCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<AdminCreateWithoutQuestionsInput, AdminUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutQuestionsInput
    connect?: AdminWhereUniqueInput
  }

  export type QuizPaperQuestionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizPaperQuestionCreateWithoutQuestionInput, QuizPaperQuestionUncheckedCreateWithoutQuestionInput> | QuizPaperQuestionCreateWithoutQuestionInput[] | QuizPaperQuestionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizPaperQuestionCreateOrConnectWithoutQuestionInput | QuizPaperQuestionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizPaperQuestionCreateManyQuestionInputEnvelope
    connect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
  }

  export type QuestionAttemptCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionAttemptCreateWithoutQuestionInput, QuestionAttemptUncheckedCreateWithoutQuestionInput> | QuestionAttemptCreateWithoutQuestionInput[] | QuestionAttemptUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutQuestionInput | QuestionAttemptCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionAttemptCreateManyQuestionInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type QuizPaperQuestionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuizPaperQuestionCreateWithoutQuestionInput, QuizPaperQuestionUncheckedCreateWithoutQuestionInput> | QuizPaperQuestionCreateWithoutQuestionInput[] | QuizPaperQuestionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizPaperQuestionCreateOrConnectWithoutQuestionInput | QuizPaperQuestionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuizPaperQuestionCreateManyQuestionInputEnvelope
    connect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
  }

  export type QuestionAttemptUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionAttemptCreateWithoutQuestionInput, QuestionAttemptUncheckedCreateWithoutQuestionInput> | QuestionAttemptCreateWithoutQuestionInput[] | QuestionAttemptUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutQuestionInput | QuestionAttemptCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionAttemptCreateManyQuestionInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type AdminUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<AdminCreateWithoutQuestionsInput, AdminUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutQuestionsInput
    upsert?: AdminUpsertWithoutQuestionsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutQuestionsInput, AdminUpdateWithoutQuestionsInput>, AdminUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizPaperQuestionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizPaperQuestionCreateWithoutQuestionInput, QuizPaperQuestionUncheckedCreateWithoutQuestionInput> | QuizPaperQuestionCreateWithoutQuestionInput[] | QuizPaperQuestionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizPaperQuestionCreateOrConnectWithoutQuestionInput | QuizPaperQuestionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizPaperQuestionUpsertWithWhereUniqueWithoutQuestionInput | QuizPaperQuestionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizPaperQuestionCreateManyQuestionInputEnvelope
    set?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    disconnect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    delete?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    connect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    update?: QuizPaperQuestionUpdateWithWhereUniqueWithoutQuestionInput | QuizPaperQuestionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizPaperQuestionUpdateManyWithWhereWithoutQuestionInput | QuizPaperQuestionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizPaperQuestionScalarWhereInput | QuizPaperQuestionScalarWhereInput[]
  }

  export type QuestionAttemptUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutQuestionInput, QuestionAttemptUncheckedCreateWithoutQuestionInput> | QuestionAttemptCreateWithoutQuestionInput[] | QuestionAttemptUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutQuestionInput | QuestionAttemptCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutQuestionInput | QuestionAttemptUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionAttemptCreateManyQuestionInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutQuestionInput | QuestionAttemptUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutQuestionInput | QuestionAttemptUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type QuizPaperQuestionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuizPaperQuestionCreateWithoutQuestionInput, QuizPaperQuestionUncheckedCreateWithoutQuestionInput> | QuizPaperQuestionCreateWithoutQuestionInput[] | QuizPaperQuestionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuizPaperQuestionCreateOrConnectWithoutQuestionInput | QuizPaperQuestionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuizPaperQuestionUpsertWithWhereUniqueWithoutQuestionInput | QuizPaperQuestionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuizPaperQuestionCreateManyQuestionInputEnvelope
    set?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    disconnect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    delete?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    connect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    update?: QuizPaperQuestionUpdateWithWhereUniqueWithoutQuestionInput | QuizPaperQuestionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuizPaperQuestionUpdateManyWithWhereWithoutQuestionInput | QuizPaperQuestionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuizPaperQuestionScalarWhereInput | QuizPaperQuestionScalarWhereInput[]
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutQuestionInput, QuestionAttemptUncheckedCreateWithoutQuestionInput> | QuestionAttemptCreateWithoutQuestionInput[] | QuestionAttemptUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutQuestionInput | QuestionAttemptCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutQuestionInput | QuestionAttemptUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionAttemptCreateManyQuestionInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutQuestionInput | QuestionAttemptUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutQuestionInput | QuestionAttemptUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutQuizPapersInput = {
    create?: XOR<AdminCreateWithoutQuizPapersInput, AdminUncheckedCreateWithoutQuizPapersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutQuizPapersInput
    connect?: AdminWhereUniqueInput
  }

  export type QuizPaperQuestionCreateNestedManyWithoutQuizPaperInput = {
    create?: XOR<QuizPaperQuestionCreateWithoutQuizPaperInput, QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput> | QuizPaperQuestionCreateWithoutQuizPaperInput[] | QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput[]
    connectOrCreate?: QuizPaperQuestionCreateOrConnectWithoutQuizPaperInput | QuizPaperQuestionCreateOrConnectWithoutQuizPaperInput[]
    createMany?: QuizPaperQuestionCreateManyQuizPaperInputEnvelope
    connect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
  }

  export type QuizAssignmentCreateNestedManyWithoutQuizPaperInput = {
    create?: XOR<QuizAssignmentCreateWithoutQuizPaperInput, QuizAssignmentUncheckedCreateWithoutQuizPaperInput> | QuizAssignmentCreateWithoutQuizPaperInput[] | QuizAssignmentUncheckedCreateWithoutQuizPaperInput[]
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutQuizPaperInput | QuizAssignmentCreateOrConnectWithoutQuizPaperInput[]
    createMany?: QuizAssignmentCreateManyQuizPaperInputEnvelope
    connect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
  }

  export type QuizPaperQuestionUncheckedCreateNestedManyWithoutQuizPaperInput = {
    create?: XOR<QuizPaperQuestionCreateWithoutQuizPaperInput, QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput> | QuizPaperQuestionCreateWithoutQuizPaperInput[] | QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput[]
    connectOrCreate?: QuizPaperQuestionCreateOrConnectWithoutQuizPaperInput | QuizPaperQuestionCreateOrConnectWithoutQuizPaperInput[]
    createMany?: QuizPaperQuestionCreateManyQuizPaperInputEnvelope
    connect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
  }

  export type QuizAssignmentUncheckedCreateNestedManyWithoutQuizPaperInput = {
    create?: XOR<QuizAssignmentCreateWithoutQuizPaperInput, QuizAssignmentUncheckedCreateWithoutQuizPaperInput> | QuizAssignmentCreateWithoutQuizPaperInput[] | QuizAssignmentUncheckedCreateWithoutQuizPaperInput[]
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutQuizPaperInput | QuizAssignmentCreateOrConnectWithoutQuizPaperInput[]
    createMany?: QuizAssignmentCreateManyQuizPaperInputEnvelope
    connect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
  }

  export type AdminUpdateOneRequiredWithoutQuizPapersNestedInput = {
    create?: XOR<AdminCreateWithoutQuizPapersInput, AdminUncheckedCreateWithoutQuizPapersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutQuizPapersInput
    upsert?: AdminUpsertWithoutQuizPapersInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutQuizPapersInput, AdminUpdateWithoutQuizPapersInput>, AdminUncheckedUpdateWithoutQuizPapersInput>
  }

  export type QuizPaperQuestionUpdateManyWithoutQuizPaperNestedInput = {
    create?: XOR<QuizPaperQuestionCreateWithoutQuizPaperInput, QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput> | QuizPaperQuestionCreateWithoutQuizPaperInput[] | QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput[]
    connectOrCreate?: QuizPaperQuestionCreateOrConnectWithoutQuizPaperInput | QuizPaperQuestionCreateOrConnectWithoutQuizPaperInput[]
    upsert?: QuizPaperQuestionUpsertWithWhereUniqueWithoutQuizPaperInput | QuizPaperQuestionUpsertWithWhereUniqueWithoutQuizPaperInput[]
    createMany?: QuizPaperQuestionCreateManyQuizPaperInputEnvelope
    set?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    disconnect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    delete?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    connect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    update?: QuizPaperQuestionUpdateWithWhereUniqueWithoutQuizPaperInput | QuizPaperQuestionUpdateWithWhereUniqueWithoutQuizPaperInput[]
    updateMany?: QuizPaperQuestionUpdateManyWithWhereWithoutQuizPaperInput | QuizPaperQuestionUpdateManyWithWhereWithoutQuizPaperInput[]
    deleteMany?: QuizPaperQuestionScalarWhereInput | QuizPaperQuestionScalarWhereInput[]
  }

  export type QuizAssignmentUpdateManyWithoutQuizPaperNestedInput = {
    create?: XOR<QuizAssignmentCreateWithoutQuizPaperInput, QuizAssignmentUncheckedCreateWithoutQuizPaperInput> | QuizAssignmentCreateWithoutQuizPaperInput[] | QuizAssignmentUncheckedCreateWithoutQuizPaperInput[]
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutQuizPaperInput | QuizAssignmentCreateOrConnectWithoutQuizPaperInput[]
    upsert?: QuizAssignmentUpsertWithWhereUniqueWithoutQuizPaperInput | QuizAssignmentUpsertWithWhereUniqueWithoutQuizPaperInput[]
    createMany?: QuizAssignmentCreateManyQuizPaperInputEnvelope
    set?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    disconnect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    delete?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    connect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    update?: QuizAssignmentUpdateWithWhereUniqueWithoutQuizPaperInput | QuizAssignmentUpdateWithWhereUniqueWithoutQuizPaperInput[]
    updateMany?: QuizAssignmentUpdateManyWithWhereWithoutQuizPaperInput | QuizAssignmentUpdateManyWithWhereWithoutQuizPaperInput[]
    deleteMany?: QuizAssignmentScalarWhereInput | QuizAssignmentScalarWhereInput[]
  }

  export type QuizPaperQuestionUncheckedUpdateManyWithoutQuizPaperNestedInput = {
    create?: XOR<QuizPaperQuestionCreateWithoutQuizPaperInput, QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput> | QuizPaperQuestionCreateWithoutQuizPaperInput[] | QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput[]
    connectOrCreate?: QuizPaperQuestionCreateOrConnectWithoutQuizPaperInput | QuizPaperQuestionCreateOrConnectWithoutQuizPaperInput[]
    upsert?: QuizPaperQuestionUpsertWithWhereUniqueWithoutQuizPaperInput | QuizPaperQuestionUpsertWithWhereUniqueWithoutQuizPaperInput[]
    createMany?: QuizPaperQuestionCreateManyQuizPaperInputEnvelope
    set?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    disconnect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    delete?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    connect?: QuizPaperQuestionWhereUniqueInput | QuizPaperQuestionWhereUniqueInput[]
    update?: QuizPaperQuestionUpdateWithWhereUniqueWithoutQuizPaperInput | QuizPaperQuestionUpdateWithWhereUniqueWithoutQuizPaperInput[]
    updateMany?: QuizPaperQuestionUpdateManyWithWhereWithoutQuizPaperInput | QuizPaperQuestionUpdateManyWithWhereWithoutQuizPaperInput[]
    deleteMany?: QuizPaperQuestionScalarWhereInput | QuizPaperQuestionScalarWhereInput[]
  }

  export type QuizAssignmentUncheckedUpdateManyWithoutQuizPaperNestedInput = {
    create?: XOR<QuizAssignmentCreateWithoutQuizPaperInput, QuizAssignmentUncheckedCreateWithoutQuizPaperInput> | QuizAssignmentCreateWithoutQuizPaperInput[] | QuizAssignmentUncheckedCreateWithoutQuizPaperInput[]
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutQuizPaperInput | QuizAssignmentCreateOrConnectWithoutQuizPaperInput[]
    upsert?: QuizAssignmentUpsertWithWhereUniqueWithoutQuizPaperInput | QuizAssignmentUpsertWithWhereUniqueWithoutQuizPaperInput[]
    createMany?: QuizAssignmentCreateManyQuizPaperInputEnvelope
    set?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    disconnect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    delete?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    connect?: QuizAssignmentWhereUniqueInput | QuizAssignmentWhereUniqueInput[]
    update?: QuizAssignmentUpdateWithWhereUniqueWithoutQuizPaperInput | QuizAssignmentUpdateWithWhereUniqueWithoutQuizPaperInput[]
    updateMany?: QuizAssignmentUpdateManyWithWhereWithoutQuizPaperInput | QuizAssignmentUpdateManyWithWhereWithoutQuizPaperInput[]
    deleteMany?: QuizAssignmentScalarWhereInput | QuizAssignmentScalarWhereInput[]
  }

  export type QuizPaperCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizPaperCreateWithoutQuestionsInput, QuizPaperUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizPaperCreateOrConnectWithoutQuestionsInput
    connect?: QuizPaperWhereUniqueInput
  }

  export type QuestionPoolCreateNestedOneWithoutQuizPaperQuestionsInput = {
    create?: XOR<QuestionPoolCreateWithoutQuizPaperQuestionsInput, QuestionPoolUncheckedCreateWithoutQuizPaperQuestionsInput>
    connectOrCreate?: QuestionPoolCreateOrConnectWithoutQuizPaperQuestionsInput
    connect?: QuestionPoolWhereUniqueInput
  }

  export type QuizPaperUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizPaperCreateWithoutQuestionsInput, QuizPaperUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizPaperCreateOrConnectWithoutQuestionsInput
    upsert?: QuizPaperUpsertWithoutQuestionsInput
    connect?: QuizPaperWhereUniqueInput
    update?: XOR<XOR<QuizPaperUpdateToOneWithWhereWithoutQuestionsInput, QuizPaperUpdateWithoutQuestionsInput>, QuizPaperUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionPoolUpdateOneRequiredWithoutQuizPaperQuestionsNestedInput = {
    create?: XOR<QuestionPoolCreateWithoutQuizPaperQuestionsInput, QuestionPoolUncheckedCreateWithoutQuizPaperQuestionsInput>
    connectOrCreate?: QuestionPoolCreateOrConnectWithoutQuizPaperQuestionsInput
    upsert?: QuestionPoolUpsertWithoutQuizPaperQuestionsInput
    connect?: QuestionPoolWhereUniqueInput
    update?: XOR<XOR<QuestionPoolUpdateToOneWithWhereWithoutQuizPaperQuestionsInput, QuestionPoolUpdateWithoutQuizPaperQuestionsInput>, QuestionPoolUncheckedUpdateWithoutQuizPaperQuestionsInput>
  }

  export type QuizPaperCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<QuizPaperCreateWithoutAssignmentsInput, QuizPaperUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: QuizPaperCreateOrConnectWithoutAssignmentsInput
    connect?: QuizPaperWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutQuizAssignmentsInput = {
    create?: XOR<ProgramCreateWithoutQuizAssignmentsInput, ProgramUncheckedCreateWithoutQuizAssignmentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutQuizAssignmentsInput
    connect?: ProgramWhereUniqueInput
  }

  export type QuizAttemptCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<QuizAttemptCreateWithoutAssignmentInput, QuizAttemptUncheckedCreateWithoutAssignmentInput> | QuizAttemptCreateWithoutAssignmentInput[] | QuizAttemptUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutAssignmentInput | QuizAttemptCreateOrConnectWithoutAssignmentInput[]
    createMany?: QuizAttemptCreateManyAssignmentInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<QuizAttemptCreateWithoutAssignmentInput, QuizAttemptUncheckedCreateWithoutAssignmentInput> | QuizAttemptCreateWithoutAssignmentInput[] | QuizAttemptUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutAssignmentInput | QuizAttemptCreateOrConnectWithoutAssignmentInput[]
    createMany?: QuizAttemptCreateManyAssignmentInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type EnumTimeModeFieldUpdateOperationsInput = {
    set?: $Enums.TimeMode
  }

  export type EnumWrongAnswerModeFieldUpdateOperationsInput = {
    set?: $Enums.WrongAnswerMode
  }

  export type EnumResultModeFieldUpdateOperationsInput = {
    set?: $Enums.ResultMode
  }

  export type QuizPaperUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<QuizPaperCreateWithoutAssignmentsInput, QuizPaperUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: QuizPaperCreateOrConnectWithoutAssignmentsInput
    upsert?: QuizPaperUpsertWithoutAssignmentsInput
    connect?: QuizPaperWhereUniqueInput
    update?: XOR<XOR<QuizPaperUpdateToOneWithWhereWithoutAssignmentsInput, QuizPaperUpdateWithoutAssignmentsInput>, QuizPaperUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ProgramUpdateOneWithoutQuizAssignmentsNestedInput = {
    create?: XOR<ProgramCreateWithoutQuizAssignmentsInput, ProgramUncheckedCreateWithoutQuizAssignmentsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutQuizAssignmentsInput
    upsert?: ProgramUpsertWithoutQuizAssignmentsInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutQuizAssignmentsInput, ProgramUpdateWithoutQuizAssignmentsInput>, ProgramUncheckedUpdateWithoutQuizAssignmentsInput>
  }

  export type QuizAttemptUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutAssignmentInput, QuizAttemptUncheckedCreateWithoutAssignmentInput> | QuizAttemptCreateWithoutAssignmentInput[] | QuizAttemptUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutAssignmentInput | QuizAttemptCreateOrConnectWithoutAssignmentInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutAssignmentInput | QuizAttemptUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: QuizAttemptCreateManyAssignmentInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutAssignmentInput | QuizAttemptUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutAssignmentInput | QuizAttemptUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutAssignmentInput, QuizAttemptUncheckedCreateWithoutAssignmentInput> | QuizAttemptCreateWithoutAssignmentInput[] | QuizAttemptUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutAssignmentInput | QuizAttemptCreateOrConnectWithoutAssignmentInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutAssignmentInput | QuizAttemptUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: QuizAttemptCreateManyAssignmentInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutAssignmentInput | QuizAttemptUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutAssignmentInput | QuizAttemptUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuizAssignmentCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<QuizAssignmentCreateWithoutQuizAttemptsInput, QuizAssignmentUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutQuizAttemptsInput
    connect?: QuizAssignmentWhereUniqueInput
  }

  export type LearnerCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<LearnerCreateWithoutQuizAttemptsInput, LearnerUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutQuizAttemptsInput
    connect?: LearnerWhereUniqueInput
  }

  export type QuestionAttemptCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuestionAttemptCreateWithoutAttemptInput, QuestionAttemptUncheckedCreateWithoutAttemptInput> | QuestionAttemptCreateWithoutAttemptInput[] | QuestionAttemptUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutAttemptInput | QuestionAttemptCreateOrConnectWithoutAttemptInput[]
    createMany?: QuestionAttemptCreateManyAttemptInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type QuestionAttemptUncheckedCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuestionAttemptCreateWithoutAttemptInput, QuestionAttemptUncheckedCreateWithoutAttemptInput> | QuestionAttemptCreateWithoutAttemptInput[] | QuestionAttemptUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutAttemptInput | QuestionAttemptCreateOrConnectWithoutAttemptInput[]
    createMany?: QuestionAttemptCreateManyAttemptInputEnvelope
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type QuizAssignmentUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<QuizAssignmentCreateWithoutQuizAttemptsInput, QuizAssignmentUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: QuizAssignmentCreateOrConnectWithoutQuizAttemptsInput
    upsert?: QuizAssignmentUpsertWithoutQuizAttemptsInput
    connect?: QuizAssignmentWhereUniqueInput
    update?: XOR<XOR<QuizAssignmentUpdateToOneWithWhereWithoutQuizAttemptsInput, QuizAssignmentUpdateWithoutQuizAttemptsInput>, QuizAssignmentUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type LearnerUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<LearnerCreateWithoutQuizAttemptsInput, LearnerUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutQuizAttemptsInput
    upsert?: LearnerUpsertWithoutQuizAttemptsInput
    connect?: LearnerWhereUniqueInput
    update?: XOR<XOR<LearnerUpdateToOneWithWhereWithoutQuizAttemptsInput, LearnerUpdateWithoutQuizAttemptsInput>, LearnerUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type QuestionAttemptUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutAttemptInput, QuestionAttemptUncheckedCreateWithoutAttemptInput> | QuestionAttemptCreateWithoutAttemptInput[] | QuestionAttemptUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutAttemptInput | QuestionAttemptCreateOrConnectWithoutAttemptInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutAttemptInput | QuestionAttemptUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuestionAttemptCreateManyAttemptInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutAttemptInput | QuestionAttemptUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutAttemptInput | QuestionAttemptUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuestionAttemptCreateWithoutAttemptInput, QuestionAttemptUncheckedCreateWithoutAttemptInput> | QuestionAttemptCreateWithoutAttemptInput[] | QuestionAttemptUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionAttemptCreateOrConnectWithoutAttemptInput | QuestionAttemptCreateOrConnectWithoutAttemptInput[]
    upsert?: QuestionAttemptUpsertWithWhereUniqueWithoutAttemptInput | QuestionAttemptUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuestionAttemptCreateManyAttemptInputEnvelope
    set?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    disconnect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    delete?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    connect?: QuestionAttemptWhereUniqueInput | QuestionAttemptWhereUniqueInput[]
    update?: QuestionAttemptUpdateWithWhereUniqueWithoutAttemptInput | QuestionAttemptUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuestionAttemptUpdateManyWithWhereWithoutAttemptInput | QuestionAttemptUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
  }

  export type QuizAttemptCreateNestedOneWithoutQuestionAttemptsInput = {
    create?: XOR<QuizAttemptCreateWithoutQuestionAttemptsInput, QuizAttemptUncheckedCreateWithoutQuestionAttemptsInput>
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuestionAttemptsInput
    connect?: QuizAttemptWhereUniqueInput
  }

  export type QuestionPoolCreateNestedOneWithoutQuestionAttemptsInput = {
    create?: XOR<QuestionPoolCreateWithoutQuestionAttemptsInput, QuestionPoolUncheckedCreateWithoutQuestionAttemptsInput>
    connectOrCreate?: QuestionPoolCreateOrConnectWithoutQuestionAttemptsInput
    connect?: QuestionPoolWhereUniqueInput
  }

  export type QuizAttemptUpdateOneRequiredWithoutQuestionAttemptsNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuestionAttemptsInput, QuizAttemptUncheckedCreateWithoutQuestionAttemptsInput>
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuestionAttemptsInput
    upsert?: QuizAttemptUpsertWithoutQuestionAttemptsInput
    connect?: QuizAttemptWhereUniqueInput
    update?: XOR<XOR<QuizAttemptUpdateToOneWithWhereWithoutQuestionAttemptsInput, QuizAttemptUpdateWithoutQuestionAttemptsInput>, QuizAttemptUncheckedUpdateWithoutQuestionAttemptsInput>
  }

  export type QuestionPoolUpdateOneRequiredWithoutQuestionAttemptsNestedInput = {
    create?: XOR<QuestionPoolCreateWithoutQuestionAttemptsInput, QuestionPoolUncheckedCreateWithoutQuestionAttemptsInput>
    connectOrCreate?: QuestionPoolCreateOrConnectWithoutQuestionAttemptsInput
    upsert?: QuestionPoolUpsertWithoutQuestionAttemptsInput
    connect?: QuestionPoolWhereUniqueInput
    update?: XOR<XOR<QuestionPoolUpdateToOneWithWhereWithoutQuestionAttemptsInput, QuestionPoolUpdateWithoutQuestionAttemptsInput>, QuestionPoolUncheckedUpdateWithoutQuestionAttemptsInput>
  }

  export type LearnerCreateNestedOneWithoutResourceViewsInput = {
    create?: XOR<LearnerCreateWithoutResourceViewsInput, LearnerUncheckedCreateWithoutResourceViewsInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutResourceViewsInput
    connect?: LearnerWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutResourceViewsInput = {
    create?: XOR<ResourceCreateWithoutResourceViewsInput, ResourceUncheckedCreateWithoutResourceViewsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutResourceViewsInput
    connect?: ResourceWhereUniqueInput
  }

  export type LearnerUpdateOneRequiredWithoutResourceViewsNestedInput = {
    create?: XOR<LearnerCreateWithoutResourceViewsInput, LearnerUncheckedCreateWithoutResourceViewsInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutResourceViewsInput
    upsert?: LearnerUpsertWithoutResourceViewsInput
    connect?: LearnerWhereUniqueInput
    update?: XOR<XOR<LearnerUpdateToOneWithWhereWithoutResourceViewsInput, LearnerUpdateWithoutResourceViewsInput>, LearnerUncheckedUpdateWithoutResourceViewsInput>
  }

  export type ResourceUpdateOneRequiredWithoutResourceViewsNestedInput = {
    create?: XOR<ResourceCreateWithoutResourceViewsInput, ResourceUncheckedCreateWithoutResourceViewsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutResourceViewsInput
    upsert?: ResourceUpsertWithoutResourceViewsInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutResourceViewsInput, ResourceUpdateWithoutResourceViewsInput>, ResourceUncheckedUpdateWithoutResourceViewsInput>
  }

  export type LearnerCreateNestedOneWithoutMeasureProgressInput = {
    create?: XOR<LearnerCreateWithoutMeasureProgressInput, LearnerUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutMeasureProgressInput
    connect?: LearnerWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutMeasureProgressInput = {
    create?: XOR<TopicCreateWithoutMeasureProgressInput, TopicUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: TopicCreateOrConnectWithoutMeasureProgressInput
    connect?: TopicWhereUniqueInput
  }

  export type ProgramCreateNestedOneWithoutMeasureProgressInput = {
    create?: XOR<ProgramCreateWithoutMeasureProgressInput, ProgramUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutMeasureProgressInput
    connect?: ProgramWhereUniqueInput
  }

  export type ModuleCreateNestedOneWithoutMeasureProgressInput = {
    create?: XOR<ModuleCreateWithoutMeasureProgressInput, ModuleUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutMeasureProgressInput
    connect?: ModuleWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutMeasureProgressInput = {
    create?: XOR<ResourceCreateWithoutMeasureProgressInput, ResourceUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutMeasureProgressInput
    connect?: ResourceWhereUniqueInput
  }

  export type LearnerUpdateOneRequiredWithoutMeasureProgressNestedInput = {
    create?: XOR<LearnerCreateWithoutMeasureProgressInput, LearnerUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutMeasureProgressInput
    upsert?: LearnerUpsertWithoutMeasureProgressInput
    connect?: LearnerWhereUniqueInput
    update?: XOR<XOR<LearnerUpdateToOneWithWhereWithoutMeasureProgressInput, LearnerUpdateWithoutMeasureProgressInput>, LearnerUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type TopicUpdateOneRequiredWithoutMeasureProgressNestedInput = {
    create?: XOR<TopicCreateWithoutMeasureProgressInput, TopicUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: TopicCreateOrConnectWithoutMeasureProgressInput
    upsert?: TopicUpsertWithoutMeasureProgressInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutMeasureProgressInput, TopicUpdateWithoutMeasureProgressInput>, TopicUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type ProgramUpdateOneWithoutMeasureProgressNestedInput = {
    create?: XOR<ProgramCreateWithoutMeasureProgressInput, ProgramUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutMeasureProgressInput
    upsert?: ProgramUpsertWithoutMeasureProgressInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutMeasureProgressInput, ProgramUpdateWithoutMeasureProgressInput>, ProgramUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type ModuleUpdateOneWithoutMeasureProgressNestedInput = {
    create?: XOR<ModuleCreateWithoutMeasureProgressInput, ModuleUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: ModuleCreateOrConnectWithoutMeasureProgressInput
    upsert?: ModuleUpsertWithoutMeasureProgressInput
    disconnect?: ModuleWhereInput | boolean
    delete?: ModuleWhereInput | boolean
    connect?: ModuleWhereUniqueInput
    update?: XOR<XOR<ModuleUpdateToOneWithWhereWithoutMeasureProgressInput, ModuleUpdateWithoutMeasureProgressInput>, ModuleUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type ResourceUpdateOneWithoutMeasureProgressNestedInput = {
    create?: XOR<ResourceCreateWithoutMeasureProgressInput, ResourceUncheckedCreateWithoutMeasureProgressInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutMeasureProgressInput
    upsert?: ResourceUpsertWithoutMeasureProgressInput
    disconnect?: ResourceWhereInput | boolean
    delete?: ResourceWhereInput | boolean
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutMeasureProgressInput, ResourceUpdateWithoutMeasureProgressInput>, ResourceUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type ProgramCreateNestedOneWithoutLeaderboardsInput = {
    create?: XOR<ProgramCreateWithoutLeaderboardsInput, ProgramUncheckedCreateWithoutLeaderboardsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutLeaderboardsInput
    connect?: ProgramWhereUniqueInput
  }

  export type LearnerCreateNestedOneWithoutLeaderboardsInput = {
    create?: XOR<LearnerCreateWithoutLeaderboardsInput, LearnerUncheckedCreateWithoutLeaderboardsInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutLeaderboardsInput
    connect?: LearnerWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProgramUpdateOneRequiredWithoutLeaderboardsNestedInput = {
    create?: XOR<ProgramCreateWithoutLeaderboardsInput, ProgramUncheckedCreateWithoutLeaderboardsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutLeaderboardsInput
    upsert?: ProgramUpsertWithoutLeaderboardsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutLeaderboardsInput, ProgramUpdateWithoutLeaderboardsInput>, ProgramUncheckedUpdateWithoutLeaderboardsInput>
  }

  export type LearnerUpdateOneRequiredWithoutLeaderboardsNestedInput = {
    create?: XOR<LearnerCreateWithoutLeaderboardsInput, LearnerUncheckedCreateWithoutLeaderboardsInput>
    connectOrCreate?: LearnerCreateOrConnectWithoutLeaderboardsInput
    upsert?: LearnerUpsertWithoutLeaderboardsInput
    connect?: LearnerWhereUniqueInput
    update?: XOR<XOR<LearnerUpdateToOneWithWhereWithoutLeaderboardsInput, LearnerUpdateWithoutLeaderboardsInput>, LearnerUncheckedUpdateWithoutLeaderboardsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumAdminTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminType | EnumAdminTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminTypeFilter<$PrismaModel> | $Enums.AdminType
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumAdminTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdminType | EnumAdminTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdminType[] | ListEnumAdminTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdminTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdminType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdminTypeFilter<$PrismaModel>
    _max?: NestedEnumAdminTypeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumProgramTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramType | EnumProgramTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProgramType[] | ListEnumProgramTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProgramType[] | ListEnumProgramTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProgramTypeNullableFilter<$PrismaModel> | $Enums.ProgramType | null
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumProgramTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramType | EnumProgramTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ProgramType[] | ListEnumProgramTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ProgramType[] | ListEnumProgramTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumProgramTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ProgramType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumProgramTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumProgramTypeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedEnumTimeModeFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeMode | EnumTimeModeFieldRefInput<$PrismaModel>
    in?: $Enums.TimeMode[] | ListEnumTimeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeMode[] | ListEnumTimeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeModeFilter<$PrismaModel> | $Enums.TimeMode
  }

  export type NestedEnumWrongAnswerModeFilter<$PrismaModel = never> = {
    equals?: $Enums.WrongAnswerMode | EnumWrongAnswerModeFieldRefInput<$PrismaModel>
    in?: $Enums.WrongAnswerMode[] | ListEnumWrongAnswerModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WrongAnswerMode[] | ListEnumWrongAnswerModeFieldRefInput<$PrismaModel>
    not?: NestedEnumWrongAnswerModeFilter<$PrismaModel> | $Enums.WrongAnswerMode
  }

  export type NestedEnumResultModeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultMode | EnumResultModeFieldRefInput<$PrismaModel>
    in?: $Enums.ResultMode[] | ListEnumResultModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultMode[] | ListEnumResultModeFieldRefInput<$PrismaModel>
    not?: NestedEnumResultModeFilter<$PrismaModel> | $Enums.ResultMode
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumTimeModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TimeMode | EnumTimeModeFieldRefInput<$PrismaModel>
    in?: $Enums.TimeMode[] | ListEnumTimeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TimeMode[] | ListEnumTimeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumTimeModeWithAggregatesFilter<$PrismaModel> | $Enums.TimeMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTimeModeFilter<$PrismaModel>
    _max?: NestedEnumTimeModeFilter<$PrismaModel>
  }

  export type NestedEnumWrongAnswerModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WrongAnswerMode | EnumWrongAnswerModeFieldRefInput<$PrismaModel>
    in?: $Enums.WrongAnswerMode[] | ListEnumWrongAnswerModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WrongAnswerMode[] | ListEnumWrongAnswerModeFieldRefInput<$PrismaModel>
    not?: NestedEnumWrongAnswerModeWithAggregatesFilter<$PrismaModel> | $Enums.WrongAnswerMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWrongAnswerModeFilter<$PrismaModel>
    _max?: NestedEnumWrongAnswerModeFilter<$PrismaModel>
  }

  export type NestedEnumResultModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResultMode | EnumResultModeFieldRefInput<$PrismaModel>
    in?: $Enums.ResultMode[] | ListEnumResultModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResultMode[] | ListEnumResultModeFieldRefInput<$PrismaModel>
    not?: NestedEnumResultModeWithAggregatesFilter<$PrismaModel> | $Enums.ResultMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResultModeFilter<$PrismaModel>
    _max?: NestedEnumResultModeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AdminCreateWithoutCreatedAdminsInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: AdminCreateNestedOneWithoutCreatedAdminsInput
    questions?: QuestionPoolCreateNestedManyWithoutAuthorInput
    quizPapers?: QuizPaperCreateNestedManyWithoutAuthorInput
  }

  export type AdminUncheckedCreateWithoutCreatedAdminsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionPoolUncheckedCreateNestedManyWithoutAuthorInput
    quizPapers?: QuizPaperUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AdminCreateOrConnectWithoutCreatedAdminsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCreatedAdminsInput, AdminUncheckedCreateWithoutCreatedAdminsInput>
  }

  export type AdminCreateWithoutCreatorInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminCreateNestedManyWithoutCreatorInput
    questions?: QuestionPoolCreateNestedManyWithoutAuthorInput
    quizPapers?: QuizPaperCreateNestedManyWithoutAuthorInput
  }

  export type AdminUncheckedCreateWithoutCreatorInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminUncheckedCreateNestedManyWithoutCreatorInput
    questions?: QuestionPoolUncheckedCreateNestedManyWithoutAuthorInput
    quizPapers?: QuizPaperUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AdminCreateOrConnectWithoutCreatorInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCreatorInput, AdminUncheckedCreateWithoutCreatorInput>
  }

  export type AdminCreateManyCreatorInputEnvelope = {
    data: AdminCreateManyCreatorInput | AdminCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type QuestionPoolCreateWithoutAuthorInput = {
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
    quizPaperQuestions?: QuizPaperQuestionCreateNestedManyWithoutQuestionInput
    questionAttempts?: QuestionAttemptCreateNestedManyWithoutQuestionInput
  }

  export type QuestionPoolUncheckedCreateWithoutAuthorInput = {
    id?: number
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
    quizPaperQuestions?: QuizPaperQuestionUncheckedCreateNestedManyWithoutQuestionInput
    questionAttempts?: QuestionAttemptUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionPoolCreateOrConnectWithoutAuthorInput = {
    where: QuestionPoolWhereUniqueInput
    create: XOR<QuestionPoolCreateWithoutAuthorInput, QuestionPoolUncheckedCreateWithoutAuthorInput>
  }

  export type QuestionPoolCreateManyAuthorInputEnvelope = {
    data: QuestionPoolCreateManyAuthorInput | QuestionPoolCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type QuizPaperCreateWithoutAuthorInput = {
    title: string
    createdAt?: Date | string
    questions?: QuizPaperQuestionCreateNestedManyWithoutQuizPaperInput
    assignments?: QuizAssignmentCreateNestedManyWithoutQuizPaperInput
  }

  export type QuizPaperUncheckedCreateWithoutAuthorInput = {
    id?: number
    title: string
    createdAt?: Date | string
    questions?: QuizPaperQuestionUncheckedCreateNestedManyWithoutQuizPaperInput
    assignments?: QuizAssignmentUncheckedCreateNestedManyWithoutQuizPaperInput
  }

  export type QuizPaperCreateOrConnectWithoutAuthorInput = {
    where: QuizPaperWhereUniqueInput
    create: XOR<QuizPaperCreateWithoutAuthorInput, QuizPaperUncheckedCreateWithoutAuthorInput>
  }

  export type QuizPaperCreateManyAuthorInputEnvelope = {
    data: QuizPaperCreateManyAuthorInput | QuizPaperCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutCreatedAdminsInput = {
    update: XOR<AdminUpdateWithoutCreatedAdminsInput, AdminUncheckedUpdateWithoutCreatedAdminsInput>
    create: XOR<AdminCreateWithoutCreatedAdminsInput, AdminUncheckedCreateWithoutCreatedAdminsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCreatedAdminsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCreatedAdminsInput, AdminUncheckedUpdateWithoutCreatedAdminsInput>
  }

  export type AdminUpdateWithoutCreatedAdminsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AdminUpdateOneWithoutCreatedAdminsNestedInput
    questions?: QuestionPoolUpdateManyWithoutAuthorNestedInput
    quizPapers?: QuizPaperUpdateManyWithoutAuthorNestedInput
  }

  export type AdminUncheckedUpdateWithoutCreatedAdminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionPoolUncheckedUpdateManyWithoutAuthorNestedInput
    quizPapers?: QuizPaperUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AdminUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AdminWhereUniqueInput
    update: XOR<AdminUpdateWithoutCreatorInput, AdminUncheckedUpdateWithoutCreatorInput>
    create: XOR<AdminCreateWithoutCreatorInput, AdminUncheckedCreateWithoutCreatorInput>
  }

  export type AdminUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AdminWhereUniqueInput
    data: XOR<AdminUpdateWithoutCreatorInput, AdminUncheckedUpdateWithoutCreatorInput>
  }

  export type AdminUpdateManyWithWhereWithoutCreatorInput = {
    where: AdminScalarWhereInput
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AdminScalarWhereInput = {
    AND?: AdminScalarWhereInput | AdminScalarWhereInput[]
    OR?: AdminScalarWhereInput[]
    NOT?: AdminScalarWhereInput | AdminScalarWhereInput[]
    id?: IntFilter<"Admin"> | number
    first_name?: StringFilter<"Admin"> | string
    last_name?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    password?: StringFilter<"Admin"> | string
    adminType?: EnumAdminTypeFilter<"Admin"> | $Enums.AdminType
    organization?: StringNullableFilter<"Admin"> | string | null
    bio?: StringNullableFilter<"Admin"> | string | null
    profile_image?: StringNullableFilter<"Admin"> | string | null
    contactPhone?: StringNullableFilter<"Admin"> | string | null
    website?: StringNullableFilter<"Admin"> | string | null
    isVerified?: BoolFilter<"Admin"> | boolean
    isActive?: BoolFilter<"Admin"> | boolean
    lastLogin?: DateTimeNullableFilter<"Admin"> | Date | string | null
    createdBy?: IntNullableFilter<"Admin"> | number | null
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
  }

  export type QuestionPoolUpsertWithWhereUniqueWithoutAuthorInput = {
    where: QuestionPoolWhereUniqueInput
    update: XOR<QuestionPoolUpdateWithoutAuthorInput, QuestionPoolUncheckedUpdateWithoutAuthorInput>
    create: XOR<QuestionPoolCreateWithoutAuthorInput, QuestionPoolUncheckedCreateWithoutAuthorInput>
  }

  export type QuestionPoolUpdateWithWhereUniqueWithoutAuthorInput = {
    where: QuestionPoolWhereUniqueInput
    data: XOR<QuestionPoolUpdateWithoutAuthorInput, QuestionPoolUncheckedUpdateWithoutAuthorInput>
  }

  export type QuestionPoolUpdateManyWithWhereWithoutAuthorInput = {
    where: QuestionPoolScalarWhereInput
    data: XOR<QuestionPoolUpdateManyMutationInput, QuestionPoolUncheckedUpdateManyWithoutAuthorInput>
  }

  export type QuestionPoolScalarWhereInput = {
    AND?: QuestionPoolScalarWhereInput | QuestionPoolScalarWhereInput[]
    OR?: QuestionPoolScalarWhereInput[]
    NOT?: QuestionPoolScalarWhereInput | QuestionPoolScalarWhereInput[]
    id?: IntFilter<"QuestionPool"> | number
    authorId?: IntFilter<"QuestionPool"> | number
    questionText?: StringFilter<"QuestionPool"> | string
    questionType?: EnumQuestionTypeFilter<"QuestionPool"> | $Enums.QuestionType
    metadata?: JsonNullableFilter<"QuestionPool">
    explanation?: StringNullableFilter<"QuestionPool"> | string | null
    timeLimitSec?: IntNullableFilter<"QuestionPool"> | number | null
    points?: IntFilter<"QuestionPool"> | number
    option1?: StringNullableFilter<"QuestionPool"> | string | null
    option2?: StringNullableFilter<"QuestionPool"> | string | null
    option3?: StringNullableFilter<"QuestionPool"> | string | null
    option4?: StringNullableFilter<"QuestionPool"> | string | null
    option5?: StringNullableFilter<"QuestionPool"> | string | null
    option6?: StringNullableFilter<"QuestionPool"> | string | null
    answer?: StringNullableFilter<"QuestionPool"> | string | null
    createdAt?: DateTimeFilter<"QuestionPool"> | Date | string
  }

  export type QuizPaperUpsertWithWhereUniqueWithoutAuthorInput = {
    where: QuizPaperWhereUniqueInput
    update: XOR<QuizPaperUpdateWithoutAuthorInput, QuizPaperUncheckedUpdateWithoutAuthorInput>
    create: XOR<QuizPaperCreateWithoutAuthorInput, QuizPaperUncheckedCreateWithoutAuthorInput>
  }

  export type QuizPaperUpdateWithWhereUniqueWithoutAuthorInput = {
    where: QuizPaperWhereUniqueInput
    data: XOR<QuizPaperUpdateWithoutAuthorInput, QuizPaperUncheckedUpdateWithoutAuthorInput>
  }

  export type QuizPaperUpdateManyWithWhereWithoutAuthorInput = {
    where: QuizPaperScalarWhereInput
    data: XOR<QuizPaperUpdateManyMutationInput, QuizPaperUncheckedUpdateManyWithoutAuthorInput>
  }

  export type QuizPaperScalarWhereInput = {
    AND?: QuizPaperScalarWhereInput | QuizPaperScalarWhereInput[]
    OR?: QuizPaperScalarWhereInput[]
    NOT?: QuizPaperScalarWhereInput | QuizPaperScalarWhereInput[]
    id?: IntFilter<"QuizPaper"> | number
    authorId?: IntFilter<"QuizPaper"> | number
    title?: StringFilter<"QuizPaper"> | string
    createdAt?: DateTimeFilter<"QuizPaper"> | Date | string
  }

  export type LearnerCreateWithoutCreatedLearnersInput = {
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    creator?: LearnerCreateNestedOneWithoutCreatedLearnersInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardCreateNestedManyWithoutLearnerInput
  }

  export type LearnerUncheckedCreateWithoutCreatedLearnersInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutLearnerInput
  }

  export type LearnerCreateOrConnectWithoutCreatedLearnersInput = {
    where: LearnerWhereUniqueInput
    create: XOR<LearnerCreateWithoutCreatedLearnersInput, LearnerUncheckedCreateWithoutCreatedLearnersInput>
  }

  export type LearnerCreateWithoutCreatorInput = {
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    createdLearners?: LearnerCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardCreateNestedManyWithoutLearnerInput
  }

  export type LearnerUncheckedCreateWithoutCreatorInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    createdLearners?: LearnerUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutLearnerInput
  }

  export type LearnerCreateOrConnectWithoutCreatorInput = {
    where: LearnerWhereUniqueInput
    create: XOR<LearnerCreateWithoutCreatorInput, LearnerUncheckedCreateWithoutCreatorInput>
  }

  export type LearnerCreateManyCreatorInputEnvelope = {
    data: LearnerCreateManyCreatorInput | LearnerCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentCreateWithoutLearnerInput = {
    enrolledAt?: Date | string
    program: ProgramCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutLearnerInput = {
    id?: number
    programId: number
    enrolledAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutLearnerInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutLearnerInput, EnrollmentUncheckedCreateWithoutLearnerInput>
  }

  export type EnrollmentCreateManyLearnerInputEnvelope = {
    data: EnrollmentCreateManyLearnerInput | EnrollmentCreateManyLearnerInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutLearnerInput = {
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
    assignment: QuizAssignmentCreateNestedOneWithoutQuizAttemptsInput
    questionAttempts?: QuestionAttemptCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateWithoutLearnerInput = {
    id?: number
    assignmentId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
    questionAttempts?: QuestionAttemptUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptCreateOrConnectWithoutLearnerInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutLearnerInput, QuizAttemptUncheckedCreateWithoutLearnerInput>
  }

  export type QuizAttemptCreateManyLearnerInputEnvelope = {
    data: QuizAttemptCreateManyLearnerInput | QuizAttemptCreateManyLearnerInput[]
    skipDuplicates?: boolean
  }

  export type ResourceViewCreateWithoutLearnerInput = {
    viewedAt?: Date | string
    resource: ResourceCreateNestedOneWithoutResourceViewsInput
  }

  export type ResourceViewUncheckedCreateWithoutLearnerInput = {
    resourceId: number
    viewedAt?: Date | string
  }

  export type ResourceViewCreateOrConnectWithoutLearnerInput = {
    where: ResourceViewWhereUniqueInput
    create: XOR<ResourceViewCreateWithoutLearnerInput, ResourceViewUncheckedCreateWithoutLearnerInput>
  }

  export type ResourceViewCreateManyLearnerInputEnvelope = {
    data: ResourceViewCreateManyLearnerInput | ResourceViewCreateManyLearnerInput[]
    skipDuplicates?: boolean
  }

  export type MeasureProgressCreateWithoutLearnerInput = {
    completedAt: Date | string
    progressType: string
    status: string
    topic: TopicCreateNestedOneWithoutMeasureProgressInput
    program?: ProgramCreateNestedOneWithoutMeasureProgressInput
    module?: ModuleCreateNestedOneWithoutMeasureProgressInput
    resource?: ResourceCreateNestedOneWithoutMeasureProgressInput
  }

  export type MeasureProgressUncheckedCreateWithoutLearnerInput = {
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    moduleId?: number | null
    resourceId?: number | null
  }

  export type MeasureProgressCreateOrConnectWithoutLearnerInput = {
    where: MeasureProgressWhereUniqueInput
    create: XOR<MeasureProgressCreateWithoutLearnerInput, MeasureProgressUncheckedCreateWithoutLearnerInput>
  }

  export type MeasureProgressCreateManyLearnerInputEnvelope = {
    data: MeasureProgressCreateManyLearnerInput | MeasureProgressCreateManyLearnerInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardCreateWithoutLearnerInput = {
    totalScore: Decimal | DecimalJsLike | number | string
    lastAttemptAt?: Date | string | null
    program: ProgramCreateNestedOneWithoutLeaderboardsInput
  }

  export type LeaderboardUncheckedCreateWithoutLearnerInput = {
    programId: number
    totalScore: Decimal | DecimalJsLike | number | string
    lastAttemptAt?: Date | string | null
  }

  export type LeaderboardCreateOrConnectWithoutLearnerInput = {
    where: LeaderboardWhereUniqueInput
    create: XOR<LeaderboardCreateWithoutLearnerInput, LeaderboardUncheckedCreateWithoutLearnerInput>
  }

  export type LeaderboardCreateManyLearnerInputEnvelope = {
    data: LeaderboardCreateManyLearnerInput | LeaderboardCreateManyLearnerInput[]
    skipDuplicates?: boolean
  }

  export type LearnerUpsertWithoutCreatedLearnersInput = {
    update: XOR<LearnerUpdateWithoutCreatedLearnersInput, LearnerUncheckedUpdateWithoutCreatedLearnersInput>
    create: XOR<LearnerCreateWithoutCreatedLearnersInput, LearnerUncheckedCreateWithoutCreatedLearnersInput>
    where?: LearnerWhereInput
  }

  export type LearnerUpdateToOneWithWhereWithoutCreatedLearnersInput = {
    where?: LearnerWhereInput
    data: XOR<LearnerUpdateWithoutCreatedLearnersInput, LearnerUncheckedUpdateWithoutCreatedLearnersInput>
  }

  export type LearnerUpdateWithoutCreatedLearnersInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    creator?: LearnerUpdateOneWithoutCreatedLearnersNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUncheckedUpdateWithoutCreatedLearnersInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUpsertWithWhereUniqueWithoutCreatorInput = {
    where: LearnerWhereUniqueInput
    update: XOR<LearnerUpdateWithoutCreatorInput, LearnerUncheckedUpdateWithoutCreatorInput>
    create: XOR<LearnerCreateWithoutCreatorInput, LearnerUncheckedCreateWithoutCreatorInput>
  }

  export type LearnerUpdateWithWhereUniqueWithoutCreatorInput = {
    where: LearnerWhereUniqueInput
    data: XOR<LearnerUpdateWithoutCreatorInput, LearnerUncheckedUpdateWithoutCreatorInput>
  }

  export type LearnerUpdateManyWithWhereWithoutCreatorInput = {
    where: LearnerScalarWhereInput
    data: XOR<LearnerUpdateManyMutationInput, LearnerUncheckedUpdateManyWithoutCreatorInput>
  }

  export type LearnerScalarWhereInput = {
    AND?: LearnerScalarWhereInput | LearnerScalarWhereInput[]
    OR?: LearnerScalarWhereInput[]
    NOT?: LearnerScalarWhereInput | LearnerScalarWhereInput[]
    id?: IntFilter<"Learner"> | number
    first_name?: StringFilter<"Learner"> | string
    last_name?: StringFilter<"Learner"> | string
    gender?: StringNullableFilter<"Learner"> | string | null
    dob?: DateTimeNullableFilter<"Learner"> | Date | string | null
    email?: StringFilter<"Learner"> | string
    phone?: BytesNullableFilter<"Learner"> | Uint8Array | null
    communicationEmail?: BytesNullableFilter<"Learner"> | Uint8Array | null
    password?: StringNullableFilter<"Learner"> | string | null
    profile_image?: StringNullableFilter<"Learner"> | string | null
    organisation?: StringNullableFilter<"Learner"> | string | null
    designation?: StringNullableFilter<"Learner"> | string | null
    department?: StringNullableFilter<"Learner"> | string | null
    location?: StringNullableFilter<"Learner"> | string | null
    hierarchy_level?: StringNullableFilter<"Learner"> | string | null
    totalPoints?: IntFilter<"Learner"> | number
    isActive?: BoolFilter<"Learner"> | boolean
    isDeleted?: BoolFilter<"Learner"> | boolean
    deletedAt?: DateTimeNullableFilter<"Learner"> | Date | string | null
    isVerified?: BoolFilter<"Learner"> | boolean
    lastLogin?: DateTimeNullableFilter<"Learner"> | Date | string | null
    createdBy?: IntNullableFilter<"Learner"> | number | null
    createdAt?: DateTimeFilter<"Learner"> | Date | string
    updatedAt?: DateTimeFilter<"Learner"> | Date | string
    uniqueHash?: StringNullableFilter<"Learner"> | string | null
    status?: IntNullableFilter<"Learner"> | number | null
    extraConfig?: StringNullableFilter<"Learner"> | string | null
    metaData?: StringNullableFilter<"Learner"> | string | null
    role?: StringFilter<"Learner"> | string
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutLearnerInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutLearnerInput, EnrollmentUncheckedUpdateWithoutLearnerInput>
    create: XOR<EnrollmentCreateWithoutLearnerInput, EnrollmentUncheckedCreateWithoutLearnerInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutLearnerInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutLearnerInput, EnrollmentUncheckedUpdateWithoutLearnerInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutLearnerInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutLearnerInput>
  }

  export type EnrollmentScalarWhereInput = {
    AND?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    OR?: EnrollmentScalarWhereInput[]
    NOT?: EnrollmentScalarWhereInput | EnrollmentScalarWhereInput[]
    id?: IntFilter<"Enrollment"> | number
    learnerId?: IntFilter<"Enrollment"> | number
    programId?: IntFilter<"Enrollment"> | number
    enrolledAt?: DateTimeFilter<"Enrollment"> | Date | string
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutLearnerInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutLearnerInput, QuizAttemptUncheckedUpdateWithoutLearnerInput>
    create: XOR<QuizAttemptCreateWithoutLearnerInput, QuizAttemptUncheckedCreateWithoutLearnerInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutLearnerInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutLearnerInput, QuizAttemptUncheckedUpdateWithoutLearnerInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutLearnerInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutLearnerInput>
  }

  export type QuizAttemptScalarWhereInput = {
    AND?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    OR?: QuizAttemptScalarWhereInput[]
    NOT?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    id?: IntFilter<"QuizAttempt"> | number
    assignmentId?: IntFilter<"QuizAttempt"> | number
    learnerId?: IntFilter<"QuizAttempt"> | number
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    submittedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    totalTimeSpent?: IntNullableFilter<"QuizAttempt"> | number | null
    score?: DecimalNullableFilter<"QuizAttempt"> | Decimal | DecimalJsLike | number | string | null
    passed?: BoolNullableFilter<"QuizAttempt"> | boolean | null
    status?: StringFilter<"QuizAttempt"> | string
    createdAt?: DateTimeFilter<"QuizAttempt"> | Date | string
  }

  export type ResourceViewUpsertWithWhereUniqueWithoutLearnerInput = {
    where: ResourceViewWhereUniqueInput
    update: XOR<ResourceViewUpdateWithoutLearnerInput, ResourceViewUncheckedUpdateWithoutLearnerInput>
    create: XOR<ResourceViewCreateWithoutLearnerInput, ResourceViewUncheckedCreateWithoutLearnerInput>
  }

  export type ResourceViewUpdateWithWhereUniqueWithoutLearnerInput = {
    where: ResourceViewWhereUniqueInput
    data: XOR<ResourceViewUpdateWithoutLearnerInput, ResourceViewUncheckedUpdateWithoutLearnerInput>
  }

  export type ResourceViewUpdateManyWithWhereWithoutLearnerInput = {
    where: ResourceViewScalarWhereInput
    data: XOR<ResourceViewUpdateManyMutationInput, ResourceViewUncheckedUpdateManyWithoutLearnerInput>
  }

  export type ResourceViewScalarWhereInput = {
    AND?: ResourceViewScalarWhereInput | ResourceViewScalarWhereInput[]
    OR?: ResourceViewScalarWhereInput[]
    NOT?: ResourceViewScalarWhereInput | ResourceViewScalarWhereInput[]
    learnerId?: IntFilter<"ResourceView"> | number
    resourceId?: IntFilter<"ResourceView"> | number
    viewedAt?: DateTimeFilter<"ResourceView"> | Date | string
  }

  export type MeasureProgressUpsertWithWhereUniqueWithoutLearnerInput = {
    where: MeasureProgressWhereUniqueInput
    update: XOR<MeasureProgressUpdateWithoutLearnerInput, MeasureProgressUncheckedUpdateWithoutLearnerInput>
    create: XOR<MeasureProgressCreateWithoutLearnerInput, MeasureProgressUncheckedCreateWithoutLearnerInput>
  }

  export type MeasureProgressUpdateWithWhereUniqueWithoutLearnerInput = {
    where: MeasureProgressWhereUniqueInput
    data: XOR<MeasureProgressUpdateWithoutLearnerInput, MeasureProgressUncheckedUpdateWithoutLearnerInput>
  }

  export type MeasureProgressUpdateManyWithWhereWithoutLearnerInput = {
    where: MeasureProgressScalarWhereInput
    data: XOR<MeasureProgressUpdateManyMutationInput, MeasureProgressUncheckedUpdateManyWithoutLearnerInput>
  }

  export type MeasureProgressScalarWhereInput = {
    AND?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
    OR?: MeasureProgressScalarWhereInput[]
    NOT?: MeasureProgressScalarWhereInput | MeasureProgressScalarWhereInput[]
    learnerId?: IntFilter<"MeasureProgress"> | number
    topicId?: IntFilter<"MeasureProgress"> | number
    completedAt?: DateTimeFilter<"MeasureProgress"> | Date | string
    progressType?: StringFilter<"MeasureProgress"> | string
    status?: StringFilter<"MeasureProgress"> | string
    programId?: IntNullableFilter<"MeasureProgress"> | number | null
    moduleId?: IntNullableFilter<"MeasureProgress"> | number | null
    resourceId?: IntNullableFilter<"MeasureProgress"> | number | null
  }

  export type LeaderboardUpsertWithWhereUniqueWithoutLearnerInput = {
    where: LeaderboardWhereUniqueInput
    update: XOR<LeaderboardUpdateWithoutLearnerInput, LeaderboardUncheckedUpdateWithoutLearnerInput>
    create: XOR<LeaderboardCreateWithoutLearnerInput, LeaderboardUncheckedCreateWithoutLearnerInput>
  }

  export type LeaderboardUpdateWithWhereUniqueWithoutLearnerInput = {
    where: LeaderboardWhereUniqueInput
    data: XOR<LeaderboardUpdateWithoutLearnerInput, LeaderboardUncheckedUpdateWithoutLearnerInput>
  }

  export type LeaderboardUpdateManyWithWhereWithoutLearnerInput = {
    where: LeaderboardScalarWhereInput
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyWithoutLearnerInput>
  }

  export type LeaderboardScalarWhereInput = {
    AND?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
    OR?: LeaderboardScalarWhereInput[]
    NOT?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
    programId?: IntFilter<"Leaderboard"> | number
    learnerId?: IntFilter<"Leaderboard"> | number
    totalScore?: DecimalFilter<"Leaderboard"> | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: DateTimeNullableFilter<"Leaderboard"> | Date | string | null
  }

  export type EnrollmentCreateWithoutProgramInput = {
    enrolledAt?: Date | string
    learner: LearnerCreateNestedOneWithoutEnrollmentsInput
  }

  export type EnrollmentUncheckedCreateWithoutProgramInput = {
    id?: number
    learnerId: number
    enrolledAt?: Date | string
  }

  export type EnrollmentCreateOrConnectWithoutProgramInput = {
    where: EnrollmentWhereUniqueInput
    create: XOR<EnrollmentCreateWithoutProgramInput, EnrollmentUncheckedCreateWithoutProgramInput>
  }

  export type EnrollmentCreateManyProgramInputEnvelope = {
    data: EnrollmentCreateManyProgramInput | EnrollmentCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type QuizAssignmentCreateWithoutProgramInput = {
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    quizPaper: QuizPaperCreateNestedOneWithoutAssignmentsInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutAssignmentInput
  }

  export type QuizAssignmentUncheckedCreateWithoutProgramInput = {
    id?: number
    quizPaperId: number
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type QuizAssignmentCreateOrConnectWithoutProgramInput = {
    where: QuizAssignmentWhereUniqueInput
    create: XOR<QuizAssignmentCreateWithoutProgramInput, QuizAssignmentUncheckedCreateWithoutProgramInput>
  }

  export type QuizAssignmentCreateManyProgramInputEnvelope = {
    data: QuizAssignmentCreateManyProgramInput | QuizAssignmentCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type MeasureProgressCreateWithoutProgramInput = {
    completedAt: Date | string
    progressType: string
    status: string
    learner: LearnerCreateNestedOneWithoutMeasureProgressInput
    topic: TopicCreateNestedOneWithoutMeasureProgressInput
    module?: ModuleCreateNestedOneWithoutMeasureProgressInput
    resource?: ResourceCreateNestedOneWithoutMeasureProgressInput
  }

  export type MeasureProgressUncheckedCreateWithoutProgramInput = {
    learnerId: number
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    moduleId?: number | null
    resourceId?: number | null
  }

  export type MeasureProgressCreateOrConnectWithoutProgramInput = {
    where: MeasureProgressWhereUniqueInput
    create: XOR<MeasureProgressCreateWithoutProgramInput, MeasureProgressUncheckedCreateWithoutProgramInput>
  }

  export type MeasureProgressCreateManyProgramInputEnvelope = {
    data: MeasureProgressCreateManyProgramInput | MeasureProgressCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardCreateWithoutProgramInput = {
    totalScore: Decimal | DecimalJsLike | number | string
    lastAttemptAt?: Date | string | null
    learner: LearnerCreateNestedOneWithoutLeaderboardsInput
  }

  export type LeaderboardUncheckedCreateWithoutProgramInput = {
    learnerId: number
    totalScore: Decimal | DecimalJsLike | number | string
    lastAttemptAt?: Date | string | null
  }

  export type LeaderboardCreateOrConnectWithoutProgramInput = {
    where: LeaderboardWhereUniqueInput
    create: XOR<LeaderboardCreateWithoutProgramInput, LeaderboardUncheckedCreateWithoutProgramInput>
  }

  export type LeaderboardCreateManyProgramInputEnvelope = {
    data: LeaderboardCreateManyProgramInput | LeaderboardCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ProgramModuleCreateWithoutProgramInput = {
    position: number
    module: ModuleCreateNestedOneWithoutProgramModulesInput
  }

  export type ProgramModuleUncheckedCreateWithoutProgramInput = {
    moduleId: number
    position: number
  }

  export type ProgramModuleCreateOrConnectWithoutProgramInput = {
    where: ProgramModuleWhereUniqueInput
    create: XOR<ProgramModuleCreateWithoutProgramInput, ProgramModuleUncheckedCreateWithoutProgramInput>
  }

  export type ProgramModuleCreateManyProgramInputEnvelope = {
    data: ProgramModuleCreateManyProgramInput | ProgramModuleCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type EnrollmentUpsertWithWhereUniqueWithoutProgramInput = {
    where: EnrollmentWhereUniqueInput
    update: XOR<EnrollmentUpdateWithoutProgramInput, EnrollmentUncheckedUpdateWithoutProgramInput>
    create: XOR<EnrollmentCreateWithoutProgramInput, EnrollmentUncheckedCreateWithoutProgramInput>
  }

  export type EnrollmentUpdateWithWhereUniqueWithoutProgramInput = {
    where: EnrollmentWhereUniqueInput
    data: XOR<EnrollmentUpdateWithoutProgramInput, EnrollmentUncheckedUpdateWithoutProgramInput>
  }

  export type EnrollmentUpdateManyWithWhereWithoutProgramInput = {
    where: EnrollmentScalarWhereInput
    data: XOR<EnrollmentUpdateManyMutationInput, EnrollmentUncheckedUpdateManyWithoutProgramInput>
  }

  export type QuizAssignmentUpsertWithWhereUniqueWithoutProgramInput = {
    where: QuizAssignmentWhereUniqueInput
    update: XOR<QuizAssignmentUpdateWithoutProgramInput, QuizAssignmentUncheckedUpdateWithoutProgramInput>
    create: XOR<QuizAssignmentCreateWithoutProgramInput, QuizAssignmentUncheckedCreateWithoutProgramInput>
  }

  export type QuizAssignmentUpdateWithWhereUniqueWithoutProgramInput = {
    where: QuizAssignmentWhereUniqueInput
    data: XOR<QuizAssignmentUpdateWithoutProgramInput, QuizAssignmentUncheckedUpdateWithoutProgramInput>
  }

  export type QuizAssignmentUpdateManyWithWhereWithoutProgramInput = {
    where: QuizAssignmentScalarWhereInput
    data: XOR<QuizAssignmentUpdateManyMutationInput, QuizAssignmentUncheckedUpdateManyWithoutProgramInput>
  }

  export type QuizAssignmentScalarWhereInput = {
    AND?: QuizAssignmentScalarWhereInput | QuizAssignmentScalarWhereInput[]
    OR?: QuizAssignmentScalarWhereInput[]
    NOT?: QuizAssignmentScalarWhereInput | QuizAssignmentScalarWhereInput[]
    id?: IntFilter<"QuizAssignment"> | number
    quizPaperId?: IntFilter<"QuizAssignment"> | number
    programId?: IntNullableFilter<"QuizAssignment"> | number | null
    startAt?: DateTimeNullableFilter<"QuizAssignment"> | Date | string | null
    endAt?: DateTimeNullableFilter<"QuizAssignment"> | Date | string | null
    uniqueLinkToken?: UuidFilter<"QuizAssignment"> | string
    timeMode?: EnumTimeModeFilter<"QuizAssignment"> | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFilter<"QuizAssignment"> | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFilter<"QuizAssignment"> | $Enums.ResultMode
    totalTimeLimit?: IntNullableFilter<"QuizAssignment"> | number | null
    passingScore?: IntNullableFilter<"QuizAssignment"> | number | null
    enabled?: BoolFilter<"QuizAssignment"> | boolean
    isDeleted?: BoolFilter<"QuizAssignment"> | boolean
    deletedAt?: DateTimeNullableFilter<"QuizAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"QuizAssignment"> | Date | string
  }

  export type MeasureProgressUpsertWithWhereUniqueWithoutProgramInput = {
    where: MeasureProgressWhereUniqueInput
    update: XOR<MeasureProgressUpdateWithoutProgramInput, MeasureProgressUncheckedUpdateWithoutProgramInput>
    create: XOR<MeasureProgressCreateWithoutProgramInput, MeasureProgressUncheckedCreateWithoutProgramInput>
  }

  export type MeasureProgressUpdateWithWhereUniqueWithoutProgramInput = {
    where: MeasureProgressWhereUniqueInput
    data: XOR<MeasureProgressUpdateWithoutProgramInput, MeasureProgressUncheckedUpdateWithoutProgramInput>
  }

  export type MeasureProgressUpdateManyWithWhereWithoutProgramInput = {
    where: MeasureProgressScalarWhereInput
    data: XOR<MeasureProgressUpdateManyMutationInput, MeasureProgressUncheckedUpdateManyWithoutProgramInput>
  }

  export type LeaderboardUpsertWithWhereUniqueWithoutProgramInput = {
    where: LeaderboardWhereUniqueInput
    update: XOR<LeaderboardUpdateWithoutProgramInput, LeaderboardUncheckedUpdateWithoutProgramInput>
    create: XOR<LeaderboardCreateWithoutProgramInput, LeaderboardUncheckedCreateWithoutProgramInput>
  }

  export type LeaderboardUpdateWithWhereUniqueWithoutProgramInput = {
    where: LeaderboardWhereUniqueInput
    data: XOR<LeaderboardUpdateWithoutProgramInput, LeaderboardUncheckedUpdateWithoutProgramInput>
  }

  export type LeaderboardUpdateManyWithWhereWithoutProgramInput = {
    where: LeaderboardScalarWhereInput
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramModuleUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramModuleWhereUniqueInput
    update: XOR<ProgramModuleUpdateWithoutProgramInput, ProgramModuleUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramModuleCreateWithoutProgramInput, ProgramModuleUncheckedCreateWithoutProgramInput>
  }

  export type ProgramModuleUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramModuleWhereUniqueInput
    data: XOR<ProgramModuleUpdateWithoutProgramInput, ProgramModuleUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramModuleUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramModuleScalarWhereInput
    data: XOR<ProgramModuleUpdateManyMutationInput, ProgramModuleUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramModuleScalarWhereInput = {
    AND?: ProgramModuleScalarWhereInput | ProgramModuleScalarWhereInput[]
    OR?: ProgramModuleScalarWhereInput[]
    NOT?: ProgramModuleScalarWhereInput | ProgramModuleScalarWhereInput[]
    programId?: IntFilter<"ProgramModule"> | number
    moduleId?: IntFilter<"ProgramModule"> | number
    position?: IntFilter<"ProgramModule"> | number
  }

  export type ModuleCreateWithoutDependentModulesInput = {
    title: string
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteModule?: ModuleCreateNestedOneWithoutDependentModulesInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutModuleInput
    programModules?: ProgramModuleCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutDependentModulesInput = {
    id?: number
    title: string
    description?: string | null
    prerequisiteModuleId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutModuleInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutDependentModulesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutDependentModulesInput, ModuleUncheckedCreateWithoutDependentModulesInput>
  }

  export type ModuleCreateWithoutPrerequisiteModuleInput = {
    title: string
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentModules?: ModuleCreateNestedManyWithoutPrerequisiteModuleInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutModuleInput
    programModules?: ProgramModuleCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutPrerequisiteModuleInput = {
    id?: number
    title: string
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentModules?: ModuleUncheckedCreateNestedManyWithoutPrerequisiteModuleInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutModuleInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutPrerequisiteModuleInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutPrerequisiteModuleInput, ModuleUncheckedCreateWithoutPrerequisiteModuleInput>
  }

  export type ModuleCreateManyPrerequisiteModuleInputEnvelope = {
    data: ModuleCreateManyPrerequisiteModuleInput | ModuleCreateManyPrerequisiteModuleInput[]
    skipDuplicates?: boolean
  }

  export type MeasureProgressCreateWithoutModuleInput = {
    completedAt: Date | string
    progressType: string
    status: string
    learner: LearnerCreateNestedOneWithoutMeasureProgressInput
    topic: TopicCreateNestedOneWithoutMeasureProgressInput
    program?: ProgramCreateNestedOneWithoutMeasureProgressInput
    resource?: ResourceCreateNestedOneWithoutMeasureProgressInput
  }

  export type MeasureProgressUncheckedCreateWithoutModuleInput = {
    learnerId: number
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    resourceId?: number | null
  }

  export type MeasureProgressCreateOrConnectWithoutModuleInput = {
    where: MeasureProgressWhereUniqueInput
    create: XOR<MeasureProgressCreateWithoutModuleInput, MeasureProgressUncheckedCreateWithoutModuleInput>
  }

  export type MeasureProgressCreateManyModuleInputEnvelope = {
    data: MeasureProgressCreateManyModuleInput | MeasureProgressCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ProgramModuleCreateWithoutModuleInput = {
    position: number
    program: ProgramCreateNestedOneWithoutProgramModulesInput
  }

  export type ProgramModuleUncheckedCreateWithoutModuleInput = {
    programId: number
    position: number
  }

  export type ProgramModuleCreateOrConnectWithoutModuleInput = {
    where: ProgramModuleWhereUniqueInput
    create: XOR<ProgramModuleCreateWithoutModuleInput, ProgramModuleUncheckedCreateWithoutModuleInput>
  }

  export type ProgramModuleCreateManyModuleInputEnvelope = {
    data: ProgramModuleCreateManyModuleInput | ProgramModuleCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleTopicCreateWithoutModuleInput = {
    position: number
    topic: TopicCreateNestedOneWithoutModuleTopicsInput
  }

  export type ModuleTopicUncheckedCreateWithoutModuleInput = {
    topicId: number
    position: number
  }

  export type ModuleTopicCreateOrConnectWithoutModuleInput = {
    where: ModuleTopicWhereUniqueInput
    create: XOR<ModuleTopicCreateWithoutModuleInput, ModuleTopicUncheckedCreateWithoutModuleInput>
  }

  export type ModuleTopicCreateManyModuleInputEnvelope = {
    data: ModuleTopicCreateManyModuleInput | ModuleTopicCreateManyModuleInput[]
    skipDuplicates?: boolean
  }

  export type ModuleUpsertWithoutDependentModulesInput = {
    update: XOR<ModuleUpdateWithoutDependentModulesInput, ModuleUncheckedUpdateWithoutDependentModulesInput>
    create: XOR<ModuleCreateWithoutDependentModulesInput, ModuleUncheckedCreateWithoutDependentModulesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutDependentModulesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutDependentModulesInput, ModuleUncheckedUpdateWithoutDependentModulesInput>
  }

  export type ModuleUpdateWithoutDependentModulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteModule?: ModuleUpdateOneWithoutDependentModulesNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutModuleNestedInput
    programModules?: ProgramModuleUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutDependentModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteModuleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutModuleNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUpsertWithWhereUniqueWithoutPrerequisiteModuleInput = {
    where: ModuleWhereUniqueInput
    update: XOR<ModuleUpdateWithoutPrerequisiteModuleInput, ModuleUncheckedUpdateWithoutPrerequisiteModuleInput>
    create: XOR<ModuleCreateWithoutPrerequisiteModuleInput, ModuleUncheckedCreateWithoutPrerequisiteModuleInput>
  }

  export type ModuleUpdateWithWhereUniqueWithoutPrerequisiteModuleInput = {
    where: ModuleWhereUniqueInput
    data: XOR<ModuleUpdateWithoutPrerequisiteModuleInput, ModuleUncheckedUpdateWithoutPrerequisiteModuleInput>
  }

  export type ModuleUpdateManyWithWhereWithoutPrerequisiteModuleInput = {
    where: ModuleScalarWhereInput
    data: XOR<ModuleUpdateManyMutationInput, ModuleUncheckedUpdateManyWithoutPrerequisiteModuleInput>
  }

  export type ModuleScalarWhereInput = {
    AND?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    OR?: ModuleScalarWhereInput[]
    NOT?: ModuleScalarWhereInput | ModuleScalarWhereInput[]
    id?: IntFilter<"Module"> | number
    title?: StringFilter<"Module"> | string
    description?: StringNullableFilter<"Module"> | string | null
    prerequisiteModuleId?: IntNullableFilter<"Module"> | number | null
    status?: IntNullableFilter<"Module"> | number | null
    isDeleted?: BoolFilter<"Module"> | boolean
    deletedAt?: DateTimeNullableFilter<"Module"> | Date | string | null
    createdAt?: DateTimeFilter<"Module"> | Date | string
    updatedAt?: DateTimeFilter<"Module"> | Date | string
  }

  export type MeasureProgressUpsertWithWhereUniqueWithoutModuleInput = {
    where: MeasureProgressWhereUniqueInput
    update: XOR<MeasureProgressUpdateWithoutModuleInput, MeasureProgressUncheckedUpdateWithoutModuleInput>
    create: XOR<MeasureProgressCreateWithoutModuleInput, MeasureProgressUncheckedCreateWithoutModuleInput>
  }

  export type MeasureProgressUpdateWithWhereUniqueWithoutModuleInput = {
    where: MeasureProgressWhereUniqueInput
    data: XOR<MeasureProgressUpdateWithoutModuleInput, MeasureProgressUncheckedUpdateWithoutModuleInput>
  }

  export type MeasureProgressUpdateManyWithWhereWithoutModuleInput = {
    where: MeasureProgressScalarWhereInput
    data: XOR<MeasureProgressUpdateManyMutationInput, MeasureProgressUncheckedUpdateManyWithoutModuleInput>
  }

  export type ProgramModuleUpsertWithWhereUniqueWithoutModuleInput = {
    where: ProgramModuleWhereUniqueInput
    update: XOR<ProgramModuleUpdateWithoutModuleInput, ProgramModuleUncheckedUpdateWithoutModuleInput>
    create: XOR<ProgramModuleCreateWithoutModuleInput, ProgramModuleUncheckedCreateWithoutModuleInput>
  }

  export type ProgramModuleUpdateWithWhereUniqueWithoutModuleInput = {
    where: ProgramModuleWhereUniqueInput
    data: XOR<ProgramModuleUpdateWithoutModuleInput, ProgramModuleUncheckedUpdateWithoutModuleInput>
  }

  export type ProgramModuleUpdateManyWithWhereWithoutModuleInput = {
    where: ProgramModuleScalarWhereInput
    data: XOR<ProgramModuleUpdateManyMutationInput, ProgramModuleUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleTopicUpsertWithWhereUniqueWithoutModuleInput = {
    where: ModuleTopicWhereUniqueInput
    update: XOR<ModuleTopicUpdateWithoutModuleInput, ModuleTopicUncheckedUpdateWithoutModuleInput>
    create: XOR<ModuleTopicCreateWithoutModuleInput, ModuleTopicUncheckedCreateWithoutModuleInput>
  }

  export type ModuleTopicUpdateWithWhereUniqueWithoutModuleInput = {
    where: ModuleTopicWhereUniqueInput
    data: XOR<ModuleTopicUpdateWithoutModuleInput, ModuleTopicUncheckedUpdateWithoutModuleInput>
  }

  export type ModuleTopicUpdateManyWithWhereWithoutModuleInput = {
    where: ModuleTopicScalarWhereInput
    data: XOR<ModuleTopicUpdateManyMutationInput, ModuleTopicUncheckedUpdateManyWithoutModuleInput>
  }

  export type ModuleTopicScalarWhereInput = {
    AND?: ModuleTopicScalarWhereInput | ModuleTopicScalarWhereInput[]
    OR?: ModuleTopicScalarWhereInput[]
    NOT?: ModuleTopicScalarWhereInput | ModuleTopicScalarWhereInput[]
    moduleId?: IntFilter<"ModuleTopic"> | number
    topicId?: IntFilter<"ModuleTopic"> | number
    position?: IntFilter<"ModuleTopic"> | number
  }

  export type LearnerCreateWithoutEnrollmentsInput = {
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    creator?: LearnerCreateNestedOneWithoutCreatedLearnersInput
    createdLearners?: LearnerCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardCreateNestedManyWithoutLearnerInput
  }

  export type LearnerUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    createdLearners?: LearnerUncheckedCreateNestedManyWithoutCreatorInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutLearnerInput
  }

  export type LearnerCreateOrConnectWithoutEnrollmentsInput = {
    where: LearnerWhereUniqueInput
    create: XOR<LearnerCreateWithoutEnrollmentsInput, LearnerUncheckedCreateWithoutEnrollmentsInput>
  }

  export type ProgramCreateWithoutEnrollmentsInput = {
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizAssignments?: QuizAssignmentCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutEnrollmentsInput = {
    id?: number
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizAssignments?: QuizAssignmentUncheckedCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutEnrollmentsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutEnrollmentsInput, ProgramUncheckedCreateWithoutEnrollmentsInput>
  }

  export type LearnerUpsertWithoutEnrollmentsInput = {
    update: XOR<LearnerUpdateWithoutEnrollmentsInput, LearnerUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<LearnerCreateWithoutEnrollmentsInput, LearnerUncheckedCreateWithoutEnrollmentsInput>
    where?: LearnerWhereInput
  }

  export type LearnerUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: LearnerWhereInput
    data: XOR<LearnerUpdateWithoutEnrollmentsInput, LearnerUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type LearnerUpdateWithoutEnrollmentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    creator?: LearnerUpdateOneWithoutCreatedLearnersNestedInput
    createdLearners?: LearnerUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdLearners?: LearnerUncheckedUpdateManyWithoutCreatorNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutLearnerNestedInput
  }

  export type ProgramUpsertWithoutEnrollmentsInput = {
    update: XOR<ProgramUpdateWithoutEnrollmentsInput, ProgramUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<ProgramCreateWithoutEnrollmentsInput, ProgramUncheckedCreateWithoutEnrollmentsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutEnrollmentsInput, ProgramUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type ProgramUpdateWithoutEnrollmentsInput = {
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizAssignments?: QuizAssignmentUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutEnrollmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizAssignments?: QuizAssignmentUncheckedUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateWithoutProgramModulesInput = {
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentCreateNestedManyWithoutProgramInput
    quizAssignments?: QuizAssignmentCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutProgramModulesInput = {
    id?: number
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProgramInput
    quizAssignments?: QuizAssignmentUncheckedCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutProgramModulesInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutProgramModulesInput, ProgramUncheckedCreateWithoutProgramModulesInput>
  }

  export type ModuleCreateWithoutProgramModulesInput = {
    title: string
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteModule?: ModuleCreateNestedOneWithoutDependentModulesInput
    dependentModules?: ModuleCreateNestedManyWithoutPrerequisiteModuleInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutProgramModulesInput = {
    id?: number
    title: string
    description?: string | null
    prerequisiteModuleId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentModules?: ModuleUncheckedCreateNestedManyWithoutPrerequisiteModuleInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutProgramModulesInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutProgramModulesInput, ModuleUncheckedCreateWithoutProgramModulesInput>
  }

  export type ProgramUpsertWithoutProgramModulesInput = {
    update: XOR<ProgramUpdateWithoutProgramModulesInput, ProgramUncheckedUpdateWithoutProgramModulesInput>
    create: XOR<ProgramCreateWithoutProgramModulesInput, ProgramUncheckedCreateWithoutProgramModulesInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutProgramModulesInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutProgramModulesInput, ProgramUncheckedUpdateWithoutProgramModulesInput>
  }

  export type ProgramUpdateWithoutProgramModulesInput = {
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUpdateManyWithoutProgramNestedInput
    quizAssignments?: QuizAssignmentUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutProgramModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProgramNestedInput
    quizAssignments?: QuizAssignmentUncheckedUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ModuleUpsertWithoutProgramModulesInput = {
    update: XOR<ModuleUpdateWithoutProgramModulesInput, ModuleUncheckedUpdateWithoutProgramModulesInput>
    create: XOR<ModuleCreateWithoutProgramModulesInput, ModuleUncheckedCreateWithoutProgramModulesInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutProgramModulesInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutProgramModulesInput, ModuleUncheckedUpdateWithoutProgramModulesInput>
  }

  export type ModuleUpdateWithoutProgramModulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteModule?: ModuleUpdateOneWithoutDependentModulesNestedInput
    dependentModules?: ModuleUpdateManyWithoutPrerequisiteModuleNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutProgramModulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteModuleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentModules?: ModuleUncheckedUpdateManyWithoutPrerequisiteModuleNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type TopicCreateWithoutDependentTopicsInput = {
    title: string
    content?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteTopic?: TopicCreateNestedOneWithoutDependentTopicsInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutTopicInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutDependentTopicsInput = {
    id?: number
    title: string
    content?: string | null
    prerequisiteTopicId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutTopicInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutDependentTopicsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutDependentTopicsInput, TopicUncheckedCreateWithoutDependentTopicsInput>
  }

  export type TopicCreateWithoutPrerequisiteTopicInput = {
    title: string
    content?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentTopics?: TopicCreateNestedManyWithoutPrerequisiteTopicInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutTopicInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutPrerequisiteTopicInput = {
    id?: number
    title: string
    content?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentTopics?: TopicUncheckedCreateNestedManyWithoutPrerequisiteTopicInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutTopicInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutPrerequisiteTopicInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutPrerequisiteTopicInput, TopicUncheckedCreateWithoutPrerequisiteTopicInput>
  }

  export type TopicCreateManyPrerequisiteTopicInputEnvelope = {
    data: TopicCreateManyPrerequisiteTopicInput | TopicCreateManyPrerequisiteTopicInput[]
    skipDuplicates?: boolean
  }

  export type MeasureProgressCreateWithoutTopicInput = {
    completedAt: Date | string
    progressType: string
    status: string
    learner: LearnerCreateNestedOneWithoutMeasureProgressInput
    program?: ProgramCreateNestedOneWithoutMeasureProgressInput
    module?: ModuleCreateNestedOneWithoutMeasureProgressInput
    resource?: ResourceCreateNestedOneWithoutMeasureProgressInput
  }

  export type MeasureProgressUncheckedCreateWithoutTopicInput = {
    learnerId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    moduleId?: number | null
    resourceId?: number | null
  }

  export type MeasureProgressCreateOrConnectWithoutTopicInput = {
    where: MeasureProgressWhereUniqueInput
    create: XOR<MeasureProgressCreateWithoutTopicInput, MeasureProgressUncheckedCreateWithoutTopicInput>
  }

  export type MeasureProgressCreateManyTopicInputEnvelope = {
    data: MeasureProgressCreateManyTopicInput | MeasureProgressCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type ModuleTopicCreateWithoutTopicInput = {
    position: number
    module: ModuleCreateNestedOneWithoutModuleTopicsInput
  }

  export type ModuleTopicUncheckedCreateWithoutTopicInput = {
    moduleId: number
    position: number
  }

  export type ModuleTopicCreateOrConnectWithoutTopicInput = {
    where: ModuleTopicWhereUniqueInput
    create: XOR<ModuleTopicCreateWithoutTopicInput, ModuleTopicUncheckedCreateWithoutTopicInput>
  }

  export type ModuleTopicCreateManyTopicInputEnvelope = {
    data: ModuleTopicCreateManyTopicInput | ModuleTopicCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type TopicResourceCreateWithoutTopicInput = {
    position: number
    resource: ResourceCreateNestedOneWithoutTopicResourcesInput
  }

  export type TopicResourceUncheckedCreateWithoutTopicInput = {
    resourceId: number
    position: number
  }

  export type TopicResourceCreateOrConnectWithoutTopicInput = {
    where: TopicResourceWhereUniqueInput
    create: XOR<TopicResourceCreateWithoutTopicInput, TopicResourceUncheckedCreateWithoutTopicInput>
  }

  export type TopicResourceCreateManyTopicInputEnvelope = {
    data: TopicResourceCreateManyTopicInput | TopicResourceCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type TopicUpsertWithoutDependentTopicsInput = {
    update: XOR<TopicUpdateWithoutDependentTopicsInput, TopicUncheckedUpdateWithoutDependentTopicsInput>
    create: XOR<TopicCreateWithoutDependentTopicsInput, TopicUncheckedCreateWithoutDependentTopicsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutDependentTopicsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutDependentTopicsInput, TopicUncheckedUpdateWithoutDependentTopicsInput>
  }

  export type TopicUpdateWithoutDependentTopicsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteTopic?: TopicUpdateOneWithoutDependentTopicsNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutTopicNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutDependentTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutTopicNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUpsertWithWhereUniqueWithoutPrerequisiteTopicInput = {
    where: TopicWhereUniqueInput
    update: XOR<TopicUpdateWithoutPrerequisiteTopicInput, TopicUncheckedUpdateWithoutPrerequisiteTopicInput>
    create: XOR<TopicCreateWithoutPrerequisiteTopicInput, TopicUncheckedCreateWithoutPrerequisiteTopicInput>
  }

  export type TopicUpdateWithWhereUniqueWithoutPrerequisiteTopicInput = {
    where: TopicWhereUniqueInput
    data: XOR<TopicUpdateWithoutPrerequisiteTopicInput, TopicUncheckedUpdateWithoutPrerequisiteTopicInput>
  }

  export type TopicUpdateManyWithWhereWithoutPrerequisiteTopicInput = {
    where: TopicScalarWhereInput
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyWithoutPrerequisiteTopicInput>
  }

  export type TopicScalarWhereInput = {
    AND?: TopicScalarWhereInput | TopicScalarWhereInput[]
    OR?: TopicScalarWhereInput[]
    NOT?: TopicScalarWhereInput | TopicScalarWhereInput[]
    id?: IntFilter<"Topic"> | number
    title?: StringFilter<"Topic"> | string
    content?: StringNullableFilter<"Topic"> | string | null
    prerequisiteTopicId?: IntNullableFilter<"Topic"> | number | null
    status?: IntNullableFilter<"Topic"> | number | null
    isDeleted?: BoolFilter<"Topic"> | boolean
    deletedAt?: DateTimeNullableFilter<"Topic"> | Date | string | null
    createdAt?: DateTimeFilter<"Topic"> | Date | string
    updatedAt?: DateTimeFilter<"Topic"> | Date | string
  }

  export type MeasureProgressUpsertWithWhereUniqueWithoutTopicInput = {
    where: MeasureProgressWhereUniqueInput
    update: XOR<MeasureProgressUpdateWithoutTopicInput, MeasureProgressUncheckedUpdateWithoutTopicInput>
    create: XOR<MeasureProgressCreateWithoutTopicInput, MeasureProgressUncheckedCreateWithoutTopicInput>
  }

  export type MeasureProgressUpdateWithWhereUniqueWithoutTopicInput = {
    where: MeasureProgressWhereUniqueInput
    data: XOR<MeasureProgressUpdateWithoutTopicInput, MeasureProgressUncheckedUpdateWithoutTopicInput>
  }

  export type MeasureProgressUpdateManyWithWhereWithoutTopicInput = {
    where: MeasureProgressScalarWhereInput
    data: XOR<MeasureProgressUpdateManyMutationInput, MeasureProgressUncheckedUpdateManyWithoutTopicInput>
  }

  export type ModuleTopicUpsertWithWhereUniqueWithoutTopicInput = {
    where: ModuleTopicWhereUniqueInput
    update: XOR<ModuleTopicUpdateWithoutTopicInput, ModuleTopicUncheckedUpdateWithoutTopicInput>
    create: XOR<ModuleTopicCreateWithoutTopicInput, ModuleTopicUncheckedCreateWithoutTopicInput>
  }

  export type ModuleTopicUpdateWithWhereUniqueWithoutTopicInput = {
    where: ModuleTopicWhereUniqueInput
    data: XOR<ModuleTopicUpdateWithoutTopicInput, ModuleTopicUncheckedUpdateWithoutTopicInput>
  }

  export type ModuleTopicUpdateManyWithWhereWithoutTopicInput = {
    where: ModuleTopicScalarWhereInput
    data: XOR<ModuleTopicUpdateManyMutationInput, ModuleTopicUncheckedUpdateManyWithoutTopicInput>
  }

  export type TopicResourceUpsertWithWhereUniqueWithoutTopicInput = {
    where: TopicResourceWhereUniqueInput
    update: XOR<TopicResourceUpdateWithoutTopicInput, TopicResourceUncheckedUpdateWithoutTopicInput>
    create: XOR<TopicResourceCreateWithoutTopicInput, TopicResourceUncheckedCreateWithoutTopicInput>
  }

  export type TopicResourceUpdateWithWhereUniqueWithoutTopicInput = {
    where: TopicResourceWhereUniqueInput
    data: XOR<TopicResourceUpdateWithoutTopicInput, TopicResourceUncheckedUpdateWithoutTopicInput>
  }

  export type TopicResourceUpdateManyWithWhereWithoutTopicInput = {
    where: TopicResourceScalarWhereInput
    data: XOR<TopicResourceUpdateManyMutationInput, TopicResourceUncheckedUpdateManyWithoutTopicInput>
  }

  export type TopicResourceScalarWhereInput = {
    AND?: TopicResourceScalarWhereInput | TopicResourceScalarWhereInput[]
    OR?: TopicResourceScalarWhereInput[]
    NOT?: TopicResourceScalarWhereInput | TopicResourceScalarWhereInput[]
    topicId?: IntFilter<"TopicResource"> | number
    resourceId?: IntFilter<"TopicResource"> | number
    position?: IntFilter<"TopicResource"> | number
  }

  export type ModuleCreateWithoutModuleTopicsInput = {
    title: string
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteModule?: ModuleCreateNestedOneWithoutDependentModulesInput
    dependentModules?: ModuleCreateNestedManyWithoutPrerequisiteModuleInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutModuleInput
    programModules?: ProgramModuleCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutModuleTopicsInput = {
    id?: number
    title: string
    description?: string | null
    prerequisiteModuleId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentModules?: ModuleUncheckedCreateNestedManyWithoutPrerequisiteModuleInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutModuleInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutModuleTopicsInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutModuleTopicsInput, ModuleUncheckedCreateWithoutModuleTopicsInput>
  }

  export type TopicCreateWithoutModuleTopicsInput = {
    title: string
    content?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteTopic?: TopicCreateNestedOneWithoutDependentTopicsInput
    dependentTopics?: TopicCreateNestedManyWithoutPrerequisiteTopicInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutModuleTopicsInput = {
    id?: number
    title: string
    content?: string | null
    prerequisiteTopicId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentTopics?: TopicUncheckedCreateNestedManyWithoutPrerequisiteTopicInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutModuleTopicsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutModuleTopicsInput, TopicUncheckedCreateWithoutModuleTopicsInput>
  }

  export type ModuleUpsertWithoutModuleTopicsInput = {
    update: XOR<ModuleUpdateWithoutModuleTopicsInput, ModuleUncheckedUpdateWithoutModuleTopicsInput>
    create: XOR<ModuleCreateWithoutModuleTopicsInput, ModuleUncheckedCreateWithoutModuleTopicsInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutModuleTopicsInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutModuleTopicsInput, ModuleUncheckedUpdateWithoutModuleTopicsInput>
  }

  export type ModuleUpdateWithoutModuleTopicsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteModule?: ModuleUpdateOneWithoutDependentModulesNestedInput
    dependentModules?: ModuleUpdateManyWithoutPrerequisiteModuleNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutModuleNestedInput
    programModules?: ProgramModuleUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutModuleTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteModuleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentModules?: ModuleUncheckedUpdateManyWithoutPrerequisiteModuleNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutModuleNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type TopicUpsertWithoutModuleTopicsInput = {
    update: XOR<TopicUpdateWithoutModuleTopicsInput, TopicUncheckedUpdateWithoutModuleTopicsInput>
    create: XOR<TopicCreateWithoutModuleTopicsInput, TopicUncheckedCreateWithoutModuleTopicsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutModuleTopicsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutModuleTopicsInput, TopicUncheckedUpdateWithoutModuleTopicsInput>
  }

  export type TopicUpdateWithoutModuleTopicsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteTopic?: TopicUpdateOneWithoutDependentTopicsNestedInput
    dependentTopics?: TopicUpdateManyWithoutPrerequisiteTopicNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutModuleTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentTopics?: TopicUncheckedUpdateManyWithoutPrerequisiteTopicNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ResourceViewCreateWithoutResourceInput = {
    viewedAt?: Date | string
    learner: LearnerCreateNestedOneWithoutResourceViewsInput
  }

  export type ResourceViewUncheckedCreateWithoutResourceInput = {
    learnerId: number
    viewedAt?: Date | string
  }

  export type ResourceViewCreateOrConnectWithoutResourceInput = {
    where: ResourceViewWhereUniqueInput
    create: XOR<ResourceViewCreateWithoutResourceInput, ResourceViewUncheckedCreateWithoutResourceInput>
  }

  export type ResourceViewCreateManyResourceInputEnvelope = {
    data: ResourceViewCreateManyResourceInput | ResourceViewCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type MeasureProgressCreateWithoutResourceInput = {
    completedAt: Date | string
    progressType: string
    status: string
    learner: LearnerCreateNestedOneWithoutMeasureProgressInput
    topic: TopicCreateNestedOneWithoutMeasureProgressInput
    program?: ProgramCreateNestedOneWithoutMeasureProgressInput
    module?: ModuleCreateNestedOneWithoutMeasureProgressInput
  }

  export type MeasureProgressUncheckedCreateWithoutResourceInput = {
    learnerId: number
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    moduleId?: number | null
  }

  export type MeasureProgressCreateOrConnectWithoutResourceInput = {
    where: MeasureProgressWhereUniqueInput
    create: XOR<MeasureProgressCreateWithoutResourceInput, MeasureProgressUncheckedCreateWithoutResourceInput>
  }

  export type MeasureProgressCreateManyResourceInputEnvelope = {
    data: MeasureProgressCreateManyResourceInput | MeasureProgressCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type TopicResourceCreateWithoutResourceInput = {
    position: number
    topic: TopicCreateNestedOneWithoutTopicResourcesInput
  }

  export type TopicResourceUncheckedCreateWithoutResourceInput = {
    topicId: number
    position: number
  }

  export type TopicResourceCreateOrConnectWithoutResourceInput = {
    where: TopicResourceWhereUniqueInput
    create: XOR<TopicResourceCreateWithoutResourceInput, TopicResourceUncheckedCreateWithoutResourceInput>
  }

  export type TopicResourceCreateManyResourceInputEnvelope = {
    data: TopicResourceCreateManyResourceInput | TopicResourceCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type ResourceViewUpsertWithWhereUniqueWithoutResourceInput = {
    where: ResourceViewWhereUniqueInput
    update: XOR<ResourceViewUpdateWithoutResourceInput, ResourceViewUncheckedUpdateWithoutResourceInput>
    create: XOR<ResourceViewCreateWithoutResourceInput, ResourceViewUncheckedCreateWithoutResourceInput>
  }

  export type ResourceViewUpdateWithWhereUniqueWithoutResourceInput = {
    where: ResourceViewWhereUniqueInput
    data: XOR<ResourceViewUpdateWithoutResourceInput, ResourceViewUncheckedUpdateWithoutResourceInput>
  }

  export type ResourceViewUpdateManyWithWhereWithoutResourceInput = {
    where: ResourceViewScalarWhereInput
    data: XOR<ResourceViewUpdateManyMutationInput, ResourceViewUncheckedUpdateManyWithoutResourceInput>
  }

  export type MeasureProgressUpsertWithWhereUniqueWithoutResourceInput = {
    where: MeasureProgressWhereUniqueInput
    update: XOR<MeasureProgressUpdateWithoutResourceInput, MeasureProgressUncheckedUpdateWithoutResourceInput>
    create: XOR<MeasureProgressCreateWithoutResourceInput, MeasureProgressUncheckedCreateWithoutResourceInput>
  }

  export type MeasureProgressUpdateWithWhereUniqueWithoutResourceInput = {
    where: MeasureProgressWhereUniqueInput
    data: XOR<MeasureProgressUpdateWithoutResourceInput, MeasureProgressUncheckedUpdateWithoutResourceInput>
  }

  export type MeasureProgressUpdateManyWithWhereWithoutResourceInput = {
    where: MeasureProgressScalarWhereInput
    data: XOR<MeasureProgressUpdateManyMutationInput, MeasureProgressUncheckedUpdateManyWithoutResourceInput>
  }

  export type TopicResourceUpsertWithWhereUniqueWithoutResourceInput = {
    where: TopicResourceWhereUniqueInput
    update: XOR<TopicResourceUpdateWithoutResourceInput, TopicResourceUncheckedUpdateWithoutResourceInput>
    create: XOR<TopicResourceCreateWithoutResourceInput, TopicResourceUncheckedCreateWithoutResourceInput>
  }

  export type TopicResourceUpdateWithWhereUniqueWithoutResourceInput = {
    where: TopicResourceWhereUniqueInput
    data: XOR<TopicResourceUpdateWithoutResourceInput, TopicResourceUncheckedUpdateWithoutResourceInput>
  }

  export type TopicResourceUpdateManyWithWhereWithoutResourceInput = {
    where: TopicResourceScalarWhereInput
    data: XOR<TopicResourceUpdateManyMutationInput, TopicResourceUncheckedUpdateManyWithoutResourceInput>
  }

  export type TopicCreateWithoutTopicResourcesInput = {
    title: string
    content?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteTopic?: TopicCreateNestedOneWithoutDependentTopicsInput
    dependentTopics?: TopicCreateNestedManyWithoutPrerequisiteTopicInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutTopicInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutTopicResourcesInput = {
    id?: number
    title: string
    content?: string | null
    prerequisiteTopicId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentTopics?: TopicUncheckedCreateNestedManyWithoutPrerequisiteTopicInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutTopicInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutTopicResourcesInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutTopicResourcesInput, TopicUncheckedCreateWithoutTopicResourcesInput>
  }

  export type ResourceCreateWithoutTopicResourcesInput = {
    resourceType: $Enums.ResourceType
    url: string
    title?: string | null
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    resourceViews?: ResourceViewCreateNestedManyWithoutResourceInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutTopicResourcesInput = {
    id?: number
    resourceType: $Enums.ResourceType
    url: string
    title?: string | null
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutResourceInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutTopicResourcesInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutTopicResourcesInput, ResourceUncheckedCreateWithoutTopicResourcesInput>
  }

  export type TopicUpsertWithoutTopicResourcesInput = {
    update: XOR<TopicUpdateWithoutTopicResourcesInput, TopicUncheckedUpdateWithoutTopicResourcesInput>
    create: XOR<TopicCreateWithoutTopicResourcesInput, TopicUncheckedCreateWithoutTopicResourcesInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutTopicResourcesInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutTopicResourcesInput, TopicUncheckedUpdateWithoutTopicResourcesInput>
  }

  export type TopicUpdateWithoutTopicResourcesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteTopic?: TopicUpdateOneWithoutDependentTopicsNestedInput
    dependentTopics?: TopicUpdateManyWithoutPrerequisiteTopicNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutTopicNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutTopicResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentTopics?: TopicUncheckedUpdateManyWithoutPrerequisiteTopicNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutTopicNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ResourceUpsertWithoutTopicResourcesInput = {
    update: XOR<ResourceUpdateWithoutTopicResourcesInput, ResourceUncheckedUpdateWithoutTopicResourcesInput>
    create: XOR<ResourceCreateWithoutTopicResourcesInput, ResourceUncheckedCreateWithoutTopicResourcesInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutTopicResourcesInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutTopicResourcesInput, ResourceUncheckedUpdateWithoutTopicResourcesInput>
  }

  export type ResourceUpdateWithoutTopicResourcesInput = {
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resourceViews?: ResourceViewUpdateManyWithoutResourceNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutTopicResourcesInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutResourceNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type AdminCreateWithoutQuestionsInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: AdminCreateNestedOneWithoutCreatedAdminsInput
    createdAdmins?: AdminCreateNestedManyWithoutCreatorInput
    quizPapers?: QuizPaperCreateNestedManyWithoutAuthorInput
  }

  export type AdminUncheckedCreateWithoutQuestionsInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminUncheckedCreateNestedManyWithoutCreatorInput
    quizPapers?: QuizPaperUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AdminCreateOrConnectWithoutQuestionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutQuestionsInput, AdminUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizPaperQuestionCreateWithoutQuestionInput = {
    position?: number | null
    timeMode?: boolean
    timeLimit?: number | null
    quizPaper: QuizPaperCreateNestedOneWithoutQuestionsInput
  }

  export type QuizPaperQuestionUncheckedCreateWithoutQuestionInput = {
    quizPaperId: number
    position?: number | null
    timeMode?: boolean
    timeLimit?: number | null
  }

  export type QuizPaperQuestionCreateOrConnectWithoutQuestionInput = {
    where: QuizPaperQuestionWhereUniqueInput
    create: XOR<QuizPaperQuestionCreateWithoutQuestionInput, QuizPaperQuestionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizPaperQuestionCreateManyQuestionInputEnvelope = {
    data: QuizPaperQuestionCreateManyQuestionInput | QuizPaperQuestionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuestionAttemptCreateWithoutQuestionInput = {
    answerText?: string | null
    isCorrect: boolean
    timeTakenSec?: number | null
    attempt: QuizAttemptCreateNestedOneWithoutQuestionAttemptsInput
  }

  export type QuestionAttemptUncheckedCreateWithoutQuestionInput = {
    attemptId: number
    answerText?: string | null
    isCorrect: boolean
    timeTakenSec?: number | null
  }

  export type QuestionAttemptCreateOrConnectWithoutQuestionInput = {
    where: QuestionAttemptWhereUniqueInput
    create: XOR<QuestionAttemptCreateWithoutQuestionInput, QuestionAttemptUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionAttemptCreateManyQuestionInputEnvelope = {
    data: QuestionAttemptCreateManyQuestionInput | QuestionAttemptCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutQuestionsInput = {
    update: XOR<AdminUpdateWithoutQuestionsInput, AdminUncheckedUpdateWithoutQuestionsInput>
    create: XOR<AdminCreateWithoutQuestionsInput, AdminUncheckedCreateWithoutQuestionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutQuestionsInput, AdminUncheckedUpdateWithoutQuestionsInput>
  }

  export type AdminUpdateWithoutQuestionsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AdminUpdateOneWithoutCreatedAdminsNestedInput
    createdAdmins?: AdminUpdateManyWithoutCreatorNestedInput
    quizPapers?: QuizPaperUpdateManyWithoutAuthorNestedInput
  }

  export type AdminUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUncheckedUpdateManyWithoutCreatorNestedInput
    quizPapers?: QuizPaperUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type QuizPaperQuestionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuizPaperQuestionWhereUniqueInput
    update: XOR<QuizPaperQuestionUpdateWithoutQuestionInput, QuizPaperQuestionUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuizPaperQuestionCreateWithoutQuestionInput, QuizPaperQuestionUncheckedCreateWithoutQuestionInput>
  }

  export type QuizPaperQuestionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuizPaperQuestionWhereUniqueInput
    data: XOR<QuizPaperQuestionUpdateWithoutQuestionInput, QuizPaperQuestionUncheckedUpdateWithoutQuestionInput>
  }

  export type QuizPaperQuestionUpdateManyWithWhereWithoutQuestionInput = {
    where: QuizPaperQuestionScalarWhereInput
    data: XOR<QuizPaperQuestionUpdateManyMutationInput, QuizPaperQuestionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuizPaperQuestionScalarWhereInput = {
    AND?: QuizPaperQuestionScalarWhereInput | QuizPaperQuestionScalarWhereInput[]
    OR?: QuizPaperQuestionScalarWhereInput[]
    NOT?: QuizPaperQuestionScalarWhereInput | QuizPaperQuestionScalarWhereInput[]
    quizPaperId?: IntFilter<"QuizPaperQuestion"> | number
    questionId?: IntFilter<"QuizPaperQuestion"> | number
    position?: IntNullableFilter<"QuizPaperQuestion"> | number | null
    timeMode?: BoolFilter<"QuizPaperQuestion"> | boolean
    timeLimit?: IntNullableFilter<"QuizPaperQuestion"> | number | null
  }

  export type QuestionAttemptUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionAttemptWhereUniqueInput
    update: XOR<QuestionAttemptUpdateWithoutQuestionInput, QuestionAttemptUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionAttemptCreateWithoutQuestionInput, QuestionAttemptUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionAttemptUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionAttemptWhereUniqueInput
    data: XOR<QuestionAttemptUpdateWithoutQuestionInput, QuestionAttemptUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionAttemptUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionAttemptScalarWhereInput
    data: XOR<QuestionAttemptUpdateManyMutationInput, QuestionAttemptUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionAttemptScalarWhereInput = {
    AND?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
    OR?: QuestionAttemptScalarWhereInput[]
    NOT?: QuestionAttemptScalarWhereInput | QuestionAttemptScalarWhereInput[]
    attemptId?: IntFilter<"QuestionAttempt"> | number
    questionId?: IntFilter<"QuestionAttempt"> | number
    answerText?: StringNullableFilter<"QuestionAttempt"> | string | null
    isCorrect?: BoolFilter<"QuestionAttempt"> | boolean
    timeTakenSec?: IntNullableFilter<"QuestionAttempt"> | number | null
  }

  export type AdminCreateWithoutQuizPapersInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: AdminCreateNestedOneWithoutCreatedAdminsInput
    createdAdmins?: AdminCreateNestedManyWithoutCreatorInput
    questions?: QuestionPoolCreateNestedManyWithoutAuthorInput
  }

  export type AdminUncheckedCreateWithoutQuizPapersInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdAdmins?: AdminUncheckedCreateNestedManyWithoutCreatorInput
    questions?: QuestionPoolUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AdminCreateOrConnectWithoutQuizPapersInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutQuizPapersInput, AdminUncheckedCreateWithoutQuizPapersInput>
  }

  export type QuizPaperQuestionCreateWithoutQuizPaperInput = {
    position?: number | null
    timeMode?: boolean
    timeLimit?: number | null
    question: QuestionPoolCreateNestedOneWithoutQuizPaperQuestionsInput
  }

  export type QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput = {
    questionId: number
    position?: number | null
    timeMode?: boolean
    timeLimit?: number | null
  }

  export type QuizPaperQuestionCreateOrConnectWithoutQuizPaperInput = {
    where: QuizPaperQuestionWhereUniqueInput
    create: XOR<QuizPaperQuestionCreateWithoutQuizPaperInput, QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput>
  }

  export type QuizPaperQuestionCreateManyQuizPaperInputEnvelope = {
    data: QuizPaperQuestionCreateManyQuizPaperInput | QuizPaperQuestionCreateManyQuizPaperInput[]
    skipDuplicates?: boolean
  }

  export type QuizAssignmentCreateWithoutQuizPaperInput = {
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    program?: ProgramCreateNestedOneWithoutQuizAssignmentsInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutAssignmentInput
  }

  export type QuizAssignmentUncheckedCreateWithoutQuizPaperInput = {
    id?: number
    programId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type QuizAssignmentCreateOrConnectWithoutQuizPaperInput = {
    where: QuizAssignmentWhereUniqueInput
    create: XOR<QuizAssignmentCreateWithoutQuizPaperInput, QuizAssignmentUncheckedCreateWithoutQuizPaperInput>
  }

  export type QuizAssignmentCreateManyQuizPaperInputEnvelope = {
    data: QuizAssignmentCreateManyQuizPaperInput | QuizAssignmentCreateManyQuizPaperInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutQuizPapersInput = {
    update: XOR<AdminUpdateWithoutQuizPapersInput, AdminUncheckedUpdateWithoutQuizPapersInput>
    create: XOR<AdminCreateWithoutQuizPapersInput, AdminUncheckedCreateWithoutQuizPapersInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutQuizPapersInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutQuizPapersInput, AdminUncheckedUpdateWithoutQuizPapersInput>
  }

  export type AdminUpdateWithoutQuizPapersInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: AdminUpdateOneWithoutCreatedAdminsNestedInput
    createdAdmins?: AdminUpdateManyWithoutCreatorNestedInput
    questions?: QuestionPoolUpdateManyWithoutAuthorNestedInput
  }

  export type AdminUncheckedUpdateWithoutQuizPapersInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUncheckedUpdateManyWithoutCreatorNestedInput
    questions?: QuestionPoolUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type QuizPaperQuestionUpsertWithWhereUniqueWithoutQuizPaperInput = {
    where: QuizPaperQuestionWhereUniqueInput
    update: XOR<QuizPaperQuestionUpdateWithoutQuizPaperInput, QuizPaperQuestionUncheckedUpdateWithoutQuizPaperInput>
    create: XOR<QuizPaperQuestionCreateWithoutQuizPaperInput, QuizPaperQuestionUncheckedCreateWithoutQuizPaperInput>
  }

  export type QuizPaperQuestionUpdateWithWhereUniqueWithoutQuizPaperInput = {
    where: QuizPaperQuestionWhereUniqueInput
    data: XOR<QuizPaperQuestionUpdateWithoutQuizPaperInput, QuizPaperQuestionUncheckedUpdateWithoutQuizPaperInput>
  }

  export type QuizPaperQuestionUpdateManyWithWhereWithoutQuizPaperInput = {
    where: QuizPaperQuestionScalarWhereInput
    data: XOR<QuizPaperQuestionUpdateManyMutationInput, QuizPaperQuestionUncheckedUpdateManyWithoutQuizPaperInput>
  }

  export type QuizAssignmentUpsertWithWhereUniqueWithoutQuizPaperInput = {
    where: QuizAssignmentWhereUniqueInput
    update: XOR<QuizAssignmentUpdateWithoutQuizPaperInput, QuizAssignmentUncheckedUpdateWithoutQuizPaperInput>
    create: XOR<QuizAssignmentCreateWithoutQuizPaperInput, QuizAssignmentUncheckedCreateWithoutQuizPaperInput>
  }

  export type QuizAssignmentUpdateWithWhereUniqueWithoutQuizPaperInput = {
    where: QuizAssignmentWhereUniqueInput
    data: XOR<QuizAssignmentUpdateWithoutQuizPaperInput, QuizAssignmentUncheckedUpdateWithoutQuizPaperInput>
  }

  export type QuizAssignmentUpdateManyWithWhereWithoutQuizPaperInput = {
    where: QuizAssignmentScalarWhereInput
    data: XOR<QuizAssignmentUpdateManyMutationInput, QuizAssignmentUncheckedUpdateManyWithoutQuizPaperInput>
  }

  export type QuizPaperCreateWithoutQuestionsInput = {
    title: string
    createdAt?: Date | string
    author: AdminCreateNestedOneWithoutQuizPapersInput
    assignments?: QuizAssignmentCreateNestedManyWithoutQuizPaperInput
  }

  export type QuizPaperUncheckedCreateWithoutQuestionsInput = {
    id?: number
    authorId: number
    title: string
    createdAt?: Date | string
    assignments?: QuizAssignmentUncheckedCreateNestedManyWithoutQuizPaperInput
  }

  export type QuizPaperCreateOrConnectWithoutQuestionsInput = {
    where: QuizPaperWhereUniqueInput
    create: XOR<QuizPaperCreateWithoutQuestionsInput, QuizPaperUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionPoolCreateWithoutQuizPaperQuestionsInput = {
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
    author: AdminCreateNestedOneWithoutQuestionsInput
    questionAttempts?: QuestionAttemptCreateNestedManyWithoutQuestionInput
  }

  export type QuestionPoolUncheckedCreateWithoutQuizPaperQuestionsInput = {
    id?: number
    authorId: number
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
    questionAttempts?: QuestionAttemptUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionPoolCreateOrConnectWithoutQuizPaperQuestionsInput = {
    where: QuestionPoolWhereUniqueInput
    create: XOR<QuestionPoolCreateWithoutQuizPaperQuestionsInput, QuestionPoolUncheckedCreateWithoutQuizPaperQuestionsInput>
  }

  export type QuizPaperUpsertWithoutQuestionsInput = {
    update: XOR<QuizPaperUpdateWithoutQuestionsInput, QuizPaperUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizPaperCreateWithoutQuestionsInput, QuizPaperUncheckedCreateWithoutQuestionsInput>
    where?: QuizPaperWhereInput
  }

  export type QuizPaperUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizPaperWhereInput
    data: XOR<QuizPaperUpdateWithoutQuestionsInput, QuizPaperUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizPaperUpdateWithoutQuestionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AdminUpdateOneRequiredWithoutQuizPapersNestedInput
    assignments?: QuizAssignmentUpdateManyWithoutQuizPaperNestedInput
  }

  export type QuizPaperUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: QuizAssignmentUncheckedUpdateManyWithoutQuizPaperNestedInput
  }

  export type QuestionPoolUpsertWithoutQuizPaperQuestionsInput = {
    update: XOR<QuestionPoolUpdateWithoutQuizPaperQuestionsInput, QuestionPoolUncheckedUpdateWithoutQuizPaperQuestionsInput>
    create: XOR<QuestionPoolCreateWithoutQuizPaperQuestionsInput, QuestionPoolUncheckedCreateWithoutQuizPaperQuestionsInput>
    where?: QuestionPoolWhereInput
  }

  export type QuestionPoolUpdateToOneWithWhereWithoutQuizPaperQuestionsInput = {
    where?: QuestionPoolWhereInput
    data: XOR<QuestionPoolUpdateWithoutQuizPaperQuestionsInput, QuestionPoolUncheckedUpdateWithoutQuizPaperQuestionsInput>
  }

  export type QuestionPoolUpdateWithoutQuizPaperQuestionsInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AdminUpdateOneRequiredWithoutQuestionsNestedInput
    questionAttempts?: QuestionAttemptUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionPoolUncheckedUpdateWithoutQuizPaperQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionAttempts?: QuestionAttemptUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuizPaperCreateWithoutAssignmentsInput = {
    title: string
    createdAt?: Date | string
    author: AdminCreateNestedOneWithoutQuizPapersInput
    questions?: QuizPaperQuestionCreateNestedManyWithoutQuizPaperInput
  }

  export type QuizPaperUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    authorId: number
    title: string
    createdAt?: Date | string
    questions?: QuizPaperQuestionUncheckedCreateNestedManyWithoutQuizPaperInput
  }

  export type QuizPaperCreateOrConnectWithoutAssignmentsInput = {
    where: QuizPaperWhereUniqueInput
    create: XOR<QuizPaperCreateWithoutAssignmentsInput, QuizPaperUncheckedCreateWithoutAssignmentsInput>
  }

  export type ProgramCreateWithoutQuizAssignmentsInput = {
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutQuizAssignmentsInput = {
    id?: number
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutQuizAssignmentsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutQuizAssignmentsInput, ProgramUncheckedCreateWithoutQuizAssignmentsInput>
  }

  export type QuizAttemptCreateWithoutAssignmentInput = {
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
    learner: LearnerCreateNestedOneWithoutQuizAttemptsInput
    questionAttempts?: QuestionAttemptCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateWithoutAssignmentInput = {
    id?: number
    learnerId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
    questionAttempts?: QuestionAttemptUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptCreateOrConnectWithoutAssignmentInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutAssignmentInput, QuizAttemptUncheckedCreateWithoutAssignmentInput>
  }

  export type QuizAttemptCreateManyAssignmentInputEnvelope = {
    data: QuizAttemptCreateManyAssignmentInput | QuizAttemptCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type QuizPaperUpsertWithoutAssignmentsInput = {
    update: XOR<QuizPaperUpdateWithoutAssignmentsInput, QuizPaperUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<QuizPaperCreateWithoutAssignmentsInput, QuizPaperUncheckedCreateWithoutAssignmentsInput>
    where?: QuizPaperWhereInput
  }

  export type QuizPaperUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: QuizPaperWhereInput
    data: XOR<QuizPaperUpdateWithoutAssignmentsInput, QuizPaperUncheckedUpdateWithoutAssignmentsInput>
  }

  export type QuizPaperUpdateWithoutAssignmentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AdminUpdateOneRequiredWithoutQuizPapersNestedInput
    questions?: QuizPaperQuestionUpdateManyWithoutQuizPaperNestedInput
  }

  export type QuizPaperUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizPaperQuestionUncheckedUpdateManyWithoutQuizPaperNestedInput
  }

  export type ProgramUpsertWithoutQuizAssignmentsInput = {
    update: XOR<ProgramUpdateWithoutQuizAssignmentsInput, ProgramUncheckedUpdateWithoutQuizAssignmentsInput>
    create: XOR<ProgramCreateWithoutQuizAssignmentsInput, ProgramUncheckedCreateWithoutQuizAssignmentsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutQuizAssignmentsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutQuizAssignmentsInput, ProgramUncheckedUpdateWithoutQuizAssignmentsInput>
  }

  export type ProgramUpdateWithoutQuizAssignmentsInput = {
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutQuizAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutAssignmentInput, QuizAttemptUncheckedUpdateWithoutAssignmentInput>
    create: XOR<QuizAttemptCreateWithoutAssignmentInput, QuizAttemptUncheckedCreateWithoutAssignmentInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutAssignmentInput, QuizAttemptUncheckedUpdateWithoutAssignmentInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutAssignmentInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type QuizAssignmentCreateWithoutQuizAttemptsInput = {
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    quizPaper: QuizPaperCreateNestedOneWithoutAssignmentsInput
    program?: ProgramCreateNestedOneWithoutQuizAssignmentsInput
  }

  export type QuizAssignmentUncheckedCreateWithoutQuizAttemptsInput = {
    id?: number
    quizPaperId: number
    programId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type QuizAssignmentCreateOrConnectWithoutQuizAttemptsInput = {
    where: QuizAssignmentWhereUniqueInput
    create: XOR<QuizAssignmentCreateWithoutQuizAttemptsInput, QuizAssignmentUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type LearnerCreateWithoutQuizAttemptsInput = {
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    creator?: LearnerCreateNestedOneWithoutCreatedLearnersInput
    createdLearners?: LearnerCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardCreateNestedManyWithoutLearnerInput
  }

  export type LearnerUncheckedCreateWithoutQuizAttemptsInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    createdLearners?: LearnerUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutLearnerInput
  }

  export type LearnerCreateOrConnectWithoutQuizAttemptsInput = {
    where: LearnerWhereUniqueInput
    create: XOR<LearnerCreateWithoutQuizAttemptsInput, LearnerUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type QuestionAttemptCreateWithoutAttemptInput = {
    answerText?: string | null
    isCorrect: boolean
    timeTakenSec?: number | null
    question: QuestionPoolCreateNestedOneWithoutQuestionAttemptsInput
  }

  export type QuestionAttemptUncheckedCreateWithoutAttemptInput = {
    questionId: number
    answerText?: string | null
    isCorrect: boolean
    timeTakenSec?: number | null
  }

  export type QuestionAttemptCreateOrConnectWithoutAttemptInput = {
    where: QuestionAttemptWhereUniqueInput
    create: XOR<QuestionAttemptCreateWithoutAttemptInput, QuestionAttemptUncheckedCreateWithoutAttemptInput>
  }

  export type QuestionAttemptCreateManyAttemptInputEnvelope = {
    data: QuestionAttemptCreateManyAttemptInput | QuestionAttemptCreateManyAttemptInput[]
    skipDuplicates?: boolean
  }

  export type QuizAssignmentUpsertWithoutQuizAttemptsInput = {
    update: XOR<QuizAssignmentUpdateWithoutQuizAttemptsInput, QuizAssignmentUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<QuizAssignmentCreateWithoutQuizAttemptsInput, QuizAssignmentUncheckedCreateWithoutQuizAttemptsInput>
    where?: QuizAssignmentWhereInput
  }

  export type QuizAssignmentUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: QuizAssignmentWhereInput
    data: XOR<QuizAssignmentUpdateWithoutQuizAttemptsInput, QuizAssignmentUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type QuizAssignmentUpdateWithoutQuizAttemptsInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizPaper?: QuizPaperUpdateOneRequiredWithoutAssignmentsNestedInput
    program?: ProgramUpdateOneWithoutQuizAssignmentsNestedInput
  }

  export type QuizAssignmentUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizPaperId?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnerUpsertWithoutQuizAttemptsInput = {
    update: XOR<LearnerUpdateWithoutQuizAttemptsInput, LearnerUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<LearnerCreateWithoutQuizAttemptsInput, LearnerUncheckedCreateWithoutQuizAttemptsInput>
    where?: LearnerWhereInput
  }

  export type LearnerUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: LearnerWhereInput
    data: XOR<LearnerUpdateWithoutQuizAttemptsInput, LearnerUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type LearnerUpdateWithoutQuizAttemptsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    creator?: LearnerUpdateOneWithoutCreatedLearnersNestedInput
    createdLearners?: LearnerUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdLearners?: LearnerUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutLearnerNestedInput
  }

  export type QuestionAttemptUpsertWithWhereUniqueWithoutAttemptInput = {
    where: QuestionAttemptWhereUniqueInput
    update: XOR<QuestionAttemptUpdateWithoutAttemptInput, QuestionAttemptUncheckedUpdateWithoutAttemptInput>
    create: XOR<QuestionAttemptCreateWithoutAttemptInput, QuestionAttemptUncheckedCreateWithoutAttemptInput>
  }

  export type QuestionAttemptUpdateWithWhereUniqueWithoutAttemptInput = {
    where: QuestionAttemptWhereUniqueInput
    data: XOR<QuestionAttemptUpdateWithoutAttemptInput, QuestionAttemptUncheckedUpdateWithoutAttemptInput>
  }

  export type QuestionAttemptUpdateManyWithWhereWithoutAttemptInput = {
    where: QuestionAttemptScalarWhereInput
    data: XOR<QuestionAttemptUpdateManyMutationInput, QuestionAttemptUncheckedUpdateManyWithoutAttemptInput>
  }

  export type QuizAttemptCreateWithoutQuestionAttemptsInput = {
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
    assignment: QuizAssignmentCreateNestedOneWithoutQuizAttemptsInput
    learner: LearnerCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutQuestionAttemptsInput = {
    id?: number
    assignmentId: number
    learnerId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
  }

  export type QuizAttemptCreateOrConnectWithoutQuestionAttemptsInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutQuestionAttemptsInput, QuizAttemptUncheckedCreateWithoutQuestionAttemptsInput>
  }

  export type QuestionPoolCreateWithoutQuestionAttemptsInput = {
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
    author: AdminCreateNestedOneWithoutQuestionsInput
    quizPaperQuestions?: QuizPaperQuestionCreateNestedManyWithoutQuestionInput
  }

  export type QuestionPoolUncheckedCreateWithoutQuestionAttemptsInput = {
    id?: number
    authorId: number
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
    quizPaperQuestions?: QuizPaperQuestionUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionPoolCreateOrConnectWithoutQuestionAttemptsInput = {
    where: QuestionPoolWhereUniqueInput
    create: XOR<QuestionPoolCreateWithoutQuestionAttemptsInput, QuestionPoolUncheckedCreateWithoutQuestionAttemptsInput>
  }

  export type QuizAttemptUpsertWithoutQuestionAttemptsInput = {
    update: XOR<QuizAttemptUpdateWithoutQuestionAttemptsInput, QuizAttemptUncheckedUpdateWithoutQuestionAttemptsInput>
    create: XOR<QuizAttemptCreateWithoutQuestionAttemptsInput, QuizAttemptUncheckedCreateWithoutQuestionAttemptsInput>
    where?: QuizAttemptWhereInput
  }

  export type QuizAttemptUpdateToOneWithWhereWithoutQuestionAttemptsInput = {
    where?: QuizAttemptWhereInput
    data: XOR<QuizAttemptUpdateWithoutQuestionAttemptsInput, QuizAttemptUncheckedUpdateWithoutQuestionAttemptsInput>
  }

  export type QuizAttemptUpdateWithoutQuestionAttemptsInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: QuizAssignmentUpdateOneRequiredWithoutQuizAttemptsNestedInput
    learner?: LearnerUpdateOneRequiredWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutQuestionAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentId?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionPoolUpsertWithoutQuestionAttemptsInput = {
    update: XOR<QuestionPoolUpdateWithoutQuestionAttemptsInput, QuestionPoolUncheckedUpdateWithoutQuestionAttemptsInput>
    create: XOR<QuestionPoolCreateWithoutQuestionAttemptsInput, QuestionPoolUncheckedCreateWithoutQuestionAttemptsInput>
    where?: QuestionPoolWhereInput
  }

  export type QuestionPoolUpdateToOneWithWhereWithoutQuestionAttemptsInput = {
    where?: QuestionPoolWhereInput
    data: XOR<QuestionPoolUpdateWithoutQuestionAttemptsInput, QuestionPoolUncheckedUpdateWithoutQuestionAttemptsInput>
  }

  export type QuestionPoolUpdateWithoutQuestionAttemptsInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AdminUpdateOneRequiredWithoutQuestionsNestedInput
    quizPaperQuestions?: QuizPaperQuestionUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionPoolUncheckedUpdateWithoutQuestionAttemptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizPaperQuestions?: QuizPaperQuestionUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type LearnerCreateWithoutResourceViewsInput = {
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    creator?: LearnerCreateNestedOneWithoutCreatedLearnersInput
    createdLearners?: LearnerCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardCreateNestedManyWithoutLearnerInput
  }

  export type LearnerUncheckedCreateWithoutResourceViewsInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    createdLearners?: LearnerUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutLearnerInput
  }

  export type LearnerCreateOrConnectWithoutResourceViewsInput = {
    where: LearnerWhereUniqueInput
    create: XOR<LearnerCreateWithoutResourceViewsInput, LearnerUncheckedCreateWithoutResourceViewsInput>
  }

  export type ResourceCreateWithoutResourceViewsInput = {
    resourceType: $Enums.ResourceType
    url: string
    title?: string | null
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    measureProgress?: MeasureProgressCreateNestedManyWithoutResourceInput
    topicResources?: TopicResourceCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutResourceViewsInput = {
    id?: number
    resourceType: $Enums.ResourceType
    url: string
    title?: string | null
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutResourceInput
    topicResources?: TopicResourceUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutResourceViewsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutResourceViewsInput, ResourceUncheckedCreateWithoutResourceViewsInput>
  }

  export type LearnerUpsertWithoutResourceViewsInput = {
    update: XOR<LearnerUpdateWithoutResourceViewsInput, LearnerUncheckedUpdateWithoutResourceViewsInput>
    create: XOR<LearnerCreateWithoutResourceViewsInput, LearnerUncheckedCreateWithoutResourceViewsInput>
    where?: LearnerWhereInput
  }

  export type LearnerUpdateToOneWithWhereWithoutResourceViewsInput = {
    where?: LearnerWhereInput
    data: XOR<LearnerUpdateWithoutResourceViewsInput, LearnerUncheckedUpdateWithoutResourceViewsInput>
  }

  export type LearnerUpdateWithoutResourceViewsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    creator?: LearnerUpdateOneWithoutCreatedLearnersNestedInput
    createdLearners?: LearnerUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUncheckedUpdateWithoutResourceViewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdLearners?: LearnerUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutLearnerNestedInput
  }

  export type ResourceUpsertWithoutResourceViewsInput = {
    update: XOR<ResourceUpdateWithoutResourceViewsInput, ResourceUncheckedUpdateWithoutResourceViewsInput>
    create: XOR<ResourceCreateWithoutResourceViewsInput, ResourceUncheckedCreateWithoutResourceViewsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutResourceViewsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutResourceViewsInput, ResourceUncheckedUpdateWithoutResourceViewsInput>
  }

  export type ResourceUpdateWithoutResourceViewsInput = {
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measureProgress?: MeasureProgressUpdateManyWithoutResourceNestedInput
    topicResources?: TopicResourceUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutResourceViewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutResourceNestedInput
    topicResources?: TopicResourceUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type LearnerCreateWithoutMeasureProgressInput = {
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    creator?: LearnerCreateNestedOneWithoutCreatedLearnersInput
    createdLearners?: LearnerCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardCreateNestedManyWithoutLearnerInput
  }

  export type LearnerUncheckedCreateWithoutMeasureProgressInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    createdLearners?: LearnerUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutLearnerInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutLearnerInput
  }

  export type LearnerCreateOrConnectWithoutMeasureProgressInput = {
    where: LearnerWhereUniqueInput
    create: XOR<LearnerCreateWithoutMeasureProgressInput, LearnerUncheckedCreateWithoutMeasureProgressInput>
  }

  export type TopicCreateWithoutMeasureProgressInput = {
    title: string
    content?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteTopic?: TopicCreateNestedOneWithoutDependentTopicsInput
    dependentTopics?: TopicCreateNestedManyWithoutPrerequisiteTopicInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateWithoutMeasureProgressInput = {
    id?: number
    title: string
    content?: string | null
    prerequisiteTopicId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentTopics?: TopicUncheckedCreateNestedManyWithoutPrerequisiteTopicInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutTopicInput
    topicResources?: TopicResourceUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicCreateOrConnectWithoutMeasureProgressInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutMeasureProgressInput, TopicUncheckedCreateWithoutMeasureProgressInput>
  }

  export type ProgramCreateWithoutMeasureProgressInput = {
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentCreateNestedManyWithoutProgramInput
    quizAssignments?: QuizAssignmentCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutMeasureProgressInput = {
    id?: number
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProgramInput
    quizAssignments?: QuizAssignmentUncheckedCreateNestedManyWithoutProgramInput
    leaderboards?: LeaderboardUncheckedCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutMeasureProgressInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutMeasureProgressInput, ProgramUncheckedCreateWithoutMeasureProgressInput>
  }

  export type ModuleCreateWithoutMeasureProgressInput = {
    title: string
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prerequisiteModule?: ModuleCreateNestedOneWithoutDependentModulesInput
    dependentModules?: ModuleCreateNestedManyWithoutPrerequisiteModuleInput
    programModules?: ProgramModuleCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicCreateNestedManyWithoutModuleInput
  }

  export type ModuleUncheckedCreateWithoutMeasureProgressInput = {
    id?: number
    title: string
    description?: string | null
    prerequisiteModuleId?: number | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dependentModules?: ModuleUncheckedCreateNestedManyWithoutPrerequisiteModuleInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutModuleInput
    moduleTopics?: ModuleTopicUncheckedCreateNestedManyWithoutModuleInput
  }

  export type ModuleCreateOrConnectWithoutMeasureProgressInput = {
    where: ModuleWhereUniqueInput
    create: XOR<ModuleCreateWithoutMeasureProgressInput, ModuleUncheckedCreateWithoutMeasureProgressInput>
  }

  export type ResourceCreateWithoutMeasureProgressInput = {
    resourceType: $Enums.ResourceType
    url: string
    title?: string | null
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    resourceViews?: ResourceViewCreateNestedManyWithoutResourceInput
    topicResources?: TopicResourceCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutMeasureProgressInput = {
    id?: number
    resourceType: $Enums.ResourceType
    url: string
    title?: string | null
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutResourceInput
    topicResources?: TopicResourceUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutMeasureProgressInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutMeasureProgressInput, ResourceUncheckedCreateWithoutMeasureProgressInput>
  }

  export type LearnerUpsertWithoutMeasureProgressInput = {
    update: XOR<LearnerUpdateWithoutMeasureProgressInput, LearnerUncheckedUpdateWithoutMeasureProgressInput>
    create: XOR<LearnerCreateWithoutMeasureProgressInput, LearnerUncheckedCreateWithoutMeasureProgressInput>
    where?: LearnerWhereInput
  }

  export type LearnerUpdateToOneWithWhereWithoutMeasureProgressInput = {
    where?: LearnerWhereInput
    data: XOR<LearnerUpdateWithoutMeasureProgressInput, LearnerUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type LearnerUpdateWithoutMeasureProgressInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    creator?: LearnerUpdateOneWithoutCreatedLearnersNestedInput
    createdLearners?: LearnerUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUncheckedUpdateWithoutMeasureProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdLearners?: LearnerUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutLearnerNestedInput
  }

  export type TopicUpsertWithoutMeasureProgressInput = {
    update: XOR<TopicUpdateWithoutMeasureProgressInput, TopicUncheckedUpdateWithoutMeasureProgressInput>
    create: XOR<TopicCreateWithoutMeasureProgressInput, TopicUncheckedCreateWithoutMeasureProgressInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutMeasureProgressInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutMeasureProgressInput, TopicUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type TopicUpdateWithoutMeasureProgressInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteTopic?: TopicUpdateOneWithoutDependentTopicsNestedInput
    dependentTopics?: TopicUpdateManyWithoutPrerequisiteTopicNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutMeasureProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteTopicId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentTopics?: TopicUncheckedUpdateManyWithoutPrerequisiteTopicNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type ProgramUpsertWithoutMeasureProgressInput = {
    update: XOR<ProgramUpdateWithoutMeasureProgressInput, ProgramUncheckedUpdateWithoutMeasureProgressInput>
    create: XOR<ProgramCreateWithoutMeasureProgressInput, ProgramUncheckedCreateWithoutMeasureProgressInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutMeasureProgressInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutMeasureProgressInput, ProgramUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type ProgramUpdateWithoutMeasureProgressInput = {
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUpdateManyWithoutProgramNestedInput
    quizAssignments?: QuizAssignmentUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutMeasureProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProgramNestedInput
    quizAssignments?: QuizAssignmentUncheckedUpdateManyWithoutProgramNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ModuleUpsertWithoutMeasureProgressInput = {
    update: XOR<ModuleUpdateWithoutMeasureProgressInput, ModuleUncheckedUpdateWithoutMeasureProgressInput>
    create: XOR<ModuleCreateWithoutMeasureProgressInput, ModuleUncheckedCreateWithoutMeasureProgressInput>
    where?: ModuleWhereInput
  }

  export type ModuleUpdateToOneWithWhereWithoutMeasureProgressInput = {
    where?: ModuleWhereInput
    data: XOR<ModuleUpdateWithoutMeasureProgressInput, ModuleUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type ModuleUpdateWithoutMeasureProgressInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prerequisiteModule?: ModuleUpdateOneWithoutDependentModulesNestedInput
    dependentModules?: ModuleUpdateManyWithoutPrerequisiteModuleNestedInput
    programModules?: ProgramModuleUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutMeasureProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    prerequisiteModuleId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentModules?: ModuleUncheckedUpdateManyWithoutPrerequisiteModuleNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ResourceUpsertWithoutMeasureProgressInput = {
    update: XOR<ResourceUpdateWithoutMeasureProgressInput, ResourceUncheckedUpdateWithoutMeasureProgressInput>
    create: XOR<ResourceCreateWithoutMeasureProgressInput, ResourceUncheckedCreateWithoutMeasureProgressInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutMeasureProgressInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutMeasureProgressInput, ResourceUncheckedUpdateWithoutMeasureProgressInput>
  }

  export type ResourceUpdateWithoutMeasureProgressInput = {
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resourceViews?: ResourceViewUpdateManyWithoutResourceNestedInput
    topicResources?: TopicResourceUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutMeasureProgressInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceType?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutResourceNestedInput
    topicResources?: TopicResourceUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ProgramCreateWithoutLeaderboardsInput = {
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentCreateNestedManyWithoutProgramInput
    quizAssignments?: QuizAssignmentCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutLeaderboardsInput = {
    id?: number
    authorId: number
    title: string
    description: string
    category?: string | null
    instructor?: string | null
    instructorAvatar?: string | null
    image?: string | null
    rating?: number | null
    level?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    type?: $Enums.ProgramType | null
    totalTimeLimit?: number | null
    status?: number | null
    uniqueHash?: string | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    surveyStartDate?: Date | string | null
    surveyEndDate?: Date | string | null
    maxParticipants?: string | null
    passingScore?: number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: number | null
    packageId?: bigint | number | null
    isActive?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutProgramInput
    quizAssignments?: QuizAssignmentUncheckedCreateNestedManyWithoutProgramInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutProgramInput
    programModules?: ProgramModuleUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutLeaderboardsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutLeaderboardsInput, ProgramUncheckedCreateWithoutLeaderboardsInput>
  }

  export type LearnerCreateWithoutLeaderboardsInput = {
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    creator?: LearnerCreateNestedOneWithoutCreatedLearnersInput
    createdLearners?: LearnerCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressCreateNestedManyWithoutLearnerInput
  }

  export type LearnerUncheckedCreateWithoutLeaderboardsInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdBy?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
    createdLearners?: LearnerUncheckedCreateNestedManyWithoutCreatorInput
    enrollments?: EnrollmentUncheckedCreateNestedManyWithoutLearnerInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutLearnerInput
    resourceViews?: ResourceViewUncheckedCreateNestedManyWithoutLearnerInput
    measureProgress?: MeasureProgressUncheckedCreateNestedManyWithoutLearnerInput
  }

  export type LearnerCreateOrConnectWithoutLeaderboardsInput = {
    where: LearnerWhereUniqueInput
    create: XOR<LearnerCreateWithoutLeaderboardsInput, LearnerUncheckedCreateWithoutLeaderboardsInput>
  }

  export type ProgramUpsertWithoutLeaderboardsInput = {
    update: XOR<ProgramUpdateWithoutLeaderboardsInput, ProgramUncheckedUpdateWithoutLeaderboardsInput>
    create: XOR<ProgramCreateWithoutLeaderboardsInput, ProgramUncheckedCreateWithoutLeaderboardsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutLeaderboardsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutLeaderboardsInput, ProgramUncheckedUpdateWithoutLeaderboardsInput>
  }

  export type ProgramUpdateWithoutLeaderboardsInput = {
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUpdateManyWithoutProgramNestedInput
    quizAssignments?: QuizAssignmentUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutLeaderboardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    authorId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    instructor?: NullableStringFieldUpdateOperationsInput | string | null
    instructorAvatar?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    type?: NullableEnumProgramTypeFieldUpdateOperationsInput | $Enums.ProgramType | null
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surveyEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maxParticipants?: NullableStringFieldUpdateOperationsInput | string | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    studySettings?: NullableJsonNullValueInput | InputJsonValue
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    packageId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: EnrollmentUncheckedUpdateManyWithoutProgramNestedInput
    quizAssignments?: QuizAssignmentUncheckedUpdateManyWithoutProgramNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutProgramNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type LearnerUpsertWithoutLeaderboardsInput = {
    update: XOR<LearnerUpdateWithoutLeaderboardsInput, LearnerUncheckedUpdateWithoutLeaderboardsInput>
    create: XOR<LearnerCreateWithoutLeaderboardsInput, LearnerUncheckedCreateWithoutLeaderboardsInput>
    where?: LearnerWhereInput
  }

  export type LearnerUpdateToOneWithWhereWithoutLeaderboardsInput = {
    where?: LearnerWhereInput
    data: XOR<LearnerUpdateWithoutLeaderboardsInput, LearnerUncheckedUpdateWithoutLeaderboardsInput>
  }

  export type LearnerUpdateWithoutLeaderboardsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    creator?: LearnerUpdateOneWithoutCreatedLearnersNestedInput
    createdLearners?: LearnerUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUncheckedUpdateWithoutLeaderboardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdLearners?: LearnerUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutLearnerNestedInput
  }

  export type AdminCreateManyCreatorInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    adminType: $Enums.AdminType
    organization?: string | null
    bio?: string | null
    profile_image?: string | null
    contactPhone?: string | null
    website?: string | null
    isVerified?: boolean
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionPoolCreateManyAuthorInput = {
    id?: number
    questionText: string
    questionType: $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: string | null
    timeLimitSec?: number | null
    points?: number
    option1?: string | null
    option2?: string | null
    option3?: string | null
    option4?: string | null
    option5?: string | null
    option6?: string | null
    answer?: string | null
    createdAt?: Date | string
  }

  export type QuizPaperCreateManyAuthorInput = {
    id?: number
    title: string
    createdAt?: Date | string
  }

  export type AdminUpdateWithoutCreatorInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUpdateManyWithoutCreatorNestedInput
    questions?: QuestionPoolUpdateManyWithoutAuthorNestedInput
    quizPapers?: QuizPaperUpdateManyWithoutAuthorNestedInput
  }

  export type AdminUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAdmins?: AdminUncheckedUpdateManyWithoutCreatorNestedInput
    questions?: QuestionPoolUncheckedUpdateManyWithoutAuthorNestedInput
    quizPapers?: QuizPaperUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AdminUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    adminType?: EnumAdminTypeFieldUpdateOperationsInput | $Enums.AdminType
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    contactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionPoolUpdateWithoutAuthorInput = {
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizPaperQuestions?: QuizPaperQuestionUpdateManyWithoutQuestionNestedInput
    questionAttempts?: QuestionAttemptUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionPoolUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizPaperQuestions?: QuizPaperQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    questionAttempts?: QuestionAttemptUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionPoolUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    metadata?: NullableJsonNullValueInput | InputJsonValue
    explanation?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimitSec?: NullableIntFieldUpdateOperationsInput | number | null
    points?: IntFieldUpdateOperationsInput | number
    option1?: NullableStringFieldUpdateOperationsInput | string | null
    option2?: NullableStringFieldUpdateOperationsInput | string | null
    option3?: NullableStringFieldUpdateOperationsInput | string | null
    option4?: NullableStringFieldUpdateOperationsInput | string | null
    option5?: NullableStringFieldUpdateOperationsInput | string | null
    option6?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizPaperUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizPaperQuestionUpdateManyWithoutQuizPaperNestedInput
    assignments?: QuizAssignmentUpdateManyWithoutQuizPaperNestedInput
  }

  export type QuizPaperUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizPaperQuestionUncheckedUpdateManyWithoutQuizPaperNestedInput
    assignments?: QuizAssignmentUncheckedUpdateManyWithoutQuizPaperNestedInput
  }

  export type QuizPaperUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnerCreateManyCreatorInput = {
    id?: number
    first_name: string
    last_name: string
    gender?: string | null
    dob?: Date | string | null
    email: string
    phone?: Uint8Array | null
    communicationEmail?: Uint8Array | null
    password?: string | null
    profile_image?: string | null
    organisation?: string | null
    designation?: string | null
    department?: string | null
    location?: string | null
    hierarchy_level?: string | null
    totalPoints?: number
    isActive?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    isVerified?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    uniqueHash?: string | null
    status?: number | null
    extraConfig?: string | null
    metaData?: string | null
    role: string
  }

  export type EnrollmentCreateManyLearnerInput = {
    id?: number
    programId: number
    enrolledAt?: Date | string
  }

  export type QuizAttemptCreateManyLearnerInput = {
    id?: number
    assignmentId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
  }

  export type ResourceViewCreateManyLearnerInput = {
    resourceId: number
    viewedAt?: Date | string
  }

  export type MeasureProgressCreateManyLearnerInput = {
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    moduleId?: number | null
    resourceId?: number | null
  }

  export type LeaderboardCreateManyLearnerInput = {
    programId: number
    totalScore: Decimal | DecimalJsLike | number | string
    lastAttemptAt?: Date | string | null
  }

  export type LearnerUpdateWithoutCreatorInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdLearners?: LearnerUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUncheckedUpdateWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdLearners?: LearnerUncheckedUpdateManyWithoutCreatorNestedInput
    enrollments?: EnrollmentUncheckedUpdateManyWithoutLearnerNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutLearnerNestedInput
    resourceViews?: ResourceViewUncheckedUpdateManyWithoutLearnerNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutLearnerNestedInput
    leaderboards?: LeaderboardUncheckedUpdateManyWithoutLearnerNestedInput
  }

  export type LearnerUncheckedUpdateManyWithoutCreatorInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    communicationEmail?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    organisation?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    hierarchy_level?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uniqueHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    extraConfig?: NullableStringFieldUpdateOperationsInput | string | null
    metaData?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
  }

  export type EnrollmentUpdateWithoutLearnerInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutLearnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutLearnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptUpdateWithoutLearnerInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: QuizAssignmentUpdateOneRequiredWithoutQuizAttemptsNestedInput
    questionAttempts?: QuestionAttemptUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutLearnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionAttempts?: QuestionAttemptUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateManyWithoutLearnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    assignmentId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceViewUpdateWithoutLearnerInput = {
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resource?: ResourceUpdateOneRequiredWithoutResourceViewsNestedInput
  }

  export type ResourceViewUncheckedUpdateWithoutLearnerInput = {
    resourceId?: IntFieldUpdateOperationsInput | number
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceViewUncheckedUpdateManyWithoutLearnerInput = {
    resourceId?: IntFieldUpdateOperationsInput | number
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasureProgressUpdateWithoutLearnerInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    topic?: TopicUpdateOneRequiredWithoutMeasureProgressNestedInput
    program?: ProgramUpdateOneWithoutMeasureProgressNestedInput
    module?: ModuleUpdateOneWithoutMeasureProgressNestedInput
    resource?: ResourceUpdateOneWithoutMeasureProgressNestedInput
  }

  export type MeasureProgressUncheckedUpdateWithoutLearnerInput = {
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasureProgressUncheckedUpdateManyWithoutLearnerInput = {
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardUpdateWithoutLearnerInput = {
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    program?: ProgramUpdateOneRequiredWithoutLeaderboardsNestedInput
  }

  export type LeaderboardUncheckedUpdateWithoutLearnerInput = {
    programId?: IntFieldUpdateOperationsInput | number
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaderboardUncheckedUpdateManyWithoutLearnerInput = {
    programId?: IntFieldUpdateOperationsInput | number
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EnrollmentCreateManyProgramInput = {
    id?: number
    learnerId: number
    enrolledAt?: Date | string
  }

  export type QuizAssignmentCreateManyProgramInput = {
    id?: number
    quizPaperId: number
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MeasureProgressCreateManyProgramInput = {
    learnerId: number
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    moduleId?: number | null
    resourceId?: number | null
  }

  export type LeaderboardCreateManyProgramInput = {
    learnerId: number
    totalScore: Decimal | DecimalJsLike | number | string
    lastAttemptAt?: Date | string | null
  }

  export type ProgramModuleCreateManyProgramInput = {
    moduleId: number
    position: number
  }

  export type EnrollmentUpdateWithoutProgramInput = {
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learner?: LearnerUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type EnrollmentUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EnrollmentUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAssignmentUpdateWithoutProgramInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizPaper?: QuizPaperUpdateOneRequiredWithoutAssignmentsNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutAssignmentNestedInput
  }

  export type QuizAssignmentUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizPaperId?: IntFieldUpdateOperationsInput | number
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type QuizAssignmentUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    quizPaperId?: IntFieldUpdateOperationsInput | number
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasureProgressUpdateWithoutProgramInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    learner?: LearnerUpdateOneRequiredWithoutMeasureProgressNestedInput
    topic?: TopicUpdateOneRequiredWithoutMeasureProgressNestedInput
    module?: ModuleUpdateOneWithoutMeasureProgressNestedInput
    resource?: ResourceUpdateOneWithoutMeasureProgressNestedInput
  }

  export type MeasureProgressUncheckedUpdateWithoutProgramInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasureProgressUncheckedUpdateManyWithoutProgramInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LeaderboardUpdateWithoutProgramInput = {
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    learner?: LearnerUpdateOneRequiredWithoutLeaderboardsNestedInput
  }

  export type LeaderboardUncheckedUpdateWithoutProgramInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaderboardUncheckedUpdateManyWithoutProgramInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    totalScore?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProgramModuleUpdateWithoutProgramInput = {
    position?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutProgramModulesNestedInput
  }

  export type ProgramModuleUncheckedUpdateWithoutProgramInput = {
    moduleId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramModuleUncheckedUpdateManyWithoutProgramInput = {
    moduleId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleCreateManyPrerequisiteModuleInput = {
    id?: number
    title: string
    description?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeasureProgressCreateManyModuleInput = {
    learnerId: number
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    resourceId?: number | null
  }

  export type ProgramModuleCreateManyModuleInput = {
    programId: number
    position: number
  }

  export type ModuleTopicCreateManyModuleInput = {
    topicId: number
    position: number
  }

  export type ModuleUpdateWithoutPrerequisiteModuleInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentModules?: ModuleUpdateManyWithoutPrerequisiteModuleNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutModuleNestedInput
    programModules?: ProgramModuleUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateWithoutPrerequisiteModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentModules?: ModuleUncheckedUpdateManyWithoutPrerequisiteModuleNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutModuleNestedInput
    programModules?: ProgramModuleUncheckedUpdateManyWithoutModuleNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutModuleNestedInput
  }

  export type ModuleUncheckedUpdateManyWithoutPrerequisiteModuleInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasureProgressUpdateWithoutModuleInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    learner?: LearnerUpdateOneRequiredWithoutMeasureProgressNestedInput
    topic?: TopicUpdateOneRequiredWithoutMeasureProgressNestedInput
    program?: ProgramUpdateOneWithoutMeasureProgressNestedInput
    resource?: ResourceUpdateOneWithoutMeasureProgressNestedInput
  }

  export type MeasureProgressUncheckedUpdateWithoutModuleInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasureProgressUncheckedUpdateManyWithoutModuleInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramModuleUpdateWithoutModuleInput = {
    position?: IntFieldUpdateOperationsInput | number
    program?: ProgramUpdateOneRequiredWithoutProgramModulesNestedInput
  }

  export type ProgramModuleUncheckedUpdateWithoutModuleInput = {
    programId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramModuleUncheckedUpdateManyWithoutModuleInput = {
    programId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleTopicUpdateWithoutModuleInput = {
    position?: IntFieldUpdateOperationsInput | number
    topic?: TopicUpdateOneRequiredWithoutModuleTopicsNestedInput
  }

  export type ModuleTopicUncheckedUpdateWithoutModuleInput = {
    topicId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleTopicUncheckedUpdateManyWithoutModuleInput = {
    topicId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type TopicCreateManyPrerequisiteTopicInput = {
    id?: number
    title: string
    content?: string | null
    status?: number | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MeasureProgressCreateManyTopicInput = {
    learnerId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    moduleId?: number | null
    resourceId?: number | null
  }

  export type ModuleTopicCreateManyTopicInput = {
    moduleId: number
    position: number
  }

  export type TopicResourceCreateManyTopicInput = {
    resourceId: number
    position: number
  }

  export type TopicUpdateWithoutPrerequisiteTopicInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentTopics?: TopicUpdateManyWithoutPrerequisiteTopicNestedInput
    measureProgress?: MeasureProgressUpdateManyWithoutTopicNestedInput
    moduleTopics?: ModuleTopicUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateWithoutPrerequisiteTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependentTopics?: TopicUncheckedUpdateManyWithoutPrerequisiteTopicNestedInput
    measureProgress?: MeasureProgressUncheckedUpdateManyWithoutTopicNestedInput
    moduleTopics?: ModuleTopicUncheckedUpdateManyWithoutTopicNestedInput
    topicResources?: TopicResourceUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateManyWithoutPrerequisiteTopicInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasureProgressUpdateWithoutTopicInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    learner?: LearnerUpdateOneRequiredWithoutMeasureProgressNestedInput
    program?: ProgramUpdateOneWithoutMeasureProgressNestedInput
    module?: ModuleUpdateOneWithoutMeasureProgressNestedInput
    resource?: ResourceUpdateOneWithoutMeasureProgressNestedInput
  }

  export type MeasureProgressUncheckedUpdateWithoutTopicInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasureProgressUncheckedUpdateManyWithoutTopicInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
    resourceId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ModuleTopicUpdateWithoutTopicInput = {
    position?: IntFieldUpdateOperationsInput | number
    module?: ModuleUpdateOneRequiredWithoutModuleTopicsNestedInput
  }

  export type ModuleTopicUncheckedUpdateWithoutTopicInput = {
    moduleId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ModuleTopicUncheckedUpdateManyWithoutTopicInput = {
    moduleId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type TopicResourceUpdateWithoutTopicInput = {
    position?: IntFieldUpdateOperationsInput | number
    resource?: ResourceUpdateOneRequiredWithoutTopicResourcesNestedInput
  }

  export type TopicResourceUncheckedUpdateWithoutTopicInput = {
    resourceId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type TopicResourceUncheckedUpdateManyWithoutTopicInput = {
    resourceId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type ResourceViewCreateManyResourceInput = {
    learnerId: number
    viewedAt?: Date | string
  }

  export type MeasureProgressCreateManyResourceInput = {
    learnerId: number
    topicId: number
    completedAt: Date | string
    progressType: string
    status: string
    programId?: number | null
    moduleId?: number | null
  }

  export type TopicResourceCreateManyResourceInput = {
    topicId: number
    position: number
  }

  export type ResourceViewUpdateWithoutResourceInput = {
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learner?: LearnerUpdateOneRequiredWithoutResourceViewsNestedInput
  }

  export type ResourceViewUncheckedUpdateWithoutResourceInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceViewUncheckedUpdateManyWithoutResourceInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    viewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeasureProgressUpdateWithoutResourceInput = {
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    learner?: LearnerUpdateOneRequiredWithoutMeasureProgressNestedInput
    topic?: TopicUpdateOneRequiredWithoutMeasureProgressNestedInput
    program?: ProgramUpdateOneWithoutMeasureProgressNestedInput
    module?: ModuleUpdateOneWithoutMeasureProgressNestedInput
  }

  export type MeasureProgressUncheckedUpdateWithoutResourceInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasureProgressUncheckedUpdateManyWithoutResourceInput = {
    learnerId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    moduleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TopicResourceUpdateWithoutResourceInput = {
    position?: IntFieldUpdateOperationsInput | number
    topic?: TopicUpdateOneRequiredWithoutTopicResourcesNestedInput
  }

  export type TopicResourceUncheckedUpdateWithoutResourceInput = {
    topicId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type TopicResourceUncheckedUpdateManyWithoutResourceInput = {
    topicId?: IntFieldUpdateOperationsInput | number
    position?: IntFieldUpdateOperationsInput | number
  }

  export type QuizPaperQuestionCreateManyQuestionInput = {
    quizPaperId: number
    position?: number | null
    timeMode?: boolean
    timeLimit?: number | null
  }

  export type QuestionAttemptCreateManyQuestionInput = {
    attemptId: number
    answerText?: string | null
    isCorrect: boolean
    timeTakenSec?: number | null
  }

  export type QuizPaperQuestionUpdateWithoutQuestionInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    quizPaper?: QuizPaperUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizPaperQuestionUncheckedUpdateWithoutQuestionInput = {
    quizPaperId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizPaperQuestionUncheckedUpdateManyWithoutQuestionInput = {
    quizPaperId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAttemptUpdateWithoutQuestionInput = {
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
    attempt?: QuizAttemptUpdateOneRequiredWithoutQuestionAttemptsNestedInput
  }

  export type QuestionAttemptUncheckedUpdateWithoutQuestionInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutQuestionInput = {
    attemptId?: IntFieldUpdateOperationsInput | number
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizPaperQuestionCreateManyQuizPaperInput = {
    questionId: number
    position?: number | null
    timeMode?: boolean
    timeLimit?: number | null
  }

  export type QuizAssignmentCreateManyQuizPaperInput = {
    id?: number
    programId?: number | null
    startAt?: Date | string | null
    endAt?: Date | string | null
    uniqueLinkToken?: string
    timeMode?: $Enums.TimeMode
    wrongAnsMode?: $Enums.WrongAnswerMode
    resultMode?: $Enums.ResultMode
    totalTimeLimit?: number | null
    passingScore?: number | null
    enabled?: boolean
    isDeleted?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type QuizPaperQuestionUpdateWithoutQuizPaperInput = {
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    question?: QuestionPoolUpdateOneRequiredWithoutQuizPaperQuestionsNestedInput
  }

  export type QuizPaperQuestionUncheckedUpdateWithoutQuizPaperInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizPaperQuestionUncheckedUpdateManyWithoutQuizPaperInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    timeMode?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuizAssignmentUpdateWithoutQuizPaperInput = {
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneWithoutQuizAssignmentsNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutAssignmentNestedInput
  }

  export type QuizAssignmentUncheckedUpdateWithoutQuizPaperInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type QuizAssignmentUncheckedUpdateManyWithoutQuizPaperInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    startAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uniqueLinkToken?: StringFieldUpdateOperationsInput | string
    timeMode?: EnumTimeModeFieldUpdateOperationsInput | $Enums.TimeMode
    wrongAnsMode?: EnumWrongAnswerModeFieldUpdateOperationsInput | $Enums.WrongAnswerMode
    resultMode?: EnumResultModeFieldUpdateOperationsInput | $Enums.ResultMode
    totalTimeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    passingScore?: NullableIntFieldUpdateOperationsInput | number | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptCreateManyAssignmentInput = {
    id?: number
    learnerId: number
    startedAt?: Date | string
    submittedAt?: Date | string | null
    totalTimeSpent?: number | null
    score?: Decimal | DecimalJsLike | number | string | null
    passed?: boolean | null
    status: string
    createdAt?: Date | string
  }

  export type QuizAttemptUpdateWithoutAssignmentInput = {
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learner?: LearnerUpdateOneRequiredWithoutQuizAttemptsNestedInput
    questionAttempts?: QuestionAttemptUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionAttempts?: QuestionAttemptUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateManyWithoutAssignmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    learnerId?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTimeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    passed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionAttemptCreateManyAttemptInput = {
    questionId: number
    answerText?: string | null
    isCorrect: boolean
    timeTakenSec?: number | null
  }

  export type QuestionAttemptUpdateWithoutAttemptInput = {
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
    question?: QuestionPoolUpdateOneRequiredWithoutQuestionAttemptsNestedInput
  }

  export type QuestionAttemptUncheckedUpdateWithoutAttemptInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type QuestionAttemptUncheckedUpdateManyWithoutAttemptInput = {
    questionId?: IntFieldUpdateOperationsInput | number
    answerText?: NullableStringFieldUpdateOperationsInput | string | null
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    timeTakenSec?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}